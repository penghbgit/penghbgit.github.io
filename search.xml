<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bit Operation(位运算)]]></title>
    <url>%2F2017%2F10%2F26%2FoperatingSystem%2FbitOperation%2F</url>
    <content type="text"><![CDATA[位运算最近在看一些源码的时候，发现里面大量的运用了位运算，所以在这里总结一下位运算。 什么是位运算？按位操作符用来操作整数基本数据类型中的单个”比特“（bit），即二进制。按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。 位运算符的使用&amp;(按位“与”操作符)如果两个输入位都是1，则输出位为1；否则输出位为0. |（按位“或”操作符）如果两个输入位只要有一个为1，则输出位为1；否则输出位为0. ^(按位“异或”操作符)如果输入位的某一个为1，但不全是1，则输出位为1；否则输出位为0. ~(按位“非”操作符)生成与输入位相反的值。－－若输入1，输出0；输入0，输出1. &lt;&lt;(左移操作符)按照操作符右侧指定的位数，将操作符左侧的操作数向左移动（在低位补0）。a&lt;&lt;b相当于a乘以2的b次方。 &gt;&gt;(右移操作符)按照操作符右侧指定的位数，将操作符左侧的操作数向右移动。“有符号”右移操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1.相当于a除以2的b次方（取整）。 &gt;&gt;&gt;(无符号右移操作符)无论正负都在高位插入0，这个操作符在c和c++中是没有的，是java中增加的。 下面列举了一些常见的二进制位的变换操作。 功能 示例 位运算 去掉最后一位 (101101-&gt;10110) x &gt;&gt; 1 在最后加一个0 (101101-&gt;1011010) x &lt;&lt; 1 在最后加一个1 (101101-&gt;1011011) x &lt;&lt; 1+1 把最后一位变成1 (101100-&gt;101101) x &#x7C; 1 把最后一位变成0 (101101-&gt;101100) x &#x7C; 1-1 最后一位取反 (101101-&gt;101100) x ^ 1 把右数第k位变成1 (101001-&gt;101101,k=3) x &#x7C; (1 &lt;&lt; (k-1)) 把右数第k位变成0 (101101-&gt;101001,k=3) x &amp; ~ (1 &lt;&lt; (k-1)) 右数第k位取反 (101001-&gt;101101,k=3) x ^ (1 &lt;&lt; (k-1)) 取末三位 (1101101-&gt;101) x &amp; 7 取末k位 (1101101-&gt;1101,k=5) x &amp; (1 &lt;&lt; k-1) 取右数第k位 (1101101-&gt;1,k=4) x &gt;&gt; (k-1) &amp; 1 把末k位变成1 (101001-&gt;101111,k=4) x &#x7C; (1 &lt;&lt; k-1) 末k位取反 (101001-&gt;100110,k=4) x ^ (1 &lt;&lt; k-1) 把右边连续的1变成0 (100101111-&gt;100100000) x &amp; (x+1) 把右起第一个0变成1 (100101111-&gt;100111111) x &#x7C; (x+1) 把右边连续的0变成1 (11011000-&gt;11011111) x &#x7C; (x-1) 取右边连续的1 (100101111-&gt;1111) (x ^ (x+1)) &gt;&gt; 1 去掉右起第一个1的左边 (100101000-&gt;1000) x &amp; (x ^ (x-1)) （未完待续。。。）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Find the Difference]]></title>
    <url>%2F2017%2F10%2F25%2FleetCode%2FfindTheDifference%2F</url>
    <content type="text"><![CDATA[Find the Difference原题：Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example1 Input:s = “abcd”t = “abcde”Output:eExplanation:‘e’ is the letter that was added. 题目大意给定两个字符串s，t。 t是由s增加了一个字符而得到的，找出增加的字符。 解题思路有很多解法，可以用异或，可以转成Unicode码，可以利用map key的形式，这里用异或的形式。代码实现（java）：1234567891011121314class Solution &#123; public char findTheDifference(String s, String t) &#123; char c = 0; for(int i = 0; i &lt; s.length(); i++)&#123; c ^= s.charAt(i); &#125; for(int i = 0; i &lt; t.length(); i++)&#123; c ^= t.charAt(i); &#125; return c; &#125;&#125; python实现（python是不是比java代码简单许多呢）：123class Solution(object): def findTheDifference(self, s, t): return chr(reduce(operator.xor, map(ord, s + t)))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Find All Numbers Disappeared in an Array]]></title>
    <url>%2F2017%2F10%2F25%2FleetCode%2FfindAllNumbersDisappearedInAnArray%2F</url>
    <content type="text"><![CDATA[Find All Numbers Disappeared in an Array原题：Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example1 Input:[4,3,2,7,8,2,3,1]Output:[5,6] 题目大意给定一个数组，1 ≤ a[i] ≤ n，n是数组的长度。其中有的数字出现一次，有的数字出现两次，有的不出现，找出不出现的数字。 解题思路要求不能使用额外的空间。循环数组，取到每个元素的值i－1获得该元素对应的下标，把该值置为负数，再遍历一遍数组，元素为正数的位置n＋1 即为没有出现的值。代码实现（java）：123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(nums == null || nums.length == 0) return res; for(int i = 0; i &lt; nums.length; i++)&#123; int val = Math.abs(nums[i]) - 1; if(nums[val] &gt; 0) nums[val] = -nums[val]; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) &#123; res.add(i + 1); &#125; &#125; return res; &#125;&#125; python实现：123456789101112class Solution(object): def findDisappearedNumbers(self, nums): res = [] for i in range(len(nums)): val = abs(nums[i]) - 1 if nums[val] &gt; 0: nums[val] = -nums[val] for i in range(len(nums)): if nums[i] &gt; 0: res.append(i + 1) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Sum of Two Integers]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FsumOfTwoIntegers%2F</url>
    <content type="text"><![CDATA[Sum of Two Integers原题：Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example1 Given a = 1 and b = 2, return 3. 题目大意给两个数字a, b 求ab的和，不能使用＋/-. 解题思路第一个想法就是使用位运算，但是没有什么好的思路。网上查了一下：这里用到了一个半加法的思想, 即两位单独的位相加其结果可以用异或得到, 进位可以用与得到. 然后对于两个数字来说同样可以延伸这个思想.举个例子: 11+5, 其二进制形式为11: 1011, 5: 0101 那么两个位置都为1的地方就需要进位, 所以进位值就为0001. 原位置两个数相加的结果为那个位置值的异或即1110, 即两个位置值如果不一样就为1, 一样的话要么两个位置原来值都为0结果也为0, 要么进位, 那么结果依然是0. 接下来就要把进位位和下一位相加, 所以进位值左移一位,即0001变为0010, 重复上面操作可得新的进位值为0010, 原位置异或(即相加)结果为1100. 继续重复上面操作直到进位为0, 可得到最终结果10000, 即16代码实现（java）：123456789class Solution &#123; public int getSum(int a, int b) &#123; if(b == 0) return a; int r = a ^ b; int curry = (a &amp; b) &lt;&lt; 1; return getSum(r, curry); &#125;&#125; python实现就显得太不要脸了，哈哈：1234class Solution(object): def getSum(self, a, b): res = [a, b] return sum(res)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Detect Capital]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FdetectCapital%2F</url>
    <content type="text"><![CDATA[Detect Capital原题：Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: 1.All letters in this word are capitals, like “USA”.2.All letters in this word are not capitals, like “leetcode”.3.Only the first letter in this word is capital if it has more than one letter, like “Google”.Otherwise, we define that this word doesn’t use capitals in a right way. Example1 Input: “USA”Output: True Example2 Input: “FlaG”Output: False Note The input will be a non-empty word consisting of uppercase and lowercase latin letters. 题目大意给定一个字符串，如果全是大写或者小写或者首字母为大写其余全是小写 返回true 否则返回false 解题思路没什么好说的了就是判断了。代码实现（java）：1234567891011121314class Solution &#123; public boolean detectCapitalUse(String word) &#123; if (word == null) return false; if (word.equals(word.toLowerCase()) || word.equals(word.toUpperCase())) return true; if (Character.isUpperCase(word.charAt(0)))&#123; String str = word.substring(1, word.length()); if (str.equals(str.toLowerCase())) return true; &#125; return false; &#125;&#125; python实现：12345class Solution(object): def detectCapitalUse(self, word): if(word == word.upper() or word == word.lower() or word == word.capitalize()): return True return False]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Max Consecutive Ones]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FmaxConsecutiveOnes%2F</url>
    <content type="text"><![CDATA[Max Consecutive Ones原题：Given a binary array, find the maximum number of consecutive 1s in this array. Example1 Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 题目大意给定一个数组，求出里面连续1的最大个数。 解题思路第一种思路是把数组变为字符串根据0分割，求出最长的字符串。代码实现（java）：123456789101112131415class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int res = 0; StringBuilder in = new StringBuilder(); for(int num : nums)&#123; in.append(num); &#125; String[] strs = in.toString().split("0"); for(String str : strs)&#123; if(res &lt; str.length()) res = str.length(); &#125; return res; &#125;&#125; 第二种思路是把每次到0之前的长度算出来和最后结果比较把大的赋值给返回值，在去比较下一轮。代码实现（java）：1234567891011class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int res = 0; int count = 0; for(int num : nums)&#123; count = (num == 1) ? ++count : 0; res = Math.max(res, count); &#125; return res; &#125;&#125; python第二种思路实现：12345678class Solution(object): def findMaxConsecutiveOnes(self, nums): res = 0 count = 0 for i in range(len(nums)): count = count + 1 if nums[i] == 1 else 0; res = max(res, count) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Binary Number with Aliternating Bits]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FbinaryNumberWithAliternatingBits%2F</url>
    <content type="text"><![CDATA[Binary Number with Alternating Bits原题：Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example1 Input: 5Output: TrueExplanation:The binary representation of 5 is: 101 Example2 Input: 7Output: FalseExplanation:The binary representation of 7 is: 111. Example3 Input: 11Output: FalseExplanation:The binary representation of 11 is: 1011. Example4 Input: 10Output: TrueExplanation:The binary representation of 10 is: 1010. 题目大意给定一个数，判断这个数的二进制相邻的两个数都不相同。 解题思路求出二进制数，依次判断。代码实现（java）：1234567891011class Solution &#123; public boolean hasAlternatingBits(int n) &#123; String str = Integer.toBinaryString(n); for (int i = 0; i &lt; str.length() - 1; i++)&#123; if (str.charAt(i) == str.charAt(i + 1)) &#123; return false; &#125; &#125; return true; &#125;&#125; python实现：1234567class Solution(object): def hasAlternatingBits(self, n): str = bin(n).replace("0b", "") for i in range(len(str) - 1): if str[i] == str[i + 1]: return False return True]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Single Number]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FsingleNumber%2F</url>
    <content type="text"><![CDATA[Single Number原题：Given an array of integers, every element appears twice except for one. Find that single one. Note Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 题目大意给定一个数组，里面的元素有的出现两次，只有一个出现一次，找出出现一次的。 解题思路利用位运算：a^a=0 a^0=a。代码实现（java）：123456789class Solution &#123; public int singleNumber(int[] nums) &#123; int res = 0; for(int num : nums)&#123; res ^= num; &#125; return res; &#125;&#125; python实现：123456class Solution(object): def singleNumber(self, nums): res = 0 for i in range(len(nums)): res ^= nums[i] return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Nim Game]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FnimGame%2F</url>
    <content type="text"><![CDATA[Nim Game原题：You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. 题目大意题目说给我们一堆石子，每次可以拿一个两个或三个，两个人轮流拿，拿到最后一个石子的人获胜，现在给我们一堆石子的个数，问我们能不能赢。 解题思路因为每个人都取不到4个，假设自己后走，要保证每轮自己和对方取得数量的和是4，这样就能确保每轮完后都有4的倍数个石头被取走。这样，如果我们先走的话，先把n除4的余数个石头拿走，这样不管怎样，到最后都会留4个下来，对方取1个你就取3个，对方取2个你就取2个，就必赢了。代码实现（java）：12345class Solution &#123; public boolean canWinNim(int n) &#123; return (n &amp; 3) != 0; &#125;&#125; python实现：123class Solution(object): def canWinNim(self, n): return (n &amp; 3) != 0]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Longest Uncommon Subsequence I]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FlongestUncommonSubsequence1%2F</url>
    <content type="text"><![CDATA[Longest Uncommon Subsequence I原题：Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1. Example1 Input: “aba”, “cdc”Output: 3Explanation: The longest uncommon subsequence is “aba” (or “cdc”),because “aba” is a subsequence of “aba”,but not a subsequence of any other strings in the group of two strings. Note Both strings’ lengths will not exceed 100. Only letters from a ~ z will appear in input strings. 题目大意给定一组两个的字符串，您需要找到这组两个字符串中最长的不常见的子序列。 最长的不常见的子序列被定义为这些字符串之一的最长子序列，并且该子序列不应该是其他字符串的任何子序列。子序列是可以通过删除一些字符而不改变剩余元素的顺序从一个序列导出的序列。 简而言之，任何字符串本身都是一个子序列，空字符串是任何字符串的子序列。输入将是两个字符串，输出需要是最长的不常见子序列的长度。 如果最长不常见的子序列不存在，则返回-1。 解题思路因为最长子字符串就是本身，所以答案也就出来了。代码实现（java）：12345678class Solution &#123; public int findLUSlength(String a, String b) &#123; if(a.equals(b)) return -1; else return Math.max(a.length(), b.length()); &#125;&#125; python实现：123class Solution(object): def findLUSlength(self, a, b): return -1 if a == b else max(len(a), len(b))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Next Greater Element1]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FnextGreaterElement1%2F</url>
    <content type="text"><![CDATA[Next Greater Element I原题：You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number. Example1 Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1]Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. Note All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000. 题目大意给出两个数组，数组1和数组2 找出数组1中每个元素在数组2中右边最大的一位数字，如果没有返回－1. 解题思路把数组2的元素作为key，下标作为value放入map中，外层循环数组1，内层循环数组2，从map中取出当前数组1中的值的value＋1，作为起始点。判断大小。代码实现（java）：12345678910111213141516171819class Solution &#123; public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int[] res = new int[nums1.length]; for (int i = 0; i &lt; nums2.length; i++) map.put(nums2[i], i); for (int i = 0; i &lt; nums1.length; i++) &#123; int ind = -1; for (int j = map.get(nums1[i]) + 1; j &lt; nums2.length; j++) &#123; if (nums2[j] &gt; nums1[i]) &#123; ind = j; break; &#125; &#125; res[i] = ind == -1 ? -1 : nums2[ind]; &#125; return res; &#125;&#125; python实现：1234567891011121314class Solution(object): def nextGreaterElement(self, findNums, nums): map = &#123;&#125; res = [] for i in range(len(nums)): map.setdefault(nums[i], i) for i in range(len(findNums)): count = -1 for j in range(map.get(findNums[i]) + 1, len(nums)): if(nums[j] &gt; findNums[i]): count = j break res.append(-1 if count == -1 else nums[count]) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Island Perimeter]]></title>
    <url>%2F2017%2F10%2F19%2FleetCode%2FislandPerimeter%2F</url>
    <content type="text"><![CDATA[Island Perimeter原题：You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example [[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] Answer: 16Explanation: The perimeter is the 16 yellow stripes in the image below: 题目大意给出一个多维数组，为1的元素是岛屿，求岛屿的周长。 解题思路依次判断。代码实现（java）：12345678910111213141516171819202122class Solution &#123; public int islandPerimeter(int[][] grid) &#123; int w = grid.length; int h = grid[0].length; int res = 0; for (int i = 0; i &lt; w; i++)&#123; for (int j = 0; j &lt; h; j++)&#123; if(grid[i][j] == 1)&#123; if(i == 0 || grid[i - 1][j] == 0) res++; if(i == w - 1 || grid[i + 1][j] == 0) res++; if(j == 0 || grid[i][j - 1] == 0) res++; if(j == h - 1 || grid[i][j + 1] == 0) res++; &#125; &#125; &#125; return res; &#125;&#125; python实现：1234567891011121314151617class Solution(object): def islandPerimeter(self, grid): w = len(grid) h = len(grid[0]) res = 0 for i in range(w): for j in range(h): if grid[i][j] == 1: if j-1 &lt; 0 or grid[i][j-1] == 0: res += 1 if j+1 &gt;= h or grid[i][j+1] == 0: res += 1 if i-1 &lt; 0 or grid[i-1][j] == 0: res += 1 if i+1 &gt;= w or grid[i+1][j] == 0: res += 1 return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Reshape the Matrix]]></title>
    <url>%2F2017%2F10%2F19%2FleetCode%2FreshapeTheMatrix%2F</url>
    <content type="text"><![CDATA[Reshape the Matrix原题：In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data. You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were. If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example1 Input:nums =[[1,2], [3,4]]r = 1, c = 4Output:[[1,2,3,4]]Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. Example2 Input:nums =[[1,2], [3,4]]r = 2, c = 4Output:[[1,2], [3,4]]Explanation:There is no way to reshape a 2 2 matrix to a 2 4 matrix. So output the original matrix. Note The height and width of the given matrix is in range [1, 100]. The given r and c are all positive. 题目大意给出多维数组然后转换，不符合要求输出原数组。 解题思路两层循环。代码实现（java）：12345678910111213141516171819class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int w = nums.length, h = nums[0].length; if (w * h != r * c) return nums; int[][] res = new int[r][c]; int row = 0, col = 0; for (int i = 0; i &lt; w; i++) &#123; for (int j = 0; j &lt; h; j++) &#123; res[row][col] = nums[i][j]; col++; if (col == c) &#123; col = 0; row++; &#125; &#125; &#125; return res; &#125;&#125; 找规律，代码实现：123456789101112131415class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int w = nums.length; int h = nums[0].length; if (w * h == r * c) &#123; int[][] res = new int[r][c]; for (int i = 0; i &lt; r * c; i++) &#123; res[i / c][i % c] = nums[i / h][i % h]; &#125; return res; &#125; else &#123; return nums; &#125; &#125;&#125; python实现：12345678910111213141516class Solution(object): def matrixReshape(self, nums, r, c): w, h = len(nums), len(nums[0]) if w * h != r * c: return nums res = [] row = col = 0 for x in range(r): result = [] for y in range(c): result.append(nums[row][col]) col += 1 if col == h: row += 1 col = 0 res.append(result) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Fizz Buzz]]></title>
    <url>%2F2017%2F10%2F19%2FleetCode%2FfizzBuzz%2F</url>
    <content type="text"><![CDATA[Fizz Buzz原题：Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example n = 15,Return:[ “1”, “2”, “Fizz”, “4”, “Buzz”, “Fizz”, “7”, “8”, “Fizz”, “Buzz”, “11”, “Fizz”, “13”, “14”, “FizzBuzz”] 题目大意输入一个数，遍历的输出从1到这个数，遇到三的倍数输出“Fizz”，遇到5的倍数输出“Buzz”，遇到3和5共同的倍数输出“FizzBuzz”。 解题思路循环判断。代码实现（java）：123456789101112class Solution &#123; public List&lt;String&gt; fizzBuzz(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int i = 1; i &lt; n + 1; i++)&#123; if (i % 15 == 0) list.add("FizzBuzz"); else if (i % 3 == 0) list.add("Fizz"); else if (i % 5 == 0) list.add("Buzz"); else list.add(String.valueOf(i)); &#125; return list; &#125;&#125; AC后看到一位大神的代码，他是重写了AbstractList中的get方法，代码实现：123456789101112131415161718192021222324class Solution &#123; private int size = 0; private final List&lt;String&gt; fizzbuzzList = new AbstractList&lt;String&gt;() &#123; @Override public String get(int index) &#123; final int i = index + 1; return i % 15 == 0 ? "FizzBuzz" : i % 5 == 0 ? "Buzz" : i % 3 == 0 ? "Fizz" : String.valueOf(i); &#125; @Override public int size() &#123; return Solution.this.size; &#125; &#125;; public List&lt;String&gt; fizzBuzz(int n)&#123; this.size = n; return fizzbuzzList; &#125;&#125; python实现：123456789101112131415class Solution(object): def fizzBuzz(self, n): res = []; x = 1 while x &lt;= n: if x % 3 == 0 and x % 5 == 0: res.append("FizzBuzz") elif x % 3 == 0: res.append("Fizz") elif x % 5 == 0: res.append("Buzz") else: res.append(str(x)) x += 1 return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threadlocal--源码分析]]></title>
    <url>%2F2017%2F10%2F18%2Fjava%2FthreadLocal%2F</url>
    <content type="text"><![CDATA[Threadlocal详解这个类其实并不是一个线程，只是Thread的一个局部变量。看看官网的解释： 该类提供线程本地变量。这些变量与一般的变量不同，每个线程访问一个线程（通过get或set方法）有自己独立的变量初始化副本。 参数threadLocalHashCode每个对象都有一个HashCode来标示自己的唯一性1234567891011/** * ThreadLocals rely on per-thread linear-probe hash maps attached * to each thread (Thread.threadLocals and * inheritableThreadLocals). The ThreadLocal objects act as keys, * searched via threadLocalHashCode. This is a custom hash code * (useful only within ThreadLocalMaps) that eliminates collisions * in the common case where consecutively constructed ThreadLocals * are used by the same threads, while remaining well-behaved in * less common cases. */ private final int threadLocalHashCode = nextHashCode(); nextHashCode原子类保证线程安全，保证每个对象的hashcode唯一，并且是静态的123456/** * The next hash code to be given out. Updated atomically. Starts at * zero. */ private static AtomicInteger nextHashCode = new AtomicInteger(); HASH_INCREMENT是为了减少碰撞选定的这个值123456/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */ private static final int HASH_INCREMENT = 0x61c88647; nextHashCode()返回原始值，加上HASH_INCREMENT.为了让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table123456/** * Returns the next hash code. */ private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT); &#125; 方法initialValue123protected T initialValue() &#123; return null; &#125; 返回此线程局部变量的当前线程的初始值。返回值为null需要子类覆盖这个方法。 withInitial123public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) &#123; return new SuppliedThreadLocal&lt;&gt;(supplier); &#125; 创建线程局部变量。SuppliedThreadLocal类 get()123456789101112131415161718192021public T get() &#123; //获取当前线程t Thread t = Thread.currentThread(); //返回当前线程t的成员变量ThreadLocalMap ThreadLocalMap map = getMap(t); //map不为null，则获取以当前线程为key的ThreadLocalMap的Entry，如果e不为null，则直接返回该Entry的value； if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; //如果map为null或者e为null，返回setInitialValue()的值。setInitialValue()调用重写的initialValue()返回新值（如果没有重写initialValue将返回默认值null），并将新值存入当前线程的ThreadLocalMap（如果当前线程没有ThreadLocalMap，会先创建一个）。 return setInitialValue(); &#125; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; 返回该线程局部变量的当前线程的值复制。如果变量当前线程没有值，setInitialValue需要从初始化的地方取值。 setInitialValue初始化值的方法1234567891011121314151617private T setInitialValue() &#123; //调用重写的initialValue，返回新值 T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //当前线程的ThreadLocalMap不为空，则直接赋值 if (map != null) map.set(this, value); // 为当前线程创造一个ThreadLocalMap(this, firstValue)并赋初值，this为当前线程 else createMap(t, value); return value; &#125; void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; set12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; ThreadLocalMap下面看看ThreadLocal重要的内部类–ThreadLocalMapThreadLocalMap 是定义在 ThreadLocal 中的静态内部类，它是一种 Hash 的 Map，以 ThreadLocal 为 Key。但是 并不是用的继承自 Object 对象的 hashcode() 方法产生 hash 值 常量123456789101112131415161718192021222324/** * The initial capacity -- MUST be a power of two. */ //Map的初始容量 private static final int INITIAL_CAPACITY = 16; /** * The table, resized as necessary. * table.length MUST always be a power of two. */ //Entry类型的数组，用于存储数据 private Entry[] table; /** * The number of entries in the table. */ //表中的存储数目 private int size = 0; /** * The next size value at which to resize. */ //需要扩容时对应size的阈值。 private int threshold; // Default to 0 构造方法构造函数的第一个参数就是本ThreadLocal实例(this)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。注意一个细节，计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是2的指数，因为这可以使得hash发生冲突的次数减小。1234567ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; set123456789101112131415161718192021222324252627282930313233343536private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; 这里面解决冲突的方式和hashMap不同。如果key == null的话 替换当前的key和value。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; // Back up to check for prior stale entry in current run. // We clean out whole runs at a time to avoid continual // incremental rehashing due to garbage collector freeing // up refs in bunches (i.e., whenever the collector runs). int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // Find either the key or trailing null slot of run, whichever // occurs first for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // If we find key, then we need to swap it // with the stale entry to maintain hash table order. // The newly stale slot, or any other stale slot // encountered above it, can then be sent to expungeStaleEntry // to remove or rehash all of the other entries in run. if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // Start expunge at preceding stale entry if it exists if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // If we didn't find stale entry on backward scan, the // first stale entry seen while scanning for key is the // first still present in the run. if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // If key not found, put new entry in stale slot tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // If there are any other stale entries in run, expunge them if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); &#125; 该方法中会清理没用的entry,调用cleanSomeSlots方法实现的。123456789101112131415private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed; &#125; 总结1.线程间数据隔离（每个线程在自己线程里使用自己的局部变量，各线程间的ThreadLocal对象互不影响）；2.ThreadLocal的应用场景非常多，（获取数据库连接，各大框架都有应用，比如Spring）3.每个Thread里都含有一个ThreadLocalMap的成员变量；4.当应用线程池的时候，由于线程池的线程一般会复用，Thread不结束，这时候用完更需要remove了。5.对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Distribute Candies]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FdistributeCandies%2F</url>
    <content type="text"><![CDATA[Distribute Candies原题：Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. You need to return the sum of the points you could get in all the rounds. Example1 Input: candies = [1,1,2,2,3,3]Output: 3Explanation:There are three different kinds of candies (1, 2 and 3), and two candies for each kind.Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.The sister has three different kinds of candies. Example2 Input: candies = [1,1,2,3]Output: 2Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].The sister has two different kinds of candies, the brother has only one kind of candies. Note The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000]. 题目大意把不同种类的糖平均分两份，一份哥哥一份妹妹，求妹妹获得糖的最多种类数 解题思路求出糖的种类，如果种类大于糖数量的一半，则妹妹最多分的数量为糖数量的一半，否则为糖的种类两种实现（java）：代码实现（java）：1234567891011class Solution &#123; public int distributeCandies(int[] candies) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int candy : candies)&#123; set.add(candy); &#125; if (set.size() &gt; candies.length/2) return candies.length/2; return set.size(); &#125;&#125; 123456789class Solution &#123; public int distributeCandies(int[] candies) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int candy : candies)&#123; set.add(candy); &#125; return Math.min(set.size(), candies.length &gt;&gt; 1); &#125;&#125; python实现：123class Solution(object): def distributeCandies(self, candies): return min(len(set(candies)), len(candies) &gt;&gt; 1)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Baseball Game]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FbaseballGame%2F</url>
    <content type="text"><![CDATA[Baseball Game原题：You’re now a baseball game point recorder. Given a list of strings, each string can be one of the 4 following types: 1.Integer (one round’s score): Directly represents the number of points you get in this round.2.”+” (one round’s score): Represents that the points you get in this round are the sum of the last two valid round’s points.3.”D” (one round’s score): Represents that the points you get in this round are the doubled data of the last valid round’s points.4.”C” (an operation, which isn’t a round’s score): Represents the last valid round’s points you get were invalid and should be removed.Each round’s operation is permanent and could have an impact on the round before and the round after. You need to return the sum of the points you could get in all the rounds. Example1 Input: [“5”,”2”,”C”,”D”,”+”]Output: 30Explanation:Round 1: You could get 5 points. The sum is: 5.Round 2: You could get 2 points. The sum is: 7.Operation 1: The round 2’s data was invalid. The sum is: 5.Round 3: You could get 10 points (the round 2’s data has been removed). The sum is: 15.Round 4: You could get 5 + 10 = 15 points. The sum is: 30. Example2 Input: [“5”,”-2”,”4”,”C”,”D”,”9”,”+”,”+”]Output: 27Explanation:Round 1: You could get 5 points. The sum is: 5.Round 2: You could get -2 points. The sum is: 3.Round 3: You could get 4 points. The sum is: 7.Operation 1: The round 3’s data is invalid. The sum is: 3.Round 4: You could get -4 points (the round 3’s data has been removed). The sum is: -1.Round 5: You could get 9 points. The sum is: 8.Round 6: You could get -4 + 9 = 5 points. The sum is 13.Round 7: You could get 9 + 5 = 14 points. The sum is 27. Note The size of the input list will be between 1 and 1000. Every integer represented in the list will be between -30000 and 30000. 题目大意输入一组字符串：1.数字表示分数2.’+’表示当前轮次的分数等于上两轮分数之和3.’D’表示当前轮次的分数等于上一轮分数加倍4.’C’表示清除上一次的分数 解题思路根据不同的情况做判断，先想到了栈，然后又想到了数组。两种实现（java）：代码实现（java）：1234567891011121314151617181920212223class Solution &#123; public int calPoints(String[] ops) &#123; if (ops == null || ops.length == 0) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int res = 0; for (String op : ops)&#123; if ("C".equals(op))&#123; res -= stack.pop(); &#125;else if ("D".equals(op))&#123; stack.push(stack.peek() * 2); res += stack.peek(); &#125;else if ("+".equals(op))&#123; stack.push(stack.peek() + stack.get(stack.size()-2)); res += stack.peek(); &#125;else &#123; stack.push(Integer.valueOf(op)); res += stack.peek(); &#125; &#125; return res; &#125;&#125; 用栈实现运行时间11ms，用数组实现运行时间8ms，见代码：123456789101112131415161718192021222324252627class Solution &#123; public int calPoints(String[] ops) &#123; if (ops == null || ops.length == 0) return 0; int[] points = new int[ops.length]; int top = -1; int res = 0; for(String op : ops)&#123; if("C".equals(op))&#123; res -= points[top--]; &#125;else if("D".equals(op))&#123; int p = points[top]*2; points[++top] = p; res += p; &#125;else if("+".equals(op))&#123; int p = points[top] + points[top - 1]; points[++top] = p; res += p; &#125;else&#123; int p = Integer.parseInt(op); points[++top] = p ; res += p; &#125; &#125; return res; &#125;&#125; python实现：12345678910111213141516class Solution(object): def calPoints(self, ops): res = 0 points = [] top = -1 for op in ops: if op == "C": points.pop() elif op == "D": points.append(points[-1] * 2) elif op == "+": points.append(points[-1] + points[-2]) else: points.append(int(op)) return sum(points)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Reverse String]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FreverseString%2F</url>
    <content type="text"><![CDATA[Reverse String原题：Write a function that takes a string as input and returns the string reversed. Example Given s = “hello”, return “olleh”. 翻译相对简单，就是翻转一个字符串。 代码实现（java）：12345class Solution &#123; public String reverseString(String s) &#123; return new StringBuilder(s).reverse().toString(); &#125;&#125; 用StringBuilder的reverse()运行时间用了4ms。尝试用了异或位运算，用时减少了一倍，变为2ms，代码实现：12345678910111213141516class Solution &#123; public String reverseString(String s) &#123; char[] str = s.toCharArray(); int begin = 0; int end = s.length() - 1; while (begin &lt; end) &#123; str[begin] = (char) (str[begin] ^ str[end]); str[end] = (char) (str[begin] ^ str[end]); str[begin] = (char) (str[end] ^ str[begin]); begin++; end--; &#125; return new String(str); &#125;&#125; python实现：123class Solution(object): def reverseString(self, s): return s[::-1]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Reverse Words in a String III]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FreverseWords3%2F</url>
    <content type="text"><![CDATA[Reverse Words in a String III原题：Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example Input: “Let’s take LeetCode contest”Output: “s’teL ekat edoCteeL tsetnoc” NoteIn the string, each word is separated by single space and there will not be any extra space in the string. 翻译大意就是给定一个list输出每个单词的顺序原来不变，单词的顺序反转。 解题思路根据空格拆分，然后依次反转每个单词。代码实现（java）：1234567891011121314151617class Solution &#123; public String reverseWords(String s) &#123; String[] strs = s.split(" "); StringBuilder sb = new StringBuilder(); boolean t = true; for(String str : strs)&#123; String resWord = new StringBuilder(str).reverse().toString(); if(t)&#123; sb.append(resWord); t = false; &#125;else&#123; sb.append(" ").append(resWord); &#125; &#125; return sb.toString(); &#125;&#125; python实现：1234567class Solution(object): def reverseWords(self, s): list = s.split() k = [] for n in list: k.append(n[::-1]) return ' '.join(k)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--keyboardRow]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FkeyboardRow%2F</url>
    <content type="text"><![CDATA[Keyboard Row原题：Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. Example Input: [“Hello”, “Alaska”, “Dad”, “Peace”]Output: [“Alaska”, “Dad”] Note1.You may use one character in the keyboard more than once.2.You may assume the input string will only contain letters of alphabet. 翻译大意就是给定一个list输出单词都在同一行的单词。 解题思路设定每行代表一个数字初始值为0，遍历每个单词如果出现在某一行，则该代表该行的值赋为1.代码实现（java）：12345678910111213141516171819202122232425class Solution &#123; public String[] findWords(String[] words) &#123; String line1 = "QWERTYUIOP"; String line2 = "ASDFGHJKL"; String line3 = "ZXCVBNM"; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); for(String word : words)&#123; char[] ch = word.toUpperCase().toCharArray(); int n1 = 0, n2 = 0, n3 = 0; for(char c : ch)&#123; if(line1.indexOf(c) &gt;= 0) n1 = 1; if(line2.indexOf(c) &gt;= 0) n2 = 1; if(line3.indexOf(c) &gt;= 0) n3 = 1; if(n1 + n2 + n3 &gt; 1) break; &#125; if(n1 + n2 + n3 == 1) res.add(word); &#125; return res.toArray(new String[0]); &#125;&#125; python实现（遍历list中的每个单词放到set中判断set中的单词是否都包含在键盘行中）：12345678910class Solution(object): def findWords(self, words): keyBoards = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"] res = [] for word in words: wordUP = word.upper() for keyBoard in keyBoards: if set(wordUP).issubset(set(keyBoard)): res.append(word) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python内置函数--set]]></title>
    <url>%2F2017%2F10%2F16%2Fpython%2FpythonSet%2F</url>
    <content type="text"><![CDATA[描述set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。set 支持 x in set, len(set),和 for x in set。作为一个无序的集合，set不记录元素位置或者插入点。因此，set不支持 indexing, slicing（切片）, 或其它类序列（sequence-like）的操作。 语法set([iterable]) iterable– 可迭代对象 返回值返回新的集合对象。 实例使用12345x = set("facebook")y = set("google")print x, youtput: set(['a', 'c', 'b', 'e', 'f', 'k', 'o']) set(['e', 'o', 'g', 'l']) 交集(x &amp; y)12345x = set("facebook")y = set("google")print x &amp; youtput: set(['e', 'o']) 并集(x | y)12345x = set("facebook")y = set("google")print x | youtput: set(['a', 'c', 'b', 'e', 'g', 'f', 'k', 'l', 'o']) 差集(x - y)12345x = set("facebook")y = set("google")print x - youtput: set(['a', 'c', 'b', 'k', 'f']) 操作add把传入的元素做为一个整个添加到集合中12345x = set("facebook")x.add('vmlp')print xoutput: set(['a', 'c', 'b', 'e', 'f', 'k', 'o', 'vmlp']) update把传入的元素拆分，做为个体传入到集合中 （x |= y ,y只能是set ）12345x = set("facebook")x.update('vmlp')print xoutput: set(['a', 'c', 'b', 'e', 'f', 'k', 'm', 'l', 'o', 'p', 'v']) remove把传入的元素删除,如果不存在则引发 KeyError12345x = set("facebook")x.remove('o')print xoutput: set(['a', 'c', 'b', 'e', 'f', 'k']) 方法issubsetx.issubset(y)相当于 x &lt;= y测试是否x中的每一个元素都在y中12345x = set("book")y = set("booklalagood")print x.issubset(y)output: True issupersetx.issuperset(y)相当于 x &gt;= y测试是否t中的每一个元素都在x中(与issubset相反)12345x = set("book")y = set("booklalagood")print y.issubset(x)output: True unionx.union(y)相当于 x | y返回一个新的set包含x和y中的每一个元素12345x = set("book")y = set("booklalagood")print x.union(y)output: set(['a', 'b', 'd', 'g', 'k', 'l', 'o']) intersectionx.intersection(y)相当于 x &amp; y返回一个新的set包含x和y中的公共元素 differencex.difference(y)相当于 x - y返回一个新的set包含x中有但是y中没有的元素 differencex.symmetric_difference(y)相当于 x ^ y返回一个新的set包含x和y中不重复的元素 copyx.copy()返回set“x”的一个浅复制 intersection_updatex.intersection_update(y)相当于 x &amp;= y返回只保留含有set“y”中元素的set“x” difference_updatex.difference_update(y)相当于 x -= y返回删除了set“y”中含有的元素后的set“x” difference_updatex.symmetric_difference_update(y)相当于x ^= y返回含有 set“y”或者set“x”中有而不是两者都有的元素的set“x” discardx.discard(b)如果在set“x”中存在元素b,则删除 popx.pop()删除并且返回set“x”中的一个不确定的元素,如果为空则引发KeyError clearx.clear()删除set“x”中的所有元素]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python--切片]]></title>
    <url>%2F2017%2F10%2F16%2Fpython%2FpythonSlice%2F</url>
    <content type="text"><![CDATA[什么是切片？可以用方括号加一个下标的方式访问序列的每一个元素，或者通过在方括号中用冒号把开始下标和结束下标分开的方式访问一组连续的元素。序列类型是其元素被顺序放置的一种数据类型结构，这种方式允许通过指定下标的方式来获取某一个数据元素，或者通过指定下标范围来获得一组序列的元素。这种访问序列的方式叫做切片，我们通过切片操作符就可以实现这个操作。 切片操作符[]sequence[index]sequence是序列的名字，index是想要访问元素对应的偏移量。可以使用0到最大值，也可以使用负值。正索引以序列的开始为起点，负索引以序列的结束为起点。如图(引用): [:]sequence[start_index: end_index]通过这种方式可以得到起始索引到结束索引之间的数据。如果没有提供切片会从序列的最开始处开始，直到最末尾处结束。 [::]sequence[start_index: end_index: delta]delta变化量（步长），可以把这个参数当做for循环里的步长一样的东西。 注意: 列表切片产生的是列表的副本，与原列表不是同一份空间。 例子1定义一个列表 str = [1, 2, 3, 4, 5, 6, 7, 8] 12print str[3:] #截取第4个字符到结尾 output: [4, 5, 6, 7, 8] 12print str[:-3] #截取从头开始到倒数第三个字符之前output: [1, 2, 3, 4, 5] 12print str[2] #截取第三个字符 output: 3 12print str[-1] #截取倒数第一个字符 output: 8 12print str[::-1] #创造一个与原字符串顺序相反的字符串 output: [8, 7, 6, 5, 4, 3, 2, 1] 12print str[-3:-1] #截取倒数第三位与倒数第一位之前的字符 output: [6, 7] 12print str[-3:] #截取倒数第三位到结尾output: [6, 7, 8] 12print str[:-5:-3] #逆序截取output: [8, 5] 参考：《Python核心编程中文版（第二版）》]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <url>%2F2017%2F10%2F15%2Fjava%2FhashMap%2F</url>
    <content type="text"><![CDATA[HashMap基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。HashMap有两个参数影响其性能：初始容量和加载因子。默认初始容量是16，加载因子是0.75。容量是哈希表中桶(Entry数组)的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，通过调用resize方法将容量翻倍。本文是基于JDK1.8分析的，JDK 1.8中HashMap的实现有了一些改进，数据存储结构引进了红黑树，使得查询更加的快捷.JDK1.8 HashMap的结构： HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。1Map map = Collections.synchronizedMap(new HashMap()); 也可以使用ConcurrentHashMap。 定义12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 我们可以看出，HashMap继承了AbstractMap抽象类，实现了Map的方法。 属性1234567891011121314151617181920212223242526272829303132333435 //默认初始容量为16，必须为2的幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //最大容量为2的30次方 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; //链表转成红黑树的阈值 static final int TREEIFY_THRESHOLD = 8; //红黑树转为链表的阈值 static final int UNTREEIFY_THRESHOLD = 6; //存储方式由链表转成红黑树的容量的最小阈值 static final int MIN_TREEIFY_CAPACITY = 64; //存储元素的数组，总是2的幂次倍 transient Node&lt;k,v&gt;[] table; //存放具体元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; //存放元素的个数，注意这个不等于数组的长度。 transient int size; //每次扩容和更改map结构的计数器 transient int modCount; //临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; //加载因子 final float loadFactor; 构造方法HashMap有4个构造方法，有参的构造方法验证参数，无参的构造方法用默认的属性。下面我们主要介绍其中的两个构造方法（一）123456789101112public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; 返回目标容量对应的2的幂次方。123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; (二)将m中的所有元素添加至HashMap中1234public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 实现了putAll的操作，将m的所有元素存入本HashMap实例中。12345678910111213141516171819final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125; &#125; 主要方法hashkey的哈希值为数组下标12345static final int hash(Object key) &#123; int h; //右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; get返回指定key所映射的value；如果该键不包含任何映射关系，则返回null1234567891011121314151617181920212223242526272829public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //table不为null，长度大于0，根据hash寻找table中的项也不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //检查第一个节点 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; //为红黑树结点 if (first instanceof TreeNode) //在红黑树中查找 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //否则，在链表中查找 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; put在学习put方法之前先看一下内部类Node123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; Node类是HashMap中内部定义的一个单向链表。Node中存储了key的hash值，键值对，同时还有下一个链表元素。我们重点关注一下equals这个方法，当我们算出的key的hash值相同时，put方法并不会报错，而是继续向这个hash值的链表中添加元素。我们会调用equals方法来比对key和value是否相同，如果equals方法返回false，会继续向链表的尾部添加一个键值对。JDK1.8中引入了红黑树内部类为TreeNode，（由于本人对红黑树不是很了解，后期会补上这部分）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //table未初始化或者长度为0，进行扩容（详见resize方法） if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //根据长度-1和hash值进行按位与运算，算出hash值对应于数组中的位置，从tab中将这个位置上面的内容取出，判断为null时，在这个位置新增一个Node。 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //key存在，覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //如果冲突节点达到8个，调用treeifyBin(tab, hash)，这个treeifyBin首先会去判断当前hash表的长度，如果不足64的话，实际上就只进行resize，扩容table，如果已经达到64，那么才会将冲突项存储结构改为红黑树。 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //如果有相同的hash和key，则退出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //将p调整为下一个节点 p = e; &#125; &#125; //若e不为null，表示已经存在与待插入节点hash、key相同的节点，hashmap后插入的key值对应的value会覆盖以前相同key值对应的value值，就是下面这块代码实现的 if (e != null) &#123; // existing mapping for key V oldValue = e.value; //判断是否修改已插入节点的value if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //超过阀值，扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; resize(扩容)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //如果老的数组容量大于0，首先判断是否大于等于HashMap的最大容量， //如果true，将阈值设置为Integer的最大值，同时数组容量不变 if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //如果扩容后的数组容量小于我们规定的最大数组容量，而且老的数组容量大于等于16， //对数组进行扩容，扩容后的数组容量为原来的两倍；同时阈值也扩容为原来的两倍（左移一位实现） else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; //之前table大小不大于0,而且老的阈值大于0，则新的容量=老的阈值 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; //老的阈值=0，容量和阈值都初始化为默认值，即16和12 else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //如果新的阈值为0，为新的阈值赋值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) //定义一个新的容量的数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //如果老的数组不为空，遍历老的数组 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; //如果链表中只有一个数据，直接重新计算hash值，放入新的数组中 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; //如果e是红黑树，需要将红黑树拆分后放入新的数组中 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 链表优化重hash的代码块 else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; //原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; JDK1.8做了优化： 我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 总结其他方法和上面介绍的方法原理基本一致，有兴趣的同学可以自行查看源码。(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。(3) JDK1.8引入红黑树大程度优化了HashMap的性能。 参考：http://www.importnew.com/20386.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Two Sum II - Input array is sorted]]></title>
    <url>%2F2017%2F10%2F14%2FleetCode%2FtwoSum2%2F</url>
    <content type="text"><![CDATA[Two Sum II - Input array is sorted原题：Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. 翻译大意是给出一个数组（升序）和一个目标数，求数组中的两个数相加正好等于目标数的两个元素的下标 解题思路left代表左下标，right代表右下标，numbers[left] + numbers[right]如果等于target返回两个下标志分别加一，如果大于target，right左移，否则left右移。代码实现（java）：12345678910111213141516class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int left = 0; int right = numbers.length - 1; while(right &gt; left)&#123; int res = numbers[left] + numbers[right]; if(res == target) return new int[]&#123;left + 1, right + 1&#125;; else if(res &lt; target) left++; else right--; &#125; return null; &#125;&#125; 代码实现（python）：12345678910111213class Solution(object): def twoSum(self, numbers, target): left = 0 right = len(numbers) - 1 while(right &gt; left): res = numbers[left] + numbers[right] if res == target: return left + 1, right + 1 elif res &lt; target: left += 1 else: right -= 1 return null]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Add Digits]]></title>
    <url>%2F2017%2F10%2F11%2FleetCode%2FaddDigits%2F</url>
    <content type="text"><![CDATA[Add Digits原题Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. 翻译大概意思就是给你一个数，把这个数的各个位上的数相加，得到一个新的数，重复下去直到最后相加出来的数为个位数为止。 解题思路：我最开始想的是把每位上的数取出来相加，然后利用递归去做，直到得到符合的答案，原题要求不用循环和递归用O(1)的时间复杂度求出结果，很显然这不符合的。然后想到找规律，发现num%9符合规律，测试发现9%9的时候出现问题，于是改成（num－1）％9+1，代码实现（java）：123public int addDigits(int num) &#123; return (num - 1) % 9 + 1; &#125; 代码实现（python）：1234def addDigits(self, num): if(num == 0): return 0 return (num - 1) % 9 + 1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Array Partition I]]></title>
    <url>%2F2017%2F10%2F11%2FleetCode%2FarrayPartition1%2F</url>
    <content type="text"><![CDATA[Array Partition I原题Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example Input: [1,4,3,2] Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = &gt;min(1, 2) + min(3, 4). 翻译大概意思就是给定一个长度为2n的数组，分成n个小组，返回每组中较小值的和sum，使sum尽量大 解题思路：要取sum为最大值，分组的话就要把两个大的数分在一起，然后以此类推，所以先把数组排序，依次把下标为偶数位的值相加即为所求值。代码实现（java）：1234567public int arrayPairSum(int[] nums) &#123; Arrays.sort(nums); int res = 0; for(int i = 0; i &lt; nums.length; i += 2) res += nums[i]; return res; &#125; 发现有很多大神的代码执行时间更少，发现他们用的排序算法是计数排序。每隔一个数进行相加：代码实现（python）：12345678def arrayPairSum(self, nums): if isinstance(nums, list) and len(nums) == 0: return 0 nums.sort() res = 0 for i in range(0, len(nums), 2): res += nums[i] return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Judge Route Circle]]></title>
    <url>%2F2017%2F10%2F10%2FleetCode%2FjudgeRouteCircle%2F</url>
    <content type="text"><![CDATA[Judge Route Circle原题Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle. Example Input: “UD”Output: true Input: “LL”Output: false 翻译大概意思就是起点为（0，0），R(右),L(左),U(上)和D(下).给定一串移动的串，判断最后是否回到原点。 解题思路：这是一个横纵坐标移动的问题，向左移动x–，向右x++，向上y++，向下y–，最后判断 x == 0 &amp;&amp; y == 0即可。代码实现（java）：1234567891011121314151617181920212223242526public boolean judgeCircle(String moves) &#123; if(moves == null || "".equals(moves)) return true; int x = 0; int y = 0; for(int i = 0; i&lt;moves.length(); i++)&#123; char c = moves.charAt(i); switch(c)&#123; case 'U': y++; break; case 'D': y--; break; case 'L': x--; break; case 'R': x++; break; &#125; &#125; if(x == 0 &amp;&amp; y == 0) return true; return false; &#125; 也可以判断给定的字符串中UD和LR是否成对的出现。代码实现（python）：12def judgeCircle(self, moves): return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D')]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread源码分析]]></title>
    <url>%2F2017%2F10%2F10%2Fjava%2Fthread%2F</url>
    <content type="text"><![CDATA[什么是线程？线程可以理解为在进程中独立运行的子任务。线程是CPU调度的最基本单元。线程的资源开销相对于进程的开销是相对较少的，所以我们一般创建线程执行，而不是进程执行。java中要创建一个线程可以继承Thread类和实现Runnable接口。 注意：多线程是异步的。 下面我们来看一下Thread类的源码。12publicclass Thread implements Runnable 从上面的代码中可以看到，Thread实现了Runnable接口，它们之间具有多态关系。创建一个线程可以继承thread类或者实现Runnable接口，这两种创建方式在工作时性质是一样的，没有本质区别。 线程是一个子任务，cpu以不确定的时间来调用线程中的run方法。 native关键字简介1234private static native void registerNatives(); static &#123; registerNatives(); &#125; native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（Java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。不过，对Java外部的调用通常不能移植到其他平台，在applet中还可能引发安全异常。实现本地代码将使您的Java应用程序无法通过100%纯Java测试。但是，如果必须执行本地调用，则要考虑几个准则： 将您的所有本地方法都封装到一个类中，这个类调用单个的DLL。对每一种目标操作系统平台，都可以用特定于适当平台的版本的DLL。这样可以将本地代码的影响减少到最小，并有助于将以后所需要的移植问题考虑在内。 本地方法尽量简单。尽量使您的本地方法对第三方（包括Microsoft）运行时DLL的依赖减少到最小。使您的本地方法尽量独立，以将加载您的DLL和应用程序所需的开销减少到最小。如果需要运行时DLL，必须随应用程序一起提供。 变量name12//线程名，volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。使得该变量是线程间可见的。private volatile String name; priority12//线程执行优先级private int priority; single_step12//是否单独执行此线程private boolean single_step; daemon12//线程是否是守护线程private boolean daemon = false; stillborn12//虚拟机状态 private boolean stillborn = false; target12//实际的线程任务 private Runnable target; group12//这个线程的组 private ThreadGroup group; contextClassLoader12//这个线程的上下文类加载器 private ClassLoader contextClassLoader; inheritedAccessControlContext12//这个线程的继承 private AccessControlContext inheritedAccessControlContext; threadInitNumber12//所有初始化线程的数目 private static int threadInitNumber; threadLocals &amp; inheritableThreadLocals123//这是为ThreadLocal类维护的一些变量ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; stackSize12//此线程请求的堆栈大小，如果创建者未指定堆栈大小，则为0。虚拟机可以用这个数字来做任何喜欢的事情一些虚拟机将忽略它。 private long stackSize; nativeParkEventPointer12//本地线程终止后仍然存在的JVM私有状态。 private long nativeParkEventPointer; tid &amp; threadSeqNumber123//线程id相关private long tid;private static long threadSeqNumber; threadStatus12//线程状态，初始化为指示线程尚未启动private volatile int threadStatus = 0; blocker12//在可中断的I / O操作（如果有）中阻塞此线程的对象。在设置此线程的中断状态后，应调用阻塞程序的中断方法。private volatile Interruptible blocker; 线程优先级12345678//线程为最低优先级。 public final static int MIN_PRIORITY = 1; //分配给线程的默认优先级。 public final static int NORM_PRIORITY = 5; //线程拥有最高优先级 public final static int MAX_PRIORITY = 10; native方法123456789101112131415161718192021222324252627282930313233//返回对当前正在执行的线程对象的引用。 public static native Thread currentThread(); //使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了 public static native void yield();//当前正在执行的线程（this.currentThread()）休眠（暂停执行）指定的毫秒数，这取决于系统定时器和调度程序的精度和准确性。线程不会丢失monitors。public static native void sleep(long millis) throws InterruptedException;//通过C代码初始化线程需要的系统资源。 private native void start0();//强制停止一个线程（不建议使用） @Deprecated public final synchronized void stop(Throwable obj) //只是设置中断标志 private native void interrupt0(); //检查一个线程是否处于活动状态。（活动状态指已经启动且尚未终止） public final native boolean isAlive(); //暂停线程 private native void suspend0(); //重新激活一个线程 private native void resume0(); //设置线程优先级 private native void setPriority0(int newPriority);//放弃当前cpu资源，让给其他任务（但是放弃的时间不确定） public static native void yield(); 构造方法Thread有好8个构造方法，最终都是调用这个辅助构造函数。接下来我们就来详细的看看init方法到底是怎么来初始化线程的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 初始化线程 * * @param g 线程组 * @param target run（）方法被调用的对象 * @param name 新线程的name * @param stackSize 新线程所需的堆栈大小，零表示此参数将被忽略。 * @param acc AccessControlContext继承，或AccessController.getContext（）为null * @param inheritThreadLocals 如果&#123;@code true&#125;，继承初始值来自构造线程的可继承线程 */private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; if (name == null) &#123; throw new NullPointerException("name cannot be null"); &#125; this.name = name; //当前线程就是该线程的父线程 Thread parent = currentThread(); //获取系统的安全管理器 SecurityManager security = System.getSecurityManager(); if (g == null) &#123; //security不为null时，线程所在group为security的group if (security != null) &#123; g = security.getThreadGroup(); &#125; //security为null时，使用父线程的group if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; //确定当前运行的线程是否有权限修改此线程组。 g.checkAccess(); //检查权限 if (security != null) &#123; if (isCCLOverridden(getClass())) &#123; security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); &#125; &#125; g.addUnstarted(); //将线程组、守护线程、优先级等设置为父线程的对应属性 this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); //从父线程继承可继承的ThreadLocal if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); //设置该线程堆栈大小 this.stackSize = stackSize; //设置线程id tid = nextThreadID(); &#125; 主要方法启动start12345678910111213141516171819202122232425//线程启动方法public synchronized void start() &#123; //当前线程初始化还未做好，不能start，0-&gt;NEW状态 if (threadStatus != 0) throw new IllegalThreadStateException(); //通知group该线程即将启动，group的nUnstartedThreads减1,nthreads加1 group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; //启动不成功，group设置当前线程启动失败 if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125; &#125; 启动线程其实做了这么几件事： 检查线程是否初始化； 通知group，线程启动； 调用native方法start0()启动线程，启动后执行run()方法； 启动失败容错处理。 run123456@Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 真正的run其实是目标类的run方法,target实际上要保存的是一个Runnable接口的实现的引用。 停止停止一个线程可以用Thread.stop()方法，但最好不要使用它。因为这个方法是不安全的。（可能使一些清理性的工作得不到完成，对锁定的对象进行“解锁”，出现数据不一致。） stop12345678910111213141516171819//强制线程停止执行。（不建议使用） @Deprecatedpublic final void stop() &#123; SecurityManager security = System.getSecurityManager(); if (security != null) &#123; checkAccess(); if (this != Thread.currentThread()) &#123; security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION); &#125; &#125; // A zero status value corresponds to "NEW", it can't change to // not-NEW because we hold the lock. if (threadStatus != 0) &#123; resume(); // Wake up thread if it was suspended; no-op otherwise &#125; // The VM can handle all thread states stop0(new ThreadDeath()); &#125; interrupt1234567891011121314public void interrupt() &#123; if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125; &#125; interrupt0(); &#125; interrupt()方法只是在当前线程中打了一个停止标记，并不是真的停止了线程。 interrupted &amp; isInterrupted123456789//测试当前线程是否已经中断(线程的中断状态由该方法清除)public static boolean interrupted() &#123; return currentThread().isInterrupted(true); &#125;//测试线程是否中断（不清除线程的中断状态） public boolean isInterrupted() &#123; return isInterrupted(false); &#125; 几种停止线程的方法 可以通过判断当前线程是否中断，如果是中断抛出异常去停止一个线程。 可以在sleep（）状态下停止线程。 interrupt()方法和return结合使用。 比较建议使用“抛异常”的方法实现停止线程，因为在catch中可以对异常进行相关的处理，而且使用异常处理能更好、更方便的控制程序的运行流程。 暂停线程暂停线程意味着此线程还可以恢复运行。在java中可以使用suspend()方法暂停线程，使用resume()方法恢复线程。 suspend123456//暂停一个线程（不推荐使用）依靠本地方法suspend0，可能会造成死锁和不同步@Deprecated public final void suspend() &#123; checkAccess(); suspend0(); &#125; resume123456//重新激活一个线程（不推荐使用）依靠本地方法resume0，可能会造成死锁和不同步@Deprecated public final void resume() &#123; checkAccess(); resume0(); &#125; join123456789101112131415161718192021222324public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125; &#125; join会锁住当前线程，等待子线程结束之后继续执行。如图: 其他方法exit1234567891011121314//由系统调用，可以使Thread在销毁前释放资源private void exit() &#123; if (group != null) &#123; group.threadTerminated(this); group = null; &#125; target = null; /* Speed the release of some of these resources */ threadLocals = null; inheritableThreadLocals = null; inheritedAccessControlContext = null; blocker = null; uncaughtExceptionHandler = null; &#125; checkAccess1234567//确定当前运行的线程是否有权限修改此线程。public final void checkAccess() &#123; SecurityManager security = System.getSecurityManager(); if (security != null) &#123; security.checkAccess(this); &#125; &#125; dumpStack1234//将当前线程的堆栈跟踪打印到标准错误流。此方法仅用于调试。public static void dumpStack() &#123; new Exception("Stack trace").printStackTrace(); &#125; 还有一些方法没有看到，就不一一概述了。 线程的状态Thread中有个状态枚举： NEW：初始状态，线程被构建，还未调用start()方法； RUNNABLE：运行状态，在java多线程模型中，就绪和运行都是运行状态； BLOCKED：阻塞状态； WAITING：等待状态，比如中断，需要其他的线程来唤醒； TIME_WAITING：超时等待，可以在指定的时间内自行返回； TERMINATED：终止状态，线程执行完毕。 java层次的状态转换图 操作系统层次的状态转换图 总结wait()和notify/notifyAll()线程中常用wait()和notify/notifyAll()方法，这是Object类中的方法。 wait()线程进入WAITING状态，并且释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁，等待其他线程调用“锁标志“对象的notify或notifyAll方法恢复wait方法是一个本地方法，其底层是通过一个叫做监视器锁的对象来完成的，所以调用wait方式时必须获取到monitor对象的所有权即通过Synchronized关键字，否则抛出IllegalMonitorStateException异常 notify &amp; notifyAll()在同一对象上去调用notify/notifyAll方法，就可以唤醒对应对象monitor上等待的线程了。notify和notifyAll的区别在于前者只能唤醒monitor上的一个线程，对其他线程没有影响，而notifyAll则唤醒所有的线程 线程复用像线程池类高效的原因在于，线程池中的线程在完成任务后，不会销毁，而且缓存起来，每当用户请求一个线程处理任务时，线程池可以利用缓存的空闲线程来处理用户任务，这样避免了线程创建销毁带来的开销。在Thread类中有一个Runnable target的域，只需将target替换成新的Runnable即可。后续会写一些线程池相关的文章。 更深入学习Thread类中有许多native方法，更深入的学习后续还需研究研究jvm的源码。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Valid Palindrome]]></title>
    <url>%2F2017%2F10%2F09%2FleetCode%2FvalidPalindrome%2F</url>
    <content type="text"><![CDATA[原题Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example, “A man, a plan, a canal: Panama” is a palindrome.“race a car” is not a palindrome. 翻译：给定一个字符串，判断其是否为一个回文串。只包含字母和数字，忽略大小写。 解题思路利用首尾指针，找到符合条件的索引，进行比较，符合条件进行下一组比较，不相等返回false，直到所有的字母都处理完。 代码实现java实现，时间复杂度O(n).12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public Boolean solution(String str)&#123; if(str == null || "".equals(str)) return true; str = str.toLowerCase(); int left = 0; int right = str.length() - 1; while (left &lt; right) &#123; char leftChar = str.charAt(left); char rightChar = str.charAt(right); while (!isValid(leftChar))&#123; left++; leftChar = str.charAt(left); if (left &gt;= right) return true; &#125; while (!isValid(rightChar))&#123; right--; rightChar = str.charAt(right); if (right &lt;= left) return true; &#125; if (leftChar != rightChar) return false; left++; right--; &#125; return true; &#125; private Boolean isValid(Character character)&#123; if (Character.isLetterOrDigit(character)) return true; return false; &#125;&#125; python实现1234567891011121314151617181920212223242526272829303132333435class Solution: def palindrome(self, str): if str.strip() == "": return True str = str.lower() left = 0 right = len(str) - 1 while(left &lt; right): leftStr = str[left] rightStr = str[right] while(not self.__isvalid(leftStr)): left += 1 leftStr = str[left] if(left &gt;= right): return True while(not self.__isvalid(rightStr)): right -= 1 rightStr = str[right] if(right &lt;= left): return True if(leftStr != rightStr): return False left += 1 right -= 1 def __isvalid(self, str): if(str.isalnum()): return True return Falseif __name__=="__main__": str = "A man, a plan, a canal: Panama" solution = Solution() print solution.palindrome(str)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2017%2F10%2F08%2Fjava%2FinnerClass%2F</url>
    <content type="text"><![CDATA[内部类可以将一个类的定义放在另一个类的定义内部，这就是内部类。内部类是一种非常有用的特性，因为它允许把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。然而，内部类和组合式完全不同的概念。 创建内部类1234567891011121314151617public class Outer &#123; class Inner &#123; private String str; Inner(String str) &#123; this.str = str; &#125; &#125; public Inner to(String str)&#123; return new Inner(str); &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Inner inner = outer.to("hello"); &#125;&#125; 编译后的class文件如下：123456789101112131415161718192021public class Outer &#123; public Outer() &#123; &#125; public Outer.Inner to(String str) &#123; return new Outer.Inner(str); &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Outer.Inner inner = outer.to("hello"); &#125; class Inner &#123; private String str; Inner(String str) &#123; this.str = str; &#125; &#125;&#125; 如果想从外部类的非静态方法之外的的任意位置创建某个内部类的对象，那么必须具体的指明这个对象的类型：OuterClassName.InnerClassName。（由虚拟机完成） 使用.this和.new如果需要生成对外部类对象的引用可以使用.this。这样产生的引用自动的具有正确的类型，这一点在编译期就被检查并完成，因此在运行期时并没有任何开销。1234567891011121314151617181920public class DotThis &#123; void f()&#123; System.out.println("f()"); &#125; public class Inner&#123; public DotThis outer()&#123; return DotThis.this; &#125; &#125; public Inner inner()&#123; return new Inner(); &#125; public static void main(String[] args) &#123; DotThis dotThis = new DotThis(); Inner inner = dotThis.inner(); inner.outer().f(); &#125;&#125; 如果要告知某些其他对象，去创建某个内部类对象。需要使用.new关键字。12345678public class DotNew &#123; public class Inner&#123; &#125; public static void main(String[] args) &#123; DotNew dotNew = new DotNew(); Inner inner = dotNew.new Inner(); &#125;&#125; 再拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会连接到创建它的外部类对象上。但是如果创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。 匿名内部类12345678910111213public class Parcel &#123; public interface Contents&#123; int value(); &#125; public Contents contents()&#123; return new Contents()&#123; private int i = 11; public int value()&#123; return i; &#125; &#125;; &#125;&#125; 简化形式：123456789101112131415public class Parcelb &#123; public interface Contents&#123; int value(); &#125; class MyContents implements Contents&#123; @Override public int value() &#123; return 0; &#125; &#125; public Contents contents()&#123; return new MyContents(); &#125;&#125; 注意：在jdk1.7及以前，如果一个匿名内部类使用其外部定义的对象，该对象需要使用final修饰，不然会得到一个编译期错误，但是jdk1.8这个final关键字由虚拟机默认加上了。 嵌套类如果不需要内部类对象与其外部类对象之间有联系，可以将内部类声明为static，通常称为嵌套类。想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式的保存了一个引用，指向创建它的外部类对象。当内部类是static时：1、创建嵌套类的对象，并不需要其外围类的对象。2、不能从嵌套类的对象中访问非静态的外围类对象。嵌套类和普通内部类还有一个区别。普通内部类不能包含static数据和字段，也不能包含嵌套类。但是嵌套类可以包含所有这些。1234567891011121314public interface ClassInInterface &#123; void h(); class Test implements ClassInInterface&#123; @Override public void h() &#123; System.out.println("h"); &#125; public static void main(String[] args) &#123; new Test().h(); &#125; &#125;&#125; 以上代码虚拟机在编译之后会把类修饰成static。内部类被嵌套多少层都可以访问所有它所嵌入的外部类的所有成员。 为什么使用内部类每个内部类都能独立的继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。这样的话就可以利用内部类实现类似于c++的多重继承。 使用内部类，还可以获得其他的一些特性：1、内部类可以有多个实例，没个实例都有自己的状态信息，并且与外部类的状态信息相互独立。2、在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。3、创建内部类对象的时刻并不依赖于外部类对象的创建。4、内部类就是一个独立的实体。闭包、回调，和控制框架中都有内部类的身影。 内部类的继承因为内部类的构造器必须连接到指向外部类对象的引用，所以在继承内部类的时候，指向外部类对象的引用必须被初始化。1234567891011public class InnerExtends &#123; class WithInnter&#123; class Inner&#123;&#125; &#125; public class InheritInner extends WithInnter.Inner&#123; public InheritInner(WithInnter withInnter) &#123; withInnter.super(); &#125; &#125;&#125; 内部类的重载这块还没看到，以后找时间补上。参考：《java编程思想》]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode题解]]></title>
    <url>%2F2017%2F10%2F01%2FleetCodeList%2F</url>
    <content type="text"><![CDATA[leetCode是一个非常值得学习的网站，以下是本人近期刷leetCode的总结，里面的代码都是AC通过的，该博文会持续更新。 389. Find the Difference448. Find All Numbers Disappeared in an Array371. Sum of Two Integers657. Judge Route Circle561. Array Partition I500. Keyboard Row557. Reverse Words in a String III344. Reverse String682. Baseball Game575. Distribute Candies258. Add Digits1.Two Sum125. Valid Palindrome167. Two Sum II - Input array is sorted412. Fizz Buzz566. Reshape the Matrix463. Island Perimter496. Next Greater Element I521. Longest Uncommon Subsequence I292. Nim Game136. Single Number693. Binary Number with Alternating Bits485. Max Consecutive Ones520. Detect Capital]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Two Sum]]></title>
    <url>%2F2017%2F09%2F30%2FleetCode%2FtwoSum%2F</url>
    <content type="text"><![CDATA[Two Sum原题：Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 翻译：给定一个整数数组，返回两个数字的索引，使它们相加到一个特定的目标。你可以假设每个输入都只有一个解决方案，而你可能不会使用相同的元素两次。 解决思路：第一种可以用两层循环（时间复杂度O(n^2)），实现代码：123456789public int[] twoSum1(int[] tmp, int target) &#123; for (int i = 0; i &lt; tmp.length; i++)&#123; for (int j = i + 1; j &lt; tmp.length; j++)&#123; if (tmp[i] + tmp[j] == target) return new int[]&#123;i, j&#125;; &#125; &#125; throw new IllegalArgumentException("don't have two sum equals target"); &#125; 第二种可以定义一个map然后把数组的值作为key，索引作为value存到map中，循环数组，每次循环用目标值减去该值，用结果作为key去map中查找，找到了返回索引数组，没找到把该次和循环的值和索引作为key和value存入map中，直到找到结果。（时间复杂度O(n)）实现：1234567891011public int[] twoSum(int[] tmp, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i&lt;tmp.length; i++)&#123; int m = target - tmp[i]; if (map.containsKey(m)) &#123; return new int[] &#123; map.get(m), i &#125;; &#125; map.put(tmp[i], i); &#125; throw new IllegalArgumentException("No two sum solution"); &#125; python实现最近也在学习python，附上python的实现（第二种方案）:1234567891011121314151617class Solution: def twoSum(self, nums, target): map = &#123;&#125; i = 0 for x in nums: if target - x in map: return i,map[target - x] print str(x) + " " + str(i) map[x] = i print map i += 1 returnif __name__=="__main__": a = [5, 4, 9, 3, 7] solution = Solution() print solution.twoSum(a, 10)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2017%2F09%2F29%2Fjava%2FarrayList%2F</url>
    <content type="text"><![CDATA[ArrayListList接口的可调整大小的数组实现。实现所有可选列表操作，并允许所有元素，包括null。除了实现List接口之外，该类还提供了一些方法来操作在内部使用来存储列表的数组的大小。 （这个类大致相当于Vector，除了它是不同步的。）size，isEmpty，get，set，iterator和listIterator操作在常量运行。添加操作以摊销的常数运行，即添加n个元素需要O（n）个时间。所有其他操作都以线性时间运行（粗略地说）。与LinkedList实现相比，常数因子较低。每个ArrayList实例都有一个容量。容量是用于存储列表中的元素的数组的大小。它总是至少与列表大小一样大。当元素被添加到ArrayList时，其容量会自动增长。增长政策的细节不包括增加元素具有不变的摊销时间成本的事实。在使用ensureCapacity操作添加大量元素之前，应用程序可以增加ArrayList实例的容量。这可能会减少增量重新分配的数量。arrayList是线程非安全的。如果要实现线程安全，可以： List list = Collections.synchronizedList(new ArrayList(…)); 使用Iterator去遍历arrayList，如果列表在迭代器创建之后的任何时间被结构化地修改，除了通过迭代器自己的remove或add方法之外，都会抛出一个ConcurrentModificationException，下面这段代码中，因为在iterator创建之后调用了ArrayList的remove方法，所以会抛出异常。12345Iterator iterator = list.iterator(); while (iterator.hasNext())&#123; list.remove(0); iterator.remove(); &#125; ArrayList的实现：12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList几个比较重要的常量：1234/** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; 默认初始容量为10。为什么定义为10？官网上没有给出解释，带着这个疑问我Google了一下，这个默认初始容量可以为任意正整数，为1太少，肯定会做一些大小的调整，100会浪费掉空间，前辈们肯定是做了性能分析和空间分析取出了中间值。1234/** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 用于空实例的共享空数组实例。123456/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 一个空数组实例，当用户没有指定 ArrayList 的容量时(即调用无参构造函数)，返回的是该数组==&gt;刚创建一个 ArrayList 时，其内数据量为 0。当用户第一次添加元素时，该数组将会扩容，变成默认容量为10(DEFAULT_CAPACITY)的一个数组===&gt;通过ensureCapacityInternal()实现，它与 EMPTY_ELEMENTDATA 的区别就是：该数组是默认返回的，而后者是在用户指定容量为0时返回。12345678/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. * */transient Object[] elementData; // non-private to simplify nested class access 存储ArrayList元素的数组缓冲区。ArrayList的容量是此数组缓冲区的长度。任何空的ArrayList elementData的值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA（就是一个空数组）当第一个元素被添加的时候，elementData会扩大到DEFAULT_CAPACITY（也就是10）注意：一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。transient关键字用来用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。ArrayList在序列化的时候会调用writeObject，直接将size和element写入ObjectOutputStream；反序列化时调用readObject，从ObjectInputStream获取size和element，再恢复到elementData。为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。12345/** * The size of the ArrayList (the number of elements it contains). * @serial */ private int size; ArrayList的大小（包含的元素数）。12345678910111213141516171819202122232425262728293031323334353637383940private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; 构造方法ArrayList一共有三个构造方法：123456789101112131415161718/** * Constructs an empty list with the specified initial capacity. * 构造一个指定长度的空列表 * @param initialCapacity the initial capacity of the list * 列表的初始容量 * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; 第一个构造方法主要用于构造一个指定长度的空列表，参数为需要构造列表的初始容量，在这里我们看到当initialCapacity == 0 的时候 elementData = EMPTY_ELEMENTDATA 123456/** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 第二个构造方法构造一个初始容量为10的空list。1234567891011121314151617181920/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) //如果返回值不是Object[]转为Object[] elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 第三个构造方法则将传入的集合转成数组赋值给elementData,如果为空则赋值为上面的共享空数组实例（EMPTY_ELEMENTDATA）。 主要方法接下来看一看ArrayList的主要方法（方法太多就不一一介绍了，有兴趣的同学可以自己看看一源码）：123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 返回指定元素在list中第一次出现的位置。需要注意的是当传入的值为null时并不会报错，因为null也可以作为元素插入ArrayList,查询方式为循环依次查找。如果没有匹配到返回-1。123456789101112public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 与indexOf同理，不过lastIndexOf方法的查找方式为从后向前查找。1234567891011public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; 对原有arrayList实例的浅拷贝。123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; 返回一个新的Object数组，对该数组操作不会影响原有list12345678910@SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; 该方法是传入一个泛型数组a,当a.length&lt;size时，按照list的size创建一个新的数组返回，数组中包含所有list的元素。如果a.length&gt;=size时，则将 list 中的元素按顺序存入 a 中，然后a[list.size] = null, a[list.size + 1] 及其后的元素依旧是 a 的元素,附上测试代码：12345678910public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("a"); list.add("b"); list.add("c"); String[] s = new String[5]; s[0] = "0";s[1] = "1";s[2] = "2";s[3] = "3";s[4] = "4"; String[] c = list.toArray(s); System.out.println(c.length +" " + c[0] + " " + c[1] + " " + c[2] + " " + c[3] + " " + c[4]); &#125; 输出：5 a b c null 4请注意这句话 Make a new array of a’s runtime type, but my contents创建一个新的数组的运行时类型，就是说返回的并不一定是Object[],而是运行时的类型，为什么会出现这种情况呢？原因很简单，因为由于继承的原因，我们父类实例的具体类型，实际上是取决于在 new 时，我们所使用的子类类型。12345public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; 返回指定位置的元素。rangeCheck method: 该方法判断了如果index &gt;= size 则throw一个 IndexOutOfBoundsExceptionelementData method：返回在索引为 index 的元素，主要是避免每次取值都需要强转（看到这里不得不佩服前辈们，要是我自己来写目前肯定封装的不会这么好）1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; 该方法是在指定索引处插入指定元素，并把被替换的元素返回。12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code //防止溢出 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //这里的oldCapacity &gt;&gt; 1相当于 oldCapacity/2 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; add方法就是向list末尾添加数据，但是这时候要考虑容量问题。ensureCapacityInternal方法：若 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 即{}，则取 minCapacity 为 默认容量和参数 minCapacity 之间的最大值。 这里需要介绍一下modCount变量，他是父类AbstractList中的变量主要用于记录arrayList结构变化&gt;的次数，每变化一次增加1.拥有这个参数的方法都是线程不安全的，在一个迭代器初始的时候会赋予它调&gt;用这个迭代器的对象的mCount，如何在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存&gt;储的mcount不一样那就抛异常 grow方法:增加容量以确保它至少能够容纳最小容量参数指定的元素数。如果扩容后大于最大存储容量,则调用hugeCapacity方法，MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8（为什么是Integer.MAX_VALUE - 8呢？只是为了避免一些机器内存溢出，最大长度依然是Integer.MAX_VALUE，并不是Integer.MAX_VALUE-8） 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 在该列表中的指定位置插入指定的元素。将当前位于该位置的元素（如果有）和任何后续元素（向其索引添加一个）移动。1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 移除指定索引位置的元素：index 之后的所有元素依次左移一位 12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; 移除指定的一个元素，索引位置最低的。123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 删除此列表的所有元素。 12345678public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; 将一个集合的所有元素顺序添加到list末尾。12345678910111213141516public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 从指定的位置开始将指定集合中的所有元素插入到此列表中。将当前处于该位置的元素（如果有的话）和随后的任何元素移动到右边（增加其索引）。新元素将按照指定集合的迭代器返回的顺序显示在列表中。123456789101112131415161718192021222324252627282930313233public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; 移除list中和c中共有的元素。1234public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; 保留list中和c中共有的元素。 总结1、ArrayList基于数组实现，其内存储元素的数组为elementData2、ArrayList中EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY._ELEMENTDATA虽然都是空数组，但是使用场景不同。前者是通过ArrayList(int initialCapacity)该构造方法直接指定初试容量为0时，后者是用户直接使用无参构造创建ArrayList时。3、ArrayList的扩容计算为newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 且扩容并非是无限制的，有内存限制、虚拟机限制。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO + github 创建自己的个人博客]]></title>
    <url>%2F2017%2F09%2F24%2FhexoBlog%2F</url>
    <content type="text"><![CDATA[hexo + github 创建自己的个人博客最近想搞一个自己的博客，写一些自己平时工作中的积累，终于搭好了，写一下搭建博客的过程。hexo是一款基于Node.js的静态博客框架,所以安装node.js是必须的（这个就不写了，node官网下载，安装）。申请GitHub（必须）作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 安装hexonode和git安装好后创建一个文件夹blog，安装hexo： sudo npm install -g hexo 执行init命令初始化hexo: hexo init 生成静态页面: hexo generate（hexo g也可以） 配置github建立Repository 建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联，我的blog在本地/user/local/bin/blog，blog是我之前建的东西也全在这里面，有： _config.yml node_modules public source db.json package.json scaffolds themes 现在我们需要_config.yml文件，来建立关联，命令： vi _config.yml 翻到最下面，改成我这样子的 deploy: type: git repo: https://github.com/yougithub/youname.github.io.git branch: master repo也可以写成yougithubname:youpassword@https://github.com/yougithub/youname.github.io.git注意所有的：后面都有一个空格。 生成添加秘钥在终端（Terminal）输入： ssh-keygen -t rsa -C “Github的注册邮箱地址” 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入https://github.com/settings/ssh： 将复制的内容粘贴到Key的输入框，随便写好Title里面的内容，点击Add SSH key按钮即可。可以本地启动服务进行预览，命令： hexo server (hexo s 也可以) 浏览器输入localhost:4000 每次部署的步骤，可按以下三步来进行。 hexo clean hexo generate(hexo g) hexo deploy(hexo d) 参考：http://www.jianshu.com/p/465830080ea9http://www.jianshu.com/p/e99ed60390a8 标签页／分类页 参考：http://theme-next.iissnan.com/theme-settings.html#syntax-highlight-scheme 头像／logo 参考：http://cherryblog.site/Hexo-high-level-tutorialcloudmusic,bg-customthemes-statistical.html 站内搜索 参考：https://zetaoyang.github.io/post/2016/07/08/hexo-localsearch.html]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Two Sum]]></title>
    <url>%2F2017%2F09%2F30%2FtwoSum%2F</url>
    <content type="text"><![CDATA[算法练习Two Sum原题：Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 翻译：给定一个整数数组，返回两个数字的索引，使它们相加到一个特定的目标。你可以假设每个输入都只有一个解决方案，而你可能不会使用相同的元素两次。 解决思路：第一种可以用两层循环（时间复杂度O(n^2)），实现代码（纯手打）：123456789public int[] twoSum1(int[] tmp, int target) &#123; for (int i = 0; i &lt; tmp.length; i++)&#123; for (int j = i + 1; j &lt; tmp.length; j++)&#123; if (tmp[i] + tmp[j] == target) return new int[]&#123;i, j&#125;; &#125; &#125; throw new IllegalArgumentException("don't have two sum equals target"); &#125; 第二种可以定义一个map然后把数组的值作为key，索引作为value存到map中，循环数组，每次循环用目标值减去该值，用结果作为key去map中查找，找到了返回索引数组，没找到把该次和循环的值和索引作为key和value存入map中，直到找到结果。（时间复杂度O(n)）实现：1234567891011public int[] twoSum(int[] tmp, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i&lt;tmp.length; i++)&#123; int m = target - tmp[i]; if (map.containsKey(m)) &#123; return new int[] &#123; map.get(m), i &#125;; &#125; map.put(tmp[i], i); &#125; throw new IllegalArgumentException("No two sum solution"); &#125; python实现最近也在学习python，附上python的实现（第二种方案）:1234567891011121314151617class Solution: def twoSum(self, nums, target): map = &#123;&#125; i = 0 for x in nums: if target - x in map: return i,map[target - x] print str(x) + " " + str(i) map[x] = i print map i += 1 returnif __name__=="__main__": a = [5, 4, 9, 3, 7] solution = Solution() print solution.twoSum(a, 10)]]></content>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2017%2F09%2F29%2FarrayList%2F</url>
    <content type="text"><![CDATA[ArrayListList接口的可调整大小的数组实现。实现所有可选列表操作，并允许所有元素，包括null。除了实现List接口之外，该类还提供了一些方法来操作在内部使用来存储列表的数组的大小。 （这个类大致相当于Vector，除了它是不同步的。）size，isEmpty，get，set，iterator和listIterator操作在常量运行。添加操作以摊销的常数运行，即添加n个元素需要O（n）个时间。所有其他操作都以线性时间运行（粗略地说）。与LinkedList实现相比，常数因子较低。每个ArrayList实例都有一个容量。容量是用于存储列表中的元素的数组的大小。它总是至少与列表大小一样大。当元素被添加到ArrayList时，其容量会自动增长。增长政策的细节不包括增加元素具有不变的摊销时间成本的事实。在使用ensureCapacity操作添加大量元素之前，应用程序可以增加ArrayList实例的容量。这可能会减少增量重新分配的数量。arrayList是线程非安全的。如果要实现线程安全，可以： List list = Collections.synchronizedList(new ArrayList(…)); 使用Iterator去遍历arrayList，如果列表在迭代器创建之后的任何时间被结构化地修改，除了通过迭代器自己的remove或add方法之外，都会抛出一个ConcurrentModificationException，下面这段代码中，因为在iterator创建之后调用了ArrayList的remove方法，所以会抛出异常。12345Iterator iterator = list.iterator(); while (iterator.hasNext())&#123; list.remove(0); iterator.remove(); &#125; ArrayList的实现：12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList几个比较重要的常量：1234/** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; 默认初始容量为10。为什么定义为10？官网上没有给出解释，带着这个疑问我Google了一下，这个默认初始容量可以为任意正整数，为1太少，肯定会做一些大小的调整，100会浪费掉空间，前辈们肯定是做了性能分析和空间分析取出了中间值。1234/** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 用于空实例的共享空数组实例。123456/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 一个空数组实例，当用户没有指定 ArrayList 的容量时(即调用无参构造函数)，返回的是该数组==&gt;刚创建一个 ArrayList 时，其内数据量为 0。当用户第一次添加元素时，该数组将会扩容，变成默认容量为10(DEFAULT_CAPACITY)的一个数组===&gt;通过ensureCapacityInternal()实现，它与 EMPTY_ELEMENTDATA 的区别就是：该数组是默认返回的，而后者是在用户指定容量为0时返回。12345678/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. * */transient Object[] elementData; // non-private to simplify nested class access 存储ArrayList元素的数组缓冲区。ArrayList的容量是此数组缓冲区的长度。任何空的ArrayList elementData的值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA（就是一个空数组）当第一个元素被添加的时候，elementData会扩大到DEFAULT_CAPACITY（也就是10）注意：一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。transient关键字用来用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。ArrayList在序列化的时候会调用writeObject，直接将size和element写入ObjectOutputStream；反序列化时调用readObject，从ObjectInputStream获取size和element，再恢复到elementData。为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。12345/** * The size of the ArrayList (the number of elements it contains). * @serial */ private int size; ArrayList的大小（包含的元素数）。12345678910111213141516171819202122232425262728293031323334353637383940private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; 构造方法ArrayList一共有三个构造方法：123456789101112131415161718/** * Constructs an empty list with the specified initial capacity. * 构造一个指定长度的空列表 * @param initialCapacity the initial capacity of the list * 列表的初始容量 * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; 第一个构造方法主要用于构造一个指定长度的空列表，参数为需要构造列表的初始容量，在这里我们看到当initialCapacity == 0 的时候 elementData = EMPTY_ELEMENTDATA 123456/** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 第二个构造方法构造一个初始容量为10的空list。1234567891011121314151617181920/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) //如果返回值不是Object[]转为Object[] elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 第三个构造方法则将传入的集合转成数组赋值给elementData,如果为空则赋值为上面的共享空数组实例（EMPTY_ELEMENTDATA）。 主要方法接下来看一看ArrayList的主要方法（方法太多就不一一介绍了，有兴趣的同学可以自己看看一源码）：123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 返回指定元素在list中第一次出现的位置。需要注意的是当传入的值为null时并不会报错，因为null也可以作为元素插入ArrayList,查询方式为循环依次查找。如果没有匹配到返回-1。123456789101112public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 与indexOf同理，不过lastIndexOf方法的查找方式为从后向前查找。1234567891011public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; 对原有arrayList实例的浅拷贝。123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; 返回一个新的Object数组，对该数组操作不会影响原有list12345678910@SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; 该方法是传入一个泛型数组a,当a.length&lt;size时，按照list的size创建一个新的数组返回，数组中包含所有list的元素。如果a.length&gt;=size时，则将 list 中的元素按顺序存入 a 中，然后a[list.size] = null, a[list.size + 1] 及其后的元素依旧是 a 的元素,附上测试代码：12345678910public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("a"); list.add("b"); list.add("c"); String[] s = new String[5]; s[0] = "0";s[1] = "1";s[2] = "2";s[3] = "3";s[4] = "4"; String[] c = list.toArray(s); System.out.println(c.length +" " + c[0] + " " + c[1] + " " + c[2] + " " + c[3] + " " + c[4]); &#125; 输出：5 a b c null 4请注意这句话 Make a new array of a’s runtime type, but my contents创建一个新的数组的运行时类型，就是说返回的并不一定是Object[],而是运行时的类型，为什么会出现这种情况呢？原因很简单，因为由于继承的原因，我们父类实例的具体类型，实际上是取决于在 new 时，我们所使用的子类类型。12345public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; 返回指定位置的元素。rangeCheck method: 该方法判断了如果index &gt;= size 则throw一个 IndexOutOfBoundsExceptionelementData method：返回在索引为 index 的元素，主要是避免每次取值都需要强转（看到这里不得不佩服前辈们，要是我自己来写目前肯定封装的不会这么好）1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; 该方法是在指定索引处插入指定元素，并把被替换的元素返回。12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code //防止溢出 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //这里的oldCapacity &gt;&gt; 1相当于 oldCapacity/2 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; add方法就是向list末尾添加数据，但是这时候要考虑容量问题。ensureCapacityInternal方法：若 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 即{}，则取 minCapacity 为 默认容量和参数 minCapacity 之间的最大值。 这里需要介绍一下modCount变量，他是父类AbstractList中的变量主要用于记录arrayList结构变化&gt;的次数，每变化一次增加1.拥有这个参数的方法都是线程不安全的，在一个迭代器初始的时候会赋予它调&gt;用这个迭代器的对象的mCount，如何在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存&gt;储的mcount不一样那就抛异常 grow方法:增加容量以确保它至少能够容纳最小容量参数指定的元素数。如果扩容后大于最大存储容量,则调用hugeCapacity方法，MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8（为什么是Integer.MAX_VALUE - 8呢？只是为了避免一些机器内存溢出，最大长度依然是Integer.MAX_VALUE，并不是Integer.MAX_VALUE-8） 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 在该列表中的指定位置插入指定的元素。将当前位于该位置的元素（如果有）和任何后续元素（向其索引添加一个）移动。1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 移除指定索引位置的元素：index 之后的所有元素依次左移一位 12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; 移除指定的一个元素，索引位置最低的。123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 删除此列表的所有元素。 12345678public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; 将一个集合的所有元素顺序添加到list末尾。12345678910111213141516public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 从指定的位置开始将指定集合中的所有元素插入到此列表中。将当前处于该位置的元素（如果有的话）和随后的任何元素移动到右边（增加其索引）。新元素将按照指定集合的迭代器返回的顺序显示在列表中。123456789101112131415161718192021222324252627282930313233public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; 移除list中和c中共有的元素。1234public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; 保留list中和c中共有的元素。 ##总结1、ArrayList基于数组实现，其内存储元素的数组为elementData2、ArrayList中EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY._ELEMENTDATA虽然都是空数组，但是使用场景不同。前者是通过ArrayList(int initialCapacity)该构造方法直接指定初试容量为0时，后者是用户直接使用无参构造创建ArrayList时。3、ArrayList的扩容计算为newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 且扩容并非是无限制的，有内存限制、虚拟机限制。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

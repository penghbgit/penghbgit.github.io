<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetCode--Add Digits]]></title>
    <url>%2F2017%2F10%2F11%2FaddDigits%2F</url>
    <content type="text"><![CDATA[Add Digits原题Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. 翻译大概意思就是给你一个数，把这个数的各个位上的数相加，得到一个新的数，重复下去直到最后相加出来的数为个位数为止。 解题思路：我最开始想的是把每位上的数取出来相加，然后利用递归去做，直到得到符合的答案，原题要求不用循环和递归用O(1)的时间复杂度求出结果，很显然这不符合的。然后想到找规律，发现num%9符合规律，测试发现9%9的时候出现问题，于是改成（num－1）％9+1，代码实现（java）：123public int addDigits(int num) &#123; return (num - 1) % 9 + 1; &#125; 代码实现（python）：1234def addDigits(self, num): if(num == 0): return 0 return (num - 1) % 9 + 1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode--Array Partition I]]></title>
    <url>%2F2017%2F10%2F11%2FarrayPartition1%2F</url>
    <content type="text"><![CDATA[Array Partition I原题Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example Input: [1,4,3,2] Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = &gt;min(1, 2) + min(3, 4). 翻译大概意思就是给定一个长度为2n的数组，分成n个小组，返回每组中较小值的和sum，使sum尽量大 解题思路：要取sum为最大值，分组的话就要把两个大的数分在一起，然后以此类推，所以先把数组排序，依次把下标为偶数位的值相加即为所求值。代码实现（java）：1234567public int arrayPairSum(int[] nums) &#123; Arrays.sort(nums); int res = 0; for(int i = 0; i &lt; nums.length; i += 2) res += nums[i]; return res; &#125; 发现有很多大神的代码执行时间更少，发现他们用的排序算法是计数排序。每隔一个数进行相加：代码实现（python）：12345678def arrayPairSum(self, nums): if isinstance(nums, list) and len(nums) == 0: return 0 nums.sort() res = 0 for i in range(0, len(nums), 2): res += nums[i] return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode--Judge Route Circle]]></title>
    <url>%2F2017%2F10%2F10%2FjudgeRouteCircle%2F</url>
    <content type="text"><![CDATA[Judge Route Circle原题Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle. Example Input: “UD”Output: true Input: “LL”Output: false 翻译大概意思就是起点为（0，0），R(右),L(左),U(上)和D(下).给定一串移动的串，判断最后是否回到原点。 解题思路：这是一个横纵坐标移动的问题，向左移动x–，向右x++，向上y++，向下y–，最后判断 x == 0 &amp;&amp; y == 0即可。代码实现（java）：1234567891011121314151617181920212223242526public boolean judgeCircle(String moves) &#123; if(moves == null || "".equals(moves)) return true; int x = 0; int y = 0; for(int i = 0; i&lt;moves.length(); i++)&#123; char c = moves.charAt(i); switch(c)&#123; case 'U': y++; break; case 'D': y--; break; case 'L': x--; break; case 'R': x++; break; &#125; &#125; if(x == 0 &amp;&amp; y == 0) return true; return false; &#125; 也可以判断给定的字符串中UD和LR是否成对的出现。代码实现（python）：12def judgeCircle(self, moves): return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D')]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread源码分析]]></title>
    <url>%2F2017%2F10%2F10%2Fthread%2F</url>
    <content type="text"><![CDATA[什么是线程？线程可以理解为在进程中独立运行的子任务。线程是CPU调度的最基本单元。线程的资源开销相对于进程的开销是相对较少的，所以我们一般创建线程执行，而不是进程执行。java中要创建一个线程可以继承Thread类和实现Runnable接口。 注意：多线程是异步的。 下面我们来看一下Thread类的源码。12publicclass Thread implements Runnable 从上面的代码中可以看到，Thread实现了Runnable接口，它们之间具有多态关系。创建一个线程可以继承thread类或者实现Runnable接口，这两种创建方式在工作时性质是一样的，没有本质区别。 线程是一个子任务，cpu以不确定的时间来调用线程中的run方法。 native关键字简介1234private static native void registerNatives(); static &#123; registerNatives(); &#125; native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（Java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。不过，对Java外部的调用通常不能移植到其他平台，在applet中还可能引发安全异常。实现本地代码将使您的Java应用程序无法通过100%纯Java测试。但是，如果必须执行本地调用，则要考虑几个准则： 将您的所有本地方法都封装到一个类中，这个类调用单个的DLL。对每一种目标操作系统平台，都可以用特定于适当平台的版本的DLL。这样可以将本地代码的影响减少到最小，并有助于将以后所需要的移植问题考虑在内。 本地方法尽量简单。尽量使您的本地方法对第三方（包括Microsoft）运行时DLL的依赖减少到最小。使您的本地方法尽量独立，以将加载您的DLL和应用程序所需的开销减少到最小。如果需要运行时DLL，必须随应用程序一起提供。 变量name12//线程名，volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。使得该变量是线程间可见的。private volatile String name; priority12//线程执行优先级private int priority; single_step12//是否单独执行此线程private boolean single_step; daemon12//线程是否是守护线程private boolean daemon = false; stillborn12//虚拟机状态 private boolean stillborn = false; target12//实际的线程任务 private Runnable target; group12//这个线程的组 private ThreadGroup group; contextClassLoader12//这个线程的上下文类加载器 private ClassLoader contextClassLoader; inheritedAccessControlContext12//这个线程的继承 private AccessControlContext inheritedAccessControlContext; threadInitNumber12//所有初始化线程的数目 private static int threadInitNumber; threadLocals &amp; inheritableThreadLocals123//这是为ThreadLocal类维护的一些变量ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; stackSize12//此线程请求的堆栈大小，如果创建者未指定堆栈大小，则为0。虚拟机可以用这个数字来做任何喜欢的事情一些虚拟机将忽略它。 private long stackSize; nativeParkEventPointer12//本地线程终止后仍然存在的JVM私有状态。 private long nativeParkEventPointer; tid &amp; threadSeqNumber123//线程id相关private long tid;private static long threadSeqNumber; threadStatus12//线程状态，初始化为指示线程尚未启动private volatile int threadStatus = 0; blocker12//在可中断的I / O操作（如果有）中阻塞此线程的对象。在设置此线程的中断状态后，应调用阻塞程序的中断方法。private volatile Interruptible blocker; 线程优先级12345678//线程为最低优先级。 public final static int MIN_PRIORITY = 1; //分配给线程的默认优先级。 public final static int NORM_PRIORITY = 5; //线程拥有最高优先级 public final static int MAX_PRIORITY = 10; native方法123456789101112131415161718192021222324252627282930313233//返回对当前正在执行的线程对象的引用。 public static native Thread currentThread(); //使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了 public static native void yield();//当前正在执行的线程（this.currentThread()）休眠（暂停执行）指定的毫秒数，这取决于系统定时器和调度程序的精度和准确性。线程不会丢失monitors。public static native void sleep(long millis) throws InterruptedException;//通过C代码初始化线程需要的系统资源。 private native void start0();//强制停止一个线程（不建议使用） @Deprecated public final synchronized void stop(Throwable obj) //只是设置中断标志 private native void interrupt0(); //检查一个线程是否处于活动状态。（活动状态指已经启动且尚未终止） public final native boolean isAlive(); //暂停线程 private native void suspend0(); //重新激活一个线程 private native void resume0(); //设置线程优先级 private native void setPriority0(int newPriority);//放弃当前cpu资源，让给其他任务（但是放弃的时间不确定） public static native void yield(); 构造方法Thread有好8个构造方法，最终都是调用这个辅助构造函数。接下来我们就来详细的看看init方法到底是怎么来初始化线程的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 初始化线程 * * @param g 线程组 * @param target run（）方法被调用的对象 * @param name 新线程的name * @param stackSize 新线程所需的堆栈大小，零表示此参数将被忽略。 * @param acc AccessControlContext继承，或AccessController.getContext（）为null * @param inheritThreadLocals 如果&#123;@code true&#125;，继承初始值来自构造线程的可继承线程 */private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; if (name == null) &#123; throw new NullPointerException("name cannot be null"); &#125; this.name = name; //当前线程就是该线程的父线程 Thread parent = currentThread(); //获取系统的安全管理器 SecurityManager security = System.getSecurityManager(); if (g == null) &#123; //security不为null时，线程所在group为security的group if (security != null) &#123; g = security.getThreadGroup(); &#125; //security为null时，使用父线程的group if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; //确定当前运行的线程是否有权限修改此线程组。 g.checkAccess(); //检查权限 if (security != null) &#123; if (isCCLOverridden(getClass())) &#123; security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); &#125; &#125; g.addUnstarted(); //将线程组、守护线程、优先级等设置为父线程的对应属性 this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); //从父线程继承可继承的ThreadLocal if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); //设置该线程堆栈大小 this.stackSize = stackSize; //设置线程id tid = nextThreadID(); &#125; 主要方法启动start12345678910111213141516171819202122232425//线程启动方法public synchronized void start() &#123; //当前线程初始化还未做好，不能start，0-&gt;NEW状态 if (threadStatus != 0) throw new IllegalThreadStateException(); //通知group该线程即将启动，group的nUnstartedThreads减1,nthreads加1 group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; //启动不成功，group设置当前线程启动失败 if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125; &#125; 启动线程其实做了这么几件事： 检查线程是否初始化； 通知group，线程启动； 调用native方法start0()启动线程，启动后执行run()方法； 启动失败容错处理。 run123456@Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 真正的run其实是目标类的run方法,target实际上要保存的是一个Runnable接口的实现的引用。 停止停止一个线程可以用Thread.stop()方法，但最好不要使用它。因为这个方法是不安全的。（可能使一些清理性的工作得不到完成，对锁定的对象进行“解锁”，出现数据不一致。） stop12345678910111213141516171819//强制线程停止执行。（不建议使用） @Deprecatedpublic final void stop() &#123; SecurityManager security = System.getSecurityManager(); if (security != null) &#123; checkAccess(); if (this != Thread.currentThread()) &#123; security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION); &#125; &#125; // A zero status value corresponds to "NEW", it can't change to // not-NEW because we hold the lock. if (threadStatus != 0) &#123; resume(); // Wake up thread if it was suspended; no-op otherwise &#125; // The VM can handle all thread states stop0(new ThreadDeath()); &#125; interrupt1234567891011121314public void interrupt() &#123; if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125; &#125; interrupt0(); &#125; interrupt()方法只是在当前线程中打了一个停止标记，并不是真的停止了线程。 interrupted &amp; isInterrupted123456789//测试当前线程是否已经中断(线程的中断状态由该方法清除)public static boolean interrupted() &#123; return currentThread().isInterrupted(true); &#125;//测试线程是否中断（不清除线程的中断状态） public boolean isInterrupted() &#123; return isInterrupted(false); &#125; 几种停止线程的方法 可以通过判断当前线程是否中断，如果是中断抛出异常去停止一个线程。 可以在sleep（）状态下停止线程。 interrupt()方法和return结合使用。 比较建议使用“抛异常”的方法实现停止线程，因为在catch中可以对异常进行相关的处理，而且使用异常处理能更好、更方便的控制程序的运行流程。 暂停线程暂停线程意味着此线程还可以恢复运行。在java中可以使用suspend()方法暂停线程，使用resume()方法恢复线程。 suspend123456//暂停一个线程（不推荐使用）依靠本地方法suspend0，可能会造成死锁和不同步@Deprecated public final void suspend() &#123; checkAccess(); suspend0(); &#125; resume123456//重新激活一个线程（不推荐使用）依靠本地方法resume0，可能会造成死锁和不同步@Deprecated public final void resume() &#123; checkAccess(); resume0(); &#125; join123456789101112131415161718192021222324public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125; &#125; join会锁住当前线程，等待子线程结束之后继续执行。如图: 其他方法exit1234567891011121314//由系统调用，可以使Thread在销毁前释放资源private void exit() &#123; if (group != null) &#123; group.threadTerminated(this); group = null; &#125; target = null; /* Speed the release of some of these resources */ threadLocals = null; inheritableThreadLocals = null; inheritedAccessControlContext = null; blocker = null; uncaughtExceptionHandler = null; &#125; checkAccess1234567//确定当前运行的线程是否有权限修改此线程。public final void checkAccess() &#123; SecurityManager security = System.getSecurityManager(); if (security != null) &#123; security.checkAccess(this); &#125; &#125; dumpStack1234//将当前线程的堆栈跟踪打印到标准错误流。此方法仅用于调试。public static void dumpStack() &#123; new Exception("Stack trace").printStackTrace(); &#125; 还有一些方法没有看到，就不一一概述了。 线程的状态Thread中有个状态枚举： NEW：初始状态，线程被构建，还未调用start()方法； RUNNABLE：运行状态，在java多线程模型中，就绪和运行都是运行状态； BLOCKED：阻塞状态； WAITING：等待状态，比如中断，需要其他的线程来唤醒； TIME_WAITING：超时等待，可以在指定的时间内自行返回； TERMINATED：终止状态，线程执行完毕。 java层次的状态转换图 操作系统层次的状态转换图 总结wait()和notify/notifyAll()线程中常用wait()和notify/notifyAll()方法，这是Object类中的方法。 wait()线程进入WAITING状态，并且释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁，等待其他线程调用“锁标志“对象的notify或notifyAll方法恢复wait方法是一个本地方法，其底层是通过一个叫做监视器锁的对象来完成的，所以调用wait方式时必须获取到monitor对象的所有权即通过Synchronized关键字，否则抛出IllegalMonitorStateException异常 notify &amp; notifyAll()在同一对象上去调用notify/notifyAll方法，就可以唤醒对应对象monitor上等待的线程了。notify和notifyAll的区别在于前者只能唤醒monitor上的一个线程，对其他线程没有影响，而notifyAll则唤醒所有的线程 线程复用像线程池类高效的原因在于，线程池中的线程在完成任务后，不会销毁，而且缓存起来，每当用户请求一个线程处理任务时，线程池可以利用缓存的空闲线程来处理用户任务，这样避免了线程创建销毁带来的开销。在Thread类中有一个Runnable target的域，只需将target替换成新的Runnable即可。后续会写一些线程池相关的文章。 更深入学习Thread类中有许多native方法，更深入的学习后续还需研究研究jvm的源码。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode--Valid Palindrome]]></title>
    <url>%2F2017%2F10%2F09%2FvalidPalindrome%2F</url>
    <content type="text"><![CDATA[原题Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example, “A man, a plan, a canal: Panama” is a palindrome.“race a car” is not a palindrome. 翻译：给定一个字符串，判断其是否为一个回文串。只包含字母和数字，忽略大小写。 解题思路利用首尾指针，找到符合条件的索引，进行比较，符合条件进行下一组比较，不相等返回false，直到所有的字母都处理完。 代码实现java实现，时间复杂度O(n).12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public Boolean solution(String str)&#123; if(str == null || "".equals(str)) return true; str = str.toLowerCase(); int left = 0; int right = str.length() - 1; while (left &lt; right) &#123; char leftChar = str.charAt(left); char rightChar = str.charAt(right); while (!isValid(leftChar))&#123; left++; leftChar = str.charAt(left); if (left &gt;= right) return true; &#125; while (!isValid(rightChar))&#123; right--; rightChar = str.charAt(right); if (right &lt;= left) return true; &#125; if (leftChar != rightChar) return false; left++; right--; &#125; return true; &#125; private Boolean isValid(Character character)&#123; if (Character.isLetterOrDigit(character)) return true; return false; &#125;&#125; python实现1234567891011121314151617181920212223242526272829303132333435class Solution: def palindrome(self, str): if str.strip() == "": return True str = str.lower() left = 0 right = len(str) - 1 while(left &lt; right): leftStr = str[left] rightStr = str[right] while(not self.__isvalid(leftStr)): left += 1 leftStr = str[left] if(left &gt;= right): return True while(not self.__isvalid(rightStr)): right -= 1 rightStr = str[right] if(right &lt;= left): return True if(leftStr != rightStr): return False left += 1 right -= 1 def __isvalid(self, str): if(str.isalnum()): return True return Falseif __name__=="__main__": str = "A man, a plan, a canal: Panama" solution = Solution() print solution.palindrome(str)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2017%2F10%2F08%2FinnerClass%2F</url>
    <content type="text"><![CDATA[内部类可以将一个类的定义放在另一个类的定义内部，这就是内部类。内部类是一种非常有用的特性，因为它允许把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。然而，内部类和组合式完全不同的概念。 创建内部类1234567891011121314151617public class Outer &#123; class Inner &#123; private String str; Inner(String str) &#123; this.str = str; &#125; &#125; public Inner to(String str)&#123; return new Inner(str); &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Inner inner = outer.to("hello"); &#125;&#125; 编译后的class文件如下：123456789101112131415161718192021public class Outer &#123; public Outer() &#123; &#125; public Outer.Inner to(String str) &#123; return new Outer.Inner(str); &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Outer.Inner inner = outer.to("hello"); &#125; class Inner &#123; private String str; Inner(String str) &#123; this.str = str; &#125; &#125;&#125; 如果想从外部类的非静态方法之外的的任意位置创建某个内部类的对象，那么必须具体的指明这个对象的类型：OuterClassName.InnerClassName。（由虚拟机完成） 使用.this和.new如果需要生成对外部类对象的引用可以使用.this。这样产生的引用自动的具有正确的类型，这一点在编译期就被检查并完成，因此在运行期时并没有任何开销。1234567891011121314151617181920public class DotThis &#123; void f()&#123; System.out.println("f()"); &#125; public class Inner&#123; public DotThis outer()&#123; return DotThis.this; &#125; &#125; public Inner inner()&#123; return new Inner(); &#125; public static void main(String[] args) &#123; DotThis dotThis = new DotThis(); Inner inner = dotThis.inner(); inner.outer().f(); &#125;&#125; 如果要告知某些其他对象，去创建某个内部类对象。需要使用.new关键字。12345678public class DotNew &#123; public class Inner&#123; &#125; public static void main(String[] args) &#123; DotNew dotNew = new DotNew(); Inner inner = dotNew.new Inner(); &#125;&#125; 再拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会连接到创建它的外部类对象上。但是如果创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。 匿名内部类12345678910111213public class Parcel &#123; public interface Contents&#123; int value(); &#125; public Contents contents()&#123; return new Contents()&#123; private int i = 11; public int value()&#123; return i; &#125; &#125;; &#125;&#125; 简化形式：123456789101112131415public class Parcelb &#123; public interface Contents&#123; int value(); &#125; class MyContents implements Contents&#123; @Override public int value() &#123; return 0; &#125; &#125; public Contents contents()&#123; return new MyContents(); &#125;&#125; 注意：在jdk1.7及以前，如果一个匿名内部类使用其外部定义的对象，该对象需要使用final修饰，不然会得到一个编译期错误，但是jdk1.8这个final关键字由虚拟机默认加上了。 嵌套类如果不需要内部类对象与其外部类对象之间有联系，可以将内部类声明为static，通常称为嵌套类。想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式的保存了一个引用，指向创建它的外部类对象。当内部类是static时：1、创建嵌套类的对象，并不需要其外围类的对象。2、不能从嵌套类的对象中访问非静态的外围类对象。嵌套类和普通内部类还有一个区别。普通内部类不能包含static数据和字段，也不能包含嵌套类。但是嵌套类可以包含所有这些。1234567891011121314public interface ClassInInterface &#123; void h(); class Test implements ClassInInterface&#123; @Override public void h() &#123; System.out.println("h"); &#125; public static void main(String[] args) &#123; new Test().h(); &#125; &#125;&#125; 以上代码虚拟机在编译之后会把类修饰成static。内部类被嵌套多少层都可以访问所有它所嵌入的外部类的所有成员。 为什么使用内部类每个内部类都能独立的继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。这样的话就可以利用内部类实现类似于c++的多重继承。 使用内部类，还可以获得其他的一些特性：1、内部类可以有多个实例，没个实例都有自己的状态信息，并且与外部类的状态信息相互独立。2、在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。3、创建内部类对象的时刻并不依赖于外部类对象的创建。4、内部类就是一个独立的实体。闭包、回调，和控制框架中都有内部类的身影。 内部类的继承因为内部类的构造器必须连接到指向外部类对象的引用，所以在继承内部类的时候，指向外部类对象的引用必须被初始化。1234567891011public class InnerExtends &#123; class WithInnter&#123; class Inner&#123;&#125; &#125; public class InheritInner extends WithInnter.Inner&#123; public InheritInner(WithInnter withInnter) &#123; withInnter.super(); &#125; &#125;&#125; 内部类的重载这块还没看到，以后找时间补上。参考：《java编程思想》]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode--Two Sum]]></title>
    <url>%2F2017%2F09%2F30%2FtwoSum%2F</url>
    <content type="text"><![CDATA[Two Sum原题：Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 翻译：给定一个整数数组，返回两个数字的索引，使它们相加到一个特定的目标。你可以假设每个输入都只有一个解决方案，而你可能不会使用相同的元素两次。 解决思路：第一种可以用两层循环（时间复杂度O(n^2)），实现代码：123456789public int[] twoSum1(int[] tmp, int target) &#123; for (int i = 0; i &lt; tmp.length; i++)&#123; for (int j = i + 1; j &lt; tmp.length; j++)&#123; if (tmp[i] + tmp[j] == target) return new int[]&#123;i, j&#125;; &#125; &#125; throw new IllegalArgumentException("don't have two sum equals target"); &#125; 第二种可以定义一个map然后把数组的值作为key，索引作为value存到map中，循环数组，每次循环用目标值减去该值，用结果作为key去map中查找，找到了返回索引数组，没找到把该次和循环的值和索引作为key和value存入map中，直到找到结果。（时间复杂度O(n)）实现：1234567891011public int[] twoSum(int[] tmp, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i&lt;tmp.length; i++)&#123; int m = target - tmp[i]; if (map.containsKey(m)) &#123; return new int[] &#123; map.get(m), i &#125;; &#125; map.put(tmp[i], i); &#125; throw new IllegalArgumentException("No two sum solution"); &#125; python实现最近也在学习python，附上python的实现（第二种方案）:1234567891011121314151617class Solution: def twoSum(self, nums, target): map = &#123;&#125; i = 0 for x in nums: if target - x in map: return i,map[target - x] print str(x) + " " + str(i) map[x] = i print map i += 1 returnif __name__=="__main__": a = [5, 4, 9, 3, 7] solution = Solution() print solution.twoSum(a, 10)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2017%2F09%2F29%2FarrayList%2F</url>
    <content type="text"><![CDATA[ArrayListList接口的可调整大小的数组实现。实现所有可选列表操作，并允许所有元素，包括null。除了实现List接口之外，该类还提供了一些方法来操作在内部使用来存储列表的数组的大小。 （这个类大致相当于Vector，除了它是不同步的。）size，isEmpty，get，set，iterator和listIterator操作在常量运行。添加操作以摊销的常数运行，即添加n个元素需要O（n）个时间。所有其他操作都以线性时间运行（粗略地说）。与LinkedList实现相比，常数因子较低。每个ArrayList实例都有一个容量。容量是用于存储列表中的元素的数组的大小。它总是至少与列表大小一样大。当元素被添加到ArrayList时，其容量会自动增长。增长政策的细节不包括增加元素具有不变的摊销时间成本的事实。在使用ensureCapacity操作添加大量元素之前，应用程序可以增加ArrayList实例的容量。这可能会减少增量重新分配的数量。arrayList是线程非安全的。如果要实现线程安全，可以： List list = Collections.synchronizedList(new ArrayList(…)); 使用Iterator去遍历arrayList，如果列表在迭代器创建之后的任何时间被结构化地修改，除了通过迭代器自己的remove或add方法之外，都会抛出一个ConcurrentModificationException，下面这段代码中，因为在iterator创建之后调用了ArrayList的remove方法，所以会抛出异常。12345Iterator iterator = list.iterator(); while (iterator.hasNext())&#123; list.remove(0); iterator.remove(); &#125; ArrayList的实现：12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList几个比较重要的常量：1234/** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; 默认初始容量为10。为什么定义为10？官网上没有给出解释，带着这个疑问我Google了一下，这个默认初始容量可以为任意正整数，为1太少，肯定会做一些大小的调整，100会浪费掉空间，前辈们肯定是做了性能分析和空间分析取出了中间值。1234/** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 用于空实例的共享空数组实例。123456/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 一个空数组实例，当用户没有指定 ArrayList 的容量时(即调用无参构造函数)，返回的是该数组==&gt;刚创建一个 ArrayList 时，其内数据量为 0。当用户第一次添加元素时，该数组将会扩容，变成默认容量为10(DEFAULT_CAPACITY)的一个数组===&gt;通过ensureCapacityInternal()实现，它与 EMPTY_ELEMENTDATA 的区别就是：该数组是默认返回的，而后者是在用户指定容量为0时返回。12345678/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. * */transient Object[] elementData; // non-private to simplify nested class access 存储ArrayList元素的数组缓冲区。ArrayList的容量是此数组缓冲区的长度。任何空的ArrayList elementData的值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA（就是一个空数组）当第一个元素被添加的时候，elementData会扩大到DEFAULT_CAPACITY（也就是10）注意：一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。transient关键字用来用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。ArrayList在序列化的时候会调用writeObject，直接将size和element写入ObjectOutputStream；反序列化时调用readObject，从ObjectInputStream获取size和element，再恢复到elementData。为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。12345/** * The size of the ArrayList (the number of elements it contains). * @serial */ private int size; ArrayList的大小（包含的元素数）。12345678910111213141516171819202122232425262728293031323334353637383940private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; 构造方法ArrayList一共有三个构造方法：123456789101112131415161718/** * Constructs an empty list with the specified initial capacity. * 构造一个指定长度的空列表 * @param initialCapacity the initial capacity of the list * 列表的初始容量 * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; 第一个构造方法主要用于构造一个指定长度的空列表，参数为需要构造列表的初始容量，在这里我们看到当initialCapacity == 0 的时候 elementData = EMPTY_ELEMENTDATA 123456/** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 第二个构造方法构造一个初始容量为10的空list。1234567891011121314151617181920/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) //如果返回值不是Object[]转为Object[] elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 第三个构造方法则将传入的集合转成数组赋值给elementData,如果为空则赋值为上面的共享空数组实例（EMPTY_ELEMENTDATA）。 主要方法接下来看一看ArrayList的主要方法（方法太多就不一一介绍了，有兴趣的同学可以自己看看一源码）：123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 返回指定元素在list中第一次出现的位置。需要注意的是当传入的值为null时并不会报错，因为null也可以作为元素插入ArrayList,查询方式为循环依次查找。如果没有匹配到返回-1。123456789101112public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 与indexOf同理，不过lastIndexOf方法的查找方式为从后向前查找。1234567891011public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; 对原有arrayList实例的浅拷贝。123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; 返回一个新的Object数组，对该数组操作不会影响原有list12345678910@SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; 该方法是传入一个泛型数组a,当a.length&lt;size时，按照list的size创建一个新的数组返回，数组中包含所有list的元素。如果a.length&gt;=size时，则将 list 中的元素按顺序存入 a 中，然后a[list.size] = null, a[list.size + 1] 及其后的元素依旧是 a 的元素,附上测试代码：12345678910public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("a"); list.add("b"); list.add("c"); String[] s = new String[5]; s[0] = "0";s[1] = "1";s[2] = "2";s[3] = "3";s[4] = "4"; String[] c = list.toArray(s); System.out.println(c.length +" " + c[0] + " " + c[1] + " " + c[2] + " " + c[3] + " " + c[4]); &#125; 输出：5 a b c null 4请注意这句话 Make a new array of a’s runtime type, but my contents创建一个新的数组的运行时类型，就是说返回的并不一定是Object[],而是运行时的类型，为什么会出现这种情况呢？原因很简单，因为由于继承的原因，我们父类实例的具体类型，实际上是取决于在 new 时，我们所使用的子类类型。12345public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; 返回指定位置的元素。rangeCheck method: 该方法判断了如果index &gt;= size 则throw一个 IndexOutOfBoundsExceptionelementData method：返回在索引为 index 的元素，主要是避免每次取值都需要强转（看到这里不得不佩服前辈们，要是我自己来写目前肯定封装的不会这么好）1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; 该方法是在指定索引处插入指定元素，并把被替换的元素返回。12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code //防止溢出 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //这里的oldCapacity &gt;&gt; 1相当于 oldCapacity/2 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; add方法就是向list末尾添加数据，但是这时候要考虑容量问题。ensureCapacityInternal方法：若 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 即{}，则取 minCapacity 为 默认容量和参数 minCapacity 之间的最大值。 这里需要介绍一下modCount变量，他是父类AbstractList中的变量主要用于记录arrayList结构变化&gt;的次数，每变化一次增加1.拥有这个参数的方法都是线程不安全的，在一个迭代器初始的时候会赋予它调&gt;用这个迭代器的对象的mCount，如何在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存&gt;储的mcount不一样那就抛异常 grow方法:增加容量以确保它至少能够容纳最小容量参数指定的元素数。如果扩容后大于最大存储容量,则调用hugeCapacity方法，MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8（为什么是Integer.MAX_VALUE - 8呢？只是为了避免一些机器内存溢出，最大长度依然是Integer.MAX_VALUE，并不是Integer.MAX_VALUE-8） 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 在该列表中的指定位置插入指定的元素。将当前位于该位置的元素（如果有）和任何后续元素（向其索引添加一个）移动。1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 移除指定索引位置的元素：index 之后的所有元素依次左移一位 12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; 移除指定的一个元素，索引位置最低的。123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 删除此列表的所有元素。 12345678public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; 将一个集合的所有元素顺序添加到list末尾。12345678910111213141516public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 从指定的位置开始将指定集合中的所有元素插入到此列表中。将当前处于该位置的元素（如果有的话）和随后的任何元素移动到右边（增加其索引）。新元素将按照指定集合的迭代器返回的顺序显示在列表中。123456789101112131415161718192021222324252627282930313233public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; 移除list中和c中共有的元素。1234public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; 保留list中和c中共有的元素。 总结1、ArrayList基于数组实现，其内存储元素的数组为elementData2、ArrayList中EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY._ELEMENTDATA虽然都是空数组，但是使用场景不同。前者是通过ArrayList(int initialCapacity)该构造方法直接指定初试容量为0时，后者是用户直接使用无参构造创建ArrayList时。3、ArrayList的扩容计算为newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 且扩容并非是无限制的，有内存限制、虚拟机限制。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO + github 创建自己的个人博客]]></title>
    <url>%2F2017%2F09%2F24%2FhexoBlog%2F</url>
    <content type="text"><![CDATA[hexo + github 创建自己的个人博客最近想搞一个自己的博客，写一些自己平时工作中的积累，终于搭好了，写一下搭建博客的过程。hexo是一款基于Node.js的静态博客框架,所以安装node.js是必须的（这个就不写了，node官网下载，安装）。申请GitHub（必须）作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 安装hexonode和git安装好后创建一个文件夹blog，安装hexo： sudo npm install -g hexo 执行init命令初始化hexo: hexo init 生成静态页面: hexo generate（hexo g也可以） 配置github建立Repository 建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联，我的blog在本地/user/local/bin/blog，blog是我之前建的东西也全在这里面，有： _config.yml node_modules public source db.json package.json scaffolds themes 现在我们需要_config.yml文件，来建立关联，命令： vi _config.yml 翻到最下面，改成我这样子的 deploy: type: git repo: https://github.com/yougithub/youname.github.io.git branch: master repo也可以写成yougithubname:youpassword@https://github.com/yougithub/youname.github.io.git注意所有的：后面都有一个空格。 生成添加秘钥在终端（Terminal）输入： ssh-keygen -t rsa -C “Github的注册邮箱地址” 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入https://github.com/settings/ssh： 将复制的内容粘贴到Key的输入框，随便写好Title里面的内容，点击Add SSH key按钮即可。可以本地启动服务进行预览，命令： hexo server (hexo s 也可以) 浏览器输入localhost:4000 每次部署的步骤，可按以下三步来进行。 hexo clean hexo generate(hexo g) hexo deploy(hexo d) 参考：http://www.jianshu.com/p/465830080ea9http://www.jianshu.com/p/e99ed60390a8 标签页／分类页 参考：http://theme-next.iissnan.com/theme-settings.html#syntax-highlight-scheme 头像／logo 参考：http://cherryblog.site/Hexo-high-level-tutorialcloudmusic,bg-customthemes-statistical.html 站内搜索 参考：https://zetaoyang.github.io/post/2016/07/08/hexo-localsearch.html]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM学习笔记－－垃圾收集器与内存分配策略(一)]]></title>
    <url>%2F2018%2F04%2F23%2Fjava%2Fjvm%2FobjectDeadOrLife%2F</url>
    <content type="text"><![CDATA[前面我们介绍了java内存运行时的各个内存区域，本文将介绍java中大名鼎鼎的垃圾收集器与内存分配策略。说到垃圾收集器（Garbage Collection, GC），大部分人都会认为它是java的伴生产物，其实不然，GC的历史比java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。 垃圾收集需要解决的事情 哪些内存需要回收 什么时候回收 如何回收 根据JVM学习笔记－－java中的OutOfMemoryError异常中介绍的jvm内存模型中，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，故这几个区域就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而java堆和方法区（1.8中是元空间）则不一样，一个方法中的多个分支需要的内存可能不一样，一个接口的多个实现类也可能不一样，只有在程序处于运行期间才能知道会创建哪些对象，这部分的内存分配和回收都是动态的，垃圾收集器所关注的就是这部分内存。 对象已死吗在堆中存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象之中哪些还存活着，哪些已经死去。 引用计数算法给对象添加一个引用计数器，每当有一个地方引用它的地方，计数器值+1；当引用失效，计数器值就减1;任何时候计数器为0，对象就不可能再被引用了。 优势：实现简单，效率高。致命缺陷：无法解决对象相互引用的问题，会导致对象的引用虽然存在，但是已经不可能再被使用，却无法被回收。 可达性分析算法在主流的商用程序语言中（Java和C#，甚至包括前面提到的古老的Lisp），都是使用根搜索算法（GC Roots Tracing）判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，如下图（object1，object2，object3， object4都是存活的对象，object5，object6，object7是下一次GC会被回收掉的对象）： GC Roots包括： 虚拟机栈（栈帧中的本地变量表）中的引用的对象。 类静态属性引用的对象。 常量引用的对象。 本地方法栈中JNI（即一般说的Native方法）的引用的对象。 更详细的GC Roots请移步help.eclipse.org或查看一下内容GC Roots是可以从堆外部访问的对象。以下原因使对象成为GC Roots：系统类 由bootstrap或系统类加载器加载的类。例如，所有从rt.jar类似java.util。。本地JNI 本地代码中的局部变量，如用户定义的JNI代码或JVM内部代码。JNI Global 本地代码中的全局变量，例如用户定义的JNI代码或JVM内部代码。线程块 从当前活动的线程块引用的对象。线程 开始但未停止的线程。Busy Monitor 所有已调用wait（）或notify（）或已同步的东西。例如，通过调用synchronized（Object）或通过输入一个同步方法。静态方法表示类，非静态方法表示对象。Java本地局部变量 例如，输入参数或仍然在线程堆栈中的方法的本地创建对象。本地堆栈 本地代码中的输入或输出参数，例如用户定义的JNI代码或JVM内部代码。这通常是这种情况，因为许多方法具有本地部分，并且作为方法参数处理的对象成为GC Roots。例如，用于文件/网络I/O方法或反射的参数。Finalizable 等待其终结器运行的队列中的对象。Unfinalized 具有finalize方法的对象，但尚未完成且尚未处于终结器队列中。Unreachable 无法从任何其他根目录获得的对象，但已被MAT标记为根目录以保留否则将不包含在分析中的对象。Java堆栈帧 一个Java堆栈框架，持有局部变量。仅在使用首选项设置将Java堆栈帧视为对象来分析转储时才会生成。*Unknown 未知根类型的对象。某些转储（例如IBM Portable Heap Dump文件）没有根信息。对于这些转储，MAT解析器会将没有入站引用的对象标记为对象，或者从任何其他根目录无法访问此类型的根。这可以确保MAT保留转储中的所有对象。 引用java1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。主要是希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。 强引用就是指在程序代码之中普遍存在的，类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。 生存还是死亡在可达性分析算法中不可达的对象，它们暂时处于&quot;缓刑&quot;阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为&quot;没有必要执行&quot;。 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的&quot;执行&quot;是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。下面例子可以看出finalize()被执行，但是它仍然可以存活。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package jvm.gc;/** * 此代码演示了两点： * 1.对象可以在被GC时自我拯救 * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只能被系统自动调用一次 */public class FinalizeEscapeGC &#123; public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive() &#123; System.out.println("yes, I am still alive :)"); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("finalize method executed!"); SAVE_HOOK = this; &#125; public static void main(String[] args) throws InterruptedException &#123; SAVE_HOOK = new FinalizeEscapeGC(); // 对象第一次自救成功 SAVE_HOOK = null; System.gc(); //因为finalize方法优先级很低,所以暂停0.5秒等待它 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println("no, i am dead :("); &#125; //代码和上面的一样 但是这次自救失败 SAVE_HOOK = null; System.gc(); //因为finalize方法优先级很低,所以暂停0.5秒等待它 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println("no, i am dead :("); &#125; &#125;&#125; 运行结果123finalize method executed!yes, I am still alive :)no, i am dead :( finalize()方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，所以不建议使用它。 方法区及元空间回收方法区Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的&quot;性价比&quot;一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串&quot;abc&quot;已经进入了常量池中，但是当前系统没有任何一个String对象是叫做&quot;abc&quot;的，换句话说是没有任何String对象引用常量池中的&quot;abc&quot;常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个&quot;abc&quot;常量就会被系统清出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 判定一个常量是否是&quot;废弃常量&quot;比较简单，而要判定一个类是否是&quot;无用的类&quot;的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是&quot;无用的类&quot;： 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class及-XX:+TraceClassLoading、 -XX:+TraceClassUnLoading查看类的加载和卸载信息。 在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。 Metaspace垃圾回收 对于僵死的类及类加载器的垃圾回收将在元数据使用达到”MaxMetaspaceSize”参数的设定值时进行。 适时地监控和调整元空间对于减小垃圾回收频率和减少延时是很有必要的。持续的元空间垃圾回收说明，可能存在类、类加载器导致的内存泄漏或是大小设置不合适。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--唯一摩尔斯密码词(Unique Morse Code Words)]]></title>
    <url>%2F2018%2F04%2F21%2FleetCode%2FuniqueMorseCodeWords%2F</url>
    <content type="text"><![CDATA[原题：国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: “a” 对应 “.-“, “b” 对应 “-…”, “c” 对应 “-.-.”, 等等。 为了方便，所有26个英文字母对应摩尔斯密码表如下：1[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;] 给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-.-….-“，(即 “-.-.” + “-…” + “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。 返回我们可以获得所有词不同单词翻译的数量。 例如:输入: words = [“gin”, “zen”, “gig”, “msg”]输出: 2解释:各单词翻译如下:“gin” -&gt; “–…-.”“zen” -&gt; “–…-.”“gig” -&gt; “–…–.”“msg” -&gt; “–…–.” 共有 2 种不同翻译, “–…-.” 和 “–…–.”. 注意 单词列表words 的长度不会超过 100。 每个单词 words[i]的长度范围为 [1, 12]。 每个单词 words[i]只包含小写字母。 解题思路思路比较简单，把每个单词翻译后，去掉重复的进行计算。 代码实现（java）：1234567891011121314151617class Solution &#123; public int uniqueMorseRepresentations(String[] words) &#123; String[] morse = &#123;".-","-...","-.-.","-..",".","..-.","--.","....","..", ".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-", "..-","...-",".--","-..-","-.--","--.."&#125;; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (String word : words) &#123; StringBuilder code = new StringBuilder(); for (int i = 0; i &lt; word.length(); i++) &#123; code.append(morse[word.charAt(i) - 'a']); &#125; set.add(code.toString()); &#125; return set.size(); &#125;&#125; python实现：1234567891011121314151617class Solution(object): def uniqueMorseRepresentations(self, words): """ :type words: List[str] :rtype: int """ morse = [".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."] m = set() for word in words: s = "" for i in word: s = '%s%s' % (s, morse[ord(i) - ord('a')]) m.add(s) return len(m) go实现123456789101112131415func uniqueMorseRepresentations(words []string) int &#123; morse := []string&#123;".-","-...","-.-.","-..",".","..-.","--.","....","..", ".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-", "..-","...-",".--","-..-","-.--","--.."&#125; m := make(map[string]string) for i := range words &#123; b := bytes.Buffer&#123;&#125; for j := 0; j &lt; len([]rune(words[i])); j++&#123; b.WriteString(morse[words[i][j] - 'a']) &#125; m[b.String()] = words[i] &#125; return len(m)&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记－－java中的OutOfMemoryError异常]]></title>
    <url>%2F2018%2F04%2F14%2Fjava%2Fjvm%2Foom%2F</url>
    <content type="text"><![CDATA[前面JVM学习笔记－－java内存区域总结过jvm的内存布局以及对象如何在内存中创建、访问的，这篇主要讲解OutOfMemoryError异常出现的区域及什么样的代码会导致该异常。在java虚拟机规范的描述中，除了程序计数器之外，虚拟机内存的其它几个运行时区域都可能会出现OutOfMemoryError异常。 下文中出现的代码，github地址 java堆溢出java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量达到最大堆的容量后就会产生内存溢出异常。下面的代码中限制堆大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便之后进行分析，可以利用-XX:HeapDumpPath参数设置转储快照文件地址，代码示例：1234567891011121314151617181920package jvm.oom;import java.util.ArrayList;import java.util.List;/** * VM args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError */public class HeapOOM &#123; static class OOMObject&#123;&#125; public static void main(String[] args) &#123; List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;(); while (true)&#123; list.add(new OOMObject()); &#125; &#125;&#125; 运行结果：123java.lang.OutOfMemoryError: Java heap spaceDumping heap to /Users/penghb/oom.hprof ...Heap dump file created [27948743 bytes in 0.170 secs] java堆内存的OOM异常是实际中常见的内存溢出异常情况。当出现java堆内存溢出时，异常栈信息“java.lang.OutOfMemoryError”，会跟着进一步提示“Java heap space”。要解决这个区域的异常，一般的手段就是通过内存映像分析工具（如jvisualvm）对Dump出来对转储快照进行分析，重点是确定内存的对象是否是必要的，也就是要分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出(Memory Overfloe)。 内存泄露：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。内存溢出:程序要求的内存，超出了系统所能分配的范围。 下图是使用jvisualvm打开堆转储快照的文件： 如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。这样就可以比较准确的定位出泄露代码的位置。如果不存在泄露，就要看看是否可以适当的扩展虚拟机的堆参数，从代码上检查是否有某些对象的生命周期是否过长，尝试减少程序运行期的内存消耗。这里简单的介绍一下处理的思路、工具和方法，后续会有更详细的内容介绍这部分知识。 虚拟机栈和本地方法栈溢出由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在java虚拟机栈规范中描述了两种异常： StackOverFlowError：线程申请的栈深度超过允许的最大深度 OutOfMemoryError： 虚拟机扩展时无法申请到足够的内存空间 单线程中虚拟机栈和本地方法栈OOM测试代码：123456789101112131415161718192021222324package jvm.oom;/** * VM args: -Xss160k */public class JavaVMStackSOF &#123; private int stackLength = 1; public void stackLength() &#123; stackLength++; stackLength(); &#125; public static void main(String[] args) &#123; JavaVMStackSOF javaVMStackSOF = new JavaVMStackSOF(); try&#123; javaVMStackSOF.stackLength(); &#125;catch (Throwable e)&#123; System.out.println("stack length:" + javaVMStackSOF.stackLength); throw e; &#125; &#125;&#125; 运行结果：123456Exception in thread &quot;main&quot; java.lang.StackOverflowErrorstack length:771 at jvm.oom.JavaVMStackSOF.stackLength(JavaVMStackSOF.java:11) at jvm.oom.JavaVMStackSOF.stackLength(JavaVMStackSOF.java:12) at jvm.oom.JavaVMStackSOF.stackLength(JavaVMStackSOF.java:12) ....... 在单线程环境下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverFlowError异常。在多线程环境下，通过不断建立线程的方式可以产生内存溢出异常，如下代码片段：123456789101112131415161718192021222324package jvm.oom;public class JavaVMStackOOM &#123; private void dontStop() throws InterruptedException &#123; while(true)&#123; Thread.sleep(900000); &#125; &#125; public void stackLeakByThread()&#123; while(true) new Thread(() -&gt; &#123; try &#123; dontStop(); &#125; catch (InterruptedException e) &#123; &#125; &#125;).start(); &#125; public static void main(String[] args) &#123; JavaVMStackOOM1 oom = new JavaVMStackOOM1(); oom.stackLeakByThread(); &#125;&#125; 运行结果：12345Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread at java.lang.Thread.start0(Native Method) at java.lang.Thread.start(Thread.java:717) at jvm.oom.JavaVMStackOOM1.stackLeakByThread(JavaVMStackOOM1.java:17) at jvm.oom.JavaVMStackOOM1.main(JavaVMStackOOM1.java:22) 但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系（为每个线程的栈分配的内存越大，反而更容易产生内存溢出异常）。原因其实不难理解，操作系统分配给每个进程的内存是有限制的，譬如32位的Windows限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。这一点开发者需要在开发多线程应用的时候特别注意，出现StackOverflowError异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的，所以只能说大多数情况下）达到1000～2000完全没有问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。如果没有这方面的经验，这种通过“减少内存”的手段来解决内存溢出的方式会比较难以想到。 方法区和运行时常量池溢出（1.6到1.8的变化对比） 运行时常量池是方法区的一部分，方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。String.intern()是一个native方法，它的作用是：如果字符串常量池中已经包含了一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并返回此String对象的引用。在JDK1.6及之前版本中，由于常量池分配在永久代中(即方法区)，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量，注意，JDK1.7开始逐步开始“去永久代”。代码如下所示：1234567891011121314151617181920package jvm.oom;import java.util.ArrayList;import java.util.List;/** * VM args: -Xms20m -Xmx20m -XX:PermSize=10m -XX:MaxPermSize=10m */public class RunTimeConstantPoolOOM &#123; public static void main(String[] args) &#123; //使用List保持着常量池引用，避免Full GC回收常量池行为 List&lt;String&gt; list = new ArrayList&lt;&gt;(); //10MB的PermSize在integer范围内足够产生OOM了 int i = 0; while (true)&#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 运行结果：123Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) at jvm.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:16) 从运行结果中可以看到，运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区（HotSpot虚拟机中的永久代）的一部分。但是使用JDK1.7运行这段程序不会得到相同的结果，而是会一直循环下去，同时发现内存一直在上升，当上升到一个极值就会趋于平稳，然后会出现：1234Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded at java.lang.Integer.toString(Integer.java:403) at java.lang.String.valueOf(String.java:3099) at jvm.oom.RunTimeConstantPoolOOM.main(RunTimeConstantPoolOOM.java:17) 这个异常是当GC的时间超过总运行时间的98%才会报的，是为了防止GC占用的时间过长。增加-Xmx20m -Xms20m -XX:-UseGCOverheadLimit参数测试（-XX:-UseGCOverheadLimit是关闭GC占用时间过长时会报的异常），运行结果：12345678Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:2245) at java.util.Arrays.copyOf(Arrays.java:2219) at java.util.ArrayList.grow(ArrayList.java:242) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:216) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:208) at java.util.ArrayList.add(ArrayList.java:440) at jvm.oom.RunTimeConstantPoolOOM.main(RunTimeConstantPoolOOM.java:17) 根据运行结果发现jdk1.7中运行时常量池已经转移到堆中，并且官网也给出了相应的说明：http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html 在jdk1.8中，方法区已经被彻底的移除，新增加了元空间,在jdk1.8的环境下执行该代码会出现以下结果：12345678910Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=10m; support was removed in 8.0Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=10m; support was removed in 8.0Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) at java.util.Arrays.copyOf(Arrays.java:3181) at java.util.ArrayList.grow(ArrayList.java:261) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227) at java.util.ArrayList.add(ArrayList.java:458) at jvm.oom.RunTimeConstantPoolOOM.main(RunTimeConstantPoolOOM.java:17) 是因为JVM参数PermSize和MaxPermSize会被忽略并给出警告（如果在启用时设置了这两个参数）。 Metaspace如果不设定大小会动态扩展的，如果设定大小后 也会出现java.lang.OutOfMemoryError: Metadata space 代码示例如下（cglib代理直接操作字节码运行时生成大量的动态类）：12345678910111213141516171819202122package jvm.metadataOOM;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;/** * VM args: -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m */public class MetadataOOM &#123; static class OOMObject&#123;&#125; public static void main(String[] args) &#123; while (true)&#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -&gt; methodProxy.invokeSuper(o, objects)); enhancer.create(); &#125; &#125;&#125; 一个类要被判定为可以被垃圾器回收，判定的条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状态。 本机直接内存溢出DirectMemory可以通过-XX:MaxDirectMemorySize指定，如果不指定，责与java堆最大内存一致，下面的代码通过反射获取Unsafe实例进行内存分配。会抛出java.lang.OutOfMemoryError123456789101112131415161718192021package jvm.metadataOOM;import sun.misc.Unsafe;import java.lang.reflect.Field;/** * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M */public class DirectMemoryOOM &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws Exception &#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。 总结以上是对java虚拟机运行时各个区域会出现的oom的分析。 参考周志明老师的《深入理解java虚拟机》]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Median of Two Sorted Arrays]]></title>
    <url>%2F2018%2F03%2F01%2FleetCode%2FmedianofTwoSortedArrays%2F</url>
    <content type="text"><![CDATA[原题：There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example1 nums1 = [1, 3]nums2 = [2] The median is 2.0 Example2 nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 题目大意有两个大小分别为m和n的排序数组nums1和nums2。查找两个排序数组的中位数。总的运行时间复杂度应该是O（log（m + n））。 解题思路比较复杂的一道题，参考了两个有序数组中的中位数和Top K问题代码实现（java）：12345678910111213141516171819202122232425class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int i = nums1.length, j = nums2.length; if (i &gt; j) return findMedianSortedArrays(nums2, nums1); int l1 = 0, l2 = 0, r1 = 0, r2 = 0, c1, c2, left = 0, right = 2 * i; while (left &lt;= right)&#123; c1 = (left + right)/2; c2 = i + j - c1; l1 = c1 == 0 ? Integer.MIN_VALUE : nums1[(c1 - 1)/2]; r1 = c1 == 2 * i ?Integer.MAX_VALUE : nums1[c1/2]; l2 = c2 == 0 ? Integer.MIN_VALUE : nums2[(c2 - 1)/2]; r2 = c2 == 2 * j ? Integer.MAX_VALUE : nums2[c2/2]; if(l1 &gt; r2) right = c1 - 1; else if(l2 &gt; r1) left = c1 + 1; else break; &#125; return (Integer.max(l1, l2)+ Integer.min(r1, r2))/2.0; &#125;&#125; python实现：1234567891011121314151617181920212223242526272829class Solution(object): def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ i = len(nums1) j = len(nums2) if i &gt; j: return self.findMedianSortedArrays(nums2, nums1) left = 0 right = 2 * i l1 = l2 = r1 = r2 = c1 = c2 = 0 while left &lt;= right: c1 = (left + right) / 2 c2 = i + j - c1 l1 = -sys.maxint - 1 if c1 == 0 else nums1[(c1 - 1)/2] r1 = sys.maxint if c1 == 2 * i else nums1[c1/2] l2 = -sys.maxint - 1 if c2 == 0 else nums2[(c2-1)/2] r2 = sys.maxint if c2 == 2 * j else nums2[c2/2] if l1 &gt; r2: right = c1 - 1 elif l2 &gt; r1: left = c1 + 1 else: break return (max(l1, l2) + min(r1, r2))/2.0]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Merge Sorted Array]]></title>
    <url>%2F2018%2F03%2F01%2FleetCode%2FmergeSortedArray%2F</url>
    <content type="text"><![CDATA[原题：Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. NoteYou may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 题目大意给定两个排序的整数数组nums1和nums2，将nums2合并为nums1作为一个排序数组。 注意你可以假设nums1有足够的空间（大小大于或等于m + n）来保存nums2中的其他元素。 nums1和nums2中初始化的元素数量分别为m和n。 解题思路从尾部开始做归并。代码实现（java）：1234567891011class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m - 1, j = n - 1, index = m + n - 1; while (index &gt;= 0)&#123; if(i &lt; 0 || j &lt; 0) nums1[index--] = i &lt; 0 ? nums2[j--] : nums1[i--]; else nums1[index--] = nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--]; &#125; &#125;&#125; python实现：123456789101112131415161718class Solution(object): def merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. """ i, j, index = m-1, n-1, m+n-1 while i &gt;= 0 and j &gt;= 0: if nums1[i] &gt; nums2[j]: nums1[index] = nums1[i] i, index = i-1, index-1 else: nums1[index] = nums2[j] j, index = j-1, index-1 nums1[:j+1] = nums2[:j+1]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Toeplitz Matrix]]></title>
    <url>%2F2018%2F02%2F28%2FleetCode%2FtoeplitzMatrix%2F</url>
    <content type="text"><![CDATA[原题：A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz. Example1 Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]Output: TrueExplanation:123451239512 In the above grid, the diagonals are “[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”, and in each diagonal all elements are the same, so the answer is True. Example2 Input: matrix = [[1,2],[2,2]]Output: FalseExplanation:The diagonal “[1, 2]” has different elements. Note matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99]. 题目大意二维数组中对角线上的数字都相等即返回true。 解题思路比较简单的一道题，检测对角线上的数据是否相等就可以。代码实现（java）：12345678910111213class Solution &#123; public boolean isToeplitzMatrix(int[][] matrix) &#123; int x = matrix.length; int y = matrix[0].length; for (int i = 0; i &lt; x - 1; i++)&#123; for (int j = 0; j &lt; y - 1; j++)&#123; if (matrix[i][j] != matrix[i+1][j+1]) return false; &#125; &#125; return true; &#125;&#125; python实现：1234567891011class Solution(object): def isToeplitzMatrix(self, matrix): """ :type matrix: List[List[int]] :rtype: bool """ for i in range(len(matrix) - 1): for j in range(len(matrix[0]) - 1): if matrix[i][j] != matrix[i+1][j+1]: return False return True]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Jewels and Stones]]></title>
    <url>%2F2018%2F02%2F27%2FleetCode%2FjewelsAndStones%2F</url>
    <content type="text"><![CDATA[原题：You’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”. Example1 Input: J = “aA”, S = “aAAbbbb”Output: 3 Example2 Input: J = “z”, S = “ZZ”Output: 0 Note S and J will consist of letters and have length at most 50. The characters in J are distinct. 题目大意J是宝石类型，S是自己拥有的，需要看看自己手中的石头有多少是宝石。区分大小写。 注意： J中的字符是不同的。 S和J将由字母组成，最多长度为50。 解题思路利用HashSet这个结构，将宝石作为HashSet的键值key，再遍历字符串S，HashSet中是否已存在这些key值。代码实现（java）：1234567891011121314class Solution &#123; public int numJewelsInStones(String J, String S) &#123; int result = 0; Set set = new HashSet(); for (char ch : J.toCharArray()) set.add(ch); for(char ch : S.toCharArray())&#123; if(set.contains(ch))&#123; result ++; &#125; &#125; return result; &#125;&#125; python实现：12345678class Solution(object): def numJewelsInStones(self, J, S): """ :type J: str :type S: str :rtype: int """ return sum(S.count(j) for j in J)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记－－HotSpot虚拟机在Java堆中对象是如何创建、如何布局以及如何访问]]></title>
    <url>%2F2018%2F02%2F27%2Fjava%2Fjvm%2FobjectCreateLayoutVisit%2F</url>
    <content type="text"><![CDATA[之前我们大致介绍了，JVM运行时的内存区域，这一篇我们会探讨一下JVM中的对象是如何创建、布局、以及使用的。以下的讨论都是基于HotSpot虚拟机展开的。 对象的创建java是一门面向对象的语言，在程序运行中无时无刻都有对象的创建，在语言层面对象的创建（例如克隆、反序列化）通常仅仅是一个new关键字，那在虚拟机中对象（本文中讨论的对象限于普通Java对象，不包括数组和Class对象等）是如何创建的呢？虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个类的符号引用代表的类是否已经被加载、解析和初始化过。如果没有那必须先执行相应的类加载过程（类加载过程在后续的博文中会讲）。在类加载检查通过之后，虚拟机会为新生的对象分配内存。对象所需要的内存大小在类加载完成后就会完全确定（后续的博文也会讲道），为对象分配内存的过程相当于把一块确定大小的内存从java堆中划分出来。 内存分配方式指针碰撞(Bump the Pointer)假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲那边挪动一段与对象大小相等的距离。 空闲列表(Free List)如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交替，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。 如何选择内存的分配方式当然，选择内存的分配方式是由java堆是否规整决定的，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带有Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。 线程安全的问题在虚拟机中分配内存时，即便是仅仅修改一个指针所指向的位置，也可能会出现的线程安全问题，比如，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。那么，如何解决线程安全的问题呢？解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁。虚拟机是否适用TLAB，可以通过-XX:+/-UseTLAB参数来确定。 内存分配完成以后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头，对象头稍后介绍），如果使用TLAB这一工作也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。接下来，虚拟机会对对象做必要的设置，例如，这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息都存在对象的对象头之中（Object Header）。根据虚拟机的运行状态不同，是否启用偏向锁等，对象头会有不同的设置方式。 对象的内存布局在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。 对象头对象头主要包括两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit、64bit，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示： 这里要特别关注的是锁标志位，锁标志位与是否偏向锁对应到唯一的锁状态。所以锁的状态保存在对象头中，所以再理解Synchronized锁的到底是什么, 锁住的是代码还是对象)（答案锁的是对象）？java中锁，锁的是对象，它是怎么实现的？这两个问题就好懂了。 第二部分就是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是数组，对象头中还要记录数组长度。 实例数据接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容（无论是从父类中继承下来的，还是在子类中定义的）。这部分数据的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为：longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 对齐填充第三部分的对齐填充并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。由于HotSpot自动管理系统要求对象起始地址必须是8字节的整数倍，就是对象必须是8字节的整数倍。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要对齐填充来补全。 对象的访问定位创建对象是为了使用对象，我们的java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方法去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。 如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息: 如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址: （上面两图中的方法区已经从1.8移除并转移到元空间，由于偷懒这里就不自己做图了！） 优势句柄访问：reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。直接指针访问：速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 最后，就我们讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式（直接指针）进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况十分常见。 参考《深入理解java虚拟机》]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CyclicBarrier的使用及分析（jdk1.8）]]></title>
    <url>%2F2018%2F02%2F09%2FcyclicBarrier%2F</url>
    <content type="text"><![CDATA[开始是想和CountDownLatch写在一篇的 但是怕篇幅太长就分开来写了,CyclicBarrier从字面上理解是循环阻碍，它是一个同步辅助类，允许一个或多个线程互相等待，直到到达某个点，并且可以多次循环。下面还是先看一个实例。 实例12345678910111213141516171819202122232425262728293031public class CyclicBarrierTest &#123; public static void main(String[] args) &#123; int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for(int i=0;i&lt;N;i++) new Writer(barrier).start(); &#125; static class Writer extends Thread&#123; private CyclicBarrier cyclicBarrier; public Writer(CyclicBarrier cyclicBarrier) &#123; this.cyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; System.out.println("线程"+Thread.currentThread().getName()+"正在写入数据..."); try &#123; Thread.sleep(5000); System.out.println("线程"+Thread.currentThread().getName()+"写入数据完毕，等待其他线程写入完毕"); cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;catch(BrokenBarrierException e)&#123; e.printStackTrace(); &#125; System.out.println("所有线程写入完毕，继续处理其他任务..."); &#125; &#125;&#125; 输出：123456789101112线程Thread-0正在写入数据...线程Thread-2正在写入数据...线程Thread-1正在写入数据...线程Thread-3正在写入数据...线程Thread-0写入数据完毕，等待其他线程写入完毕线程Thread-2写入数据完毕，等待其他线程写入完毕线程Thread-3写入数据完毕，等待其他线程写入完毕线程Thread-1写入数据完毕，等待其他线程写入完毕所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务... 通过输出可以看出当所有线程都写入完毕后才开始继续运行。 源码分析构造函数123456public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction; &#125; CyclicBarrier提供了两个构造方法，但最后调的都是这个，就是做个参数效验，然后赋值没什么难点，barrierAction参数是都到了共同点之后可以先执行一个动作。 属性介绍1234567891011121314151617181920212223//处在等待状态的线程个数private int count; //必须同时到达barrier的线程个数 private final int parties;//表示parties个线程到达barrier时，执行的动作 private final Runnable barrierCommand; //一个可重入锁，CyclicBarrier的主要加锁方式。 private final ReentrantLock lock = new ReentrantLock(); //通过lock得到的一个状态变量 private final Condition trip = lock.newCondition(); //通过构造器传入的参数，表示总的等待线程的数量。 private final int parties; //当屏障正常打开后运行的程序，通过最后一个调用await的线程来执行。 private final Runnable barrierCommand; //当前的Generation。每当屏障失效或者开闸之后都会自动替换掉。从而实现重置的功能。 private Generation generation = new Generation(); 内部类123private static class Generation &#123; boolean broken = false; &#125; Generation是CyclicBarrier的一个私有内部类，他只有一个成员变量来标识当前的barrier是否已”损坏”。 常用方法await1234567public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125; &#125; await是最常用也是最重要的方法，调用await()的线程会等待直到有足够数量的线程调用await－－也就是开闸状态。await是由内部方法dowait来实现的，下面我们来看看这个方法的内部实现。 dowait123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; // 获取独占锁 final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 保存当前的generation final Generation g = generation; // 若当前generation已损坏，则抛出异常。 if (g.broken) throw new BrokenBarrierException(); // 如果当前线程被中断，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。 if (Thread.interrupted()) &#123; breakBarrier(); throw new InterruptedException(); &#125; // 将计数器-1 int index = --count; // 如果index等于0了，则意味着有parties个线程到达barrier。 if (index == 0) &#123; // tripped boolean ranAction = false; try &#123; // 如果barrierCommand不为null，则执行该动作。 final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; // 唤醒所有等待线程，并更新generation。 nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) breakBarrier(); &#125; &#125; // 当前线程一直阻塞，直到有parties个线程到达barrier或当前线程被中断或超时这3者之一发生，当前线程才继续执行。 // loop until tripped, broken, interrupted, or timed out for (;;) &#123; try &#123; // 如果不是超时等待，则调用awati()进行等待；否则，调用awaitNanos()进行等待。 if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; // 如果等待过程中，线程被中断，则执行下面的函数。 if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; // We're about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // "belong" to subsequent execution. Thread.currentThread().interrupt(); &#125; &#125; // 如果当前generation已经损坏，则抛出异常。 if (g.broken) throw new BrokenBarrierException(); // 如果generation已经换代，则返回index。 if (g != generation) return index; // 如果是超时等待，并且时间已到，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。 if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; // 释放独占锁 lock.unlock(); &#125; &#125; dowait()的作用就是让当前线程阻塞，直到有parties个线程到达barrier或当前线程被中断 或超时这三者之一发生，当前线程才继续执行。 在CyclicBarrier中，同一批的线程属于同一代，即同一个Generation；CyclicBarrier中通过generation对象，记录属于哪一代。当有parties个线程到达barrier，generation就会被更新换代。如果当前线程被中断，即Thread.interrupted()为true；则通过breakBarrier()终止CyclicBarrier。 breakBarrier12345private void breakBarrier() &#123; generation.broken = true; count = parties; trip.signalAll(); &#125; breakBarrier()会设置当前中断标记broken为true，意味着“将该Generation中断”；同时，设置count=parties，即重新初始化count；最后，通过signalAll()唤醒CyclicBarrier上所有的等待线程。 nextGeneration将count计数器-1，即–count；然后判断是不是有parties个线程到达barrier，即index是不是为0。当index=0时，如果barrierCommand不为null，则执行该barrierCommand，barrierCommand就是我们创建CyclicBarrier时，传入的Runnable对象。然后，调用nextGeneration()进行换代工作，nextGeneration()的源码如下：12345private void nextGeneration() &#123; trip.signalAll(); count = parties; generation = new Generation();&#125; 首先，它会调用signalAll()唤醒CyclicBarrier上所有的等待线程；接着，重新初始化count；最后，更新generation的值。在for(;;)循环中。timed是用来表示当前是不是“超时等待”线程。如果不是，则通过trip.await()进行等待；否则，调用awaitNanos()进行超时等待。 reset12345678910public void reset() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; breakBarrier(); // break the current generation nextGeneration(); // start a new generation &#125; finally &#123; lock.unlock(); &#125; &#125; reset方法先break当执行breakBarrier操作（如果有线程在barrier上等待，调用reset会导致BrokenBarrierException），再更新generation对象。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－－Active Object（主动对象）]]></title>
    <url>%2F2018%2F02%2F07%2Fdesignpatterns%2FactiveObject%2F</url>
    <content type="text"><![CDATA[这篇文章主要介绍主动对象模式，主动对象是内部拥有自己的控制线程的对象。为了简化异步调用的复杂性，这个模式分离了方法的执行和调用。使用这个模式，一个对象中无论是否有独立的线程，客户从外部访问它时，感觉是一样的。生产者/消费者，读者/写者，这两个应用广泛的模型中，这种策略非常适合。这个模式常用在多线程的，分布式系统中。另外，一些客户端应用，如：视窗系统和网络浏览器，也可以使用主动对象模式，对并行的、异步调起的IO操作简化处理。 核心思想一种异步编程思想，允许任务的提交（相当于对异步方法的调用）和任务的执行（相当于异步方法的真正执行）分离，实现了异步编程。有利于提高并发性，从而提高系统的吞吐率。 适用场景适合分解一个比较耗时的任务（如I/O任务）已减少主线程的等待时间。 实例下面以一个实例来帮助大家理解active object模式，github上的代码例子。有一个用户类12345678910111213141516package designpatterns.activeObject;import lombok.Data;@Datapublic class User &#123; private String name; private Integer age; @Override public String toString()&#123; return "user [name=" + name + ", age=" + age + "]"; &#125;&#125; 用户服务类1234567891011121314151617package designpatterns.activeObject;public class UserService &#123; public static User getUserInfo()&#123; try &#123; // 模拟耗时操作,调用该方法的线程,要挂起5s Thread.sleep(5 * 1000); &#125; catch (InterruptedException e) &#123;&#125; User user = new User(); user.setAge(25); user.setName("penghb"); return user; &#125;&#125; 测试代码，进行同步调用1234567891011121314package designpatterns.activeObject;public class Main &#123; public static void main(String[] args) &#123; User user = UserService.getUserInfo(); System.out.println("出去玩"); System.out.println("去吃饭"); System.out.println("得到用户信息: " + user.toString()); &#125;&#125; 如果获取用户信息的代码不执行完毕，后续的流程是不会执行的，实际上后续的流程是不依赖于获取用户信息的，显然效率就会低下，下面我将用异步调用的方式来解决这个问题。1234567891011package designpatterns.activeObject;public class Proxy &#123; public static Future getUserInfo() &#123; Future future = new Future(); System.out.println(1); new Thread(new Task(future)).start(); return future; &#125;&#125; 123456789101112131415161718package designpatterns.activeObject;public class Task implements Runnable&#123; private Future future; public Task(Future future) &#123; this.future = future; &#125; @Override public void run() &#123; User user = UserService.getUserInfo(); System.out.println(user.toString()); future.setUser(user); future.setDone(true); &#125;&#125; 1234567891011121314151617package designpatterns.activeObject;import lombok.Data;@Datapublic class Future &#123; private boolean done = false; private User user; public User get() &#123; while (!done) &#123; System.out.println("模拟循环"); &#125; return user; &#125;&#125; 测试类如下12345678910111213141516package designpatterns.activeObject;public class MainTest &#123; public static void main(String[] args) &#123; // 获取用户信息 Future future = Proxy.getUserInfo(); // 获取用户信息的时候主线程还可以做其他的事情 System.out.println("出去玩"); System.out.println("去吃饭"); // 如果获取用户信息没有结束,那么当前线程挂起,等候计算完成. User user = future.get(); System.out.println("得到用户信息: " + user); &#125;&#125; 通过这种异步的方式，可以减少主线程的等待时间，增加并发量。 结构当Active Object模式对外暴露的异步方法被调用时，与该方法调用相关的上下文信息，包括被调用的异步方法名(或其代表的操作)、客户端代码所传递的参数等，会被封装成一个对象。该对象被称为方法请求(Method Request)。方法请求对象会被存入Active Object模式所维护的缓冲区(Activation Queue)中，并由专门的工作线程负责根据其包含的上下文信息执行相应的操作。也就是说，方法请求所代表的操作则由专门的工作线程来执行，从而实现了方法的调用和执行的分离，产生了并发。其类图如下： Proxy:负责对外暴露异步方法接口。其主要方法及职责如下: asyncServic:该异步方法负责创建于该方法相应的MethodRequest参与者实例，并将其提交给Scheduler参与者实例。该方法的返回值是一个Future参与者实例，客户端代码可以通过它获取异步方法对应的任务的执行结果。 MethodRequest:负责将客户端代码对Proxy实例的异步方法的调用封装为一个对象。该对象保留了异步方法的名称及客户端代码传递的参数等上下文信息。它使得Proxy的异步方法的调用和执行分离成为可能。其主要方法及职责如下: 根据其所属MethodRequest实例所包含的上下文信息调用Servant实例的相应方法。 ActivationQueue:缓冲区，用于临时存储由Proxy的异步方法被调用时所创建的MethodRequest实例。其主要方法及职责如下: 将MethodRequest实例放入缓冲区 从缓冲区中取出一个MethodRequest实例 Scheduler：负责将Proxy的异步方法所创建的MethodRequest实例存入其维护的缓冲区中，并根据一定的调度策略，对其维护的缓冲区中的MethodRequest实例进行执行。其调度策略可以根据实际需要来定，如FIFO、LIFO和根据MethodRequest中包含的信息所定的优先级等。其主要方法及职责如下: 接受一个MethodRequest实例，并将其存入缓冲区。 反复地从缓冲区中取出MethodRequest实例进行执行。 Servant:负责Proxy所暴露的异步方法的具体实现。其主要方法及职责如下: 执行Proxy所暴露的异步方法对应的任务。 Future:负责存储和获取Active Object异步方法的执行结果。其主要方法及职责如下: 获取异步方法对应的任务的执行结果。 设置异步方法对应的任务的执行结果。 整理后的代码：这是我们的Future接口，用来存储异步返回结果。1234567891011121314151617package designpatterns.activeObject.example;import lombok.Data;@Datapublic class Future&lt;T&gt; &#123; private boolean done = false; private T result; public T get() throws InterruptedException &#123; while (!done) &#123; Thread.sleep(1); &#125; return result; &#125;&#125; Servant接口123456package designpatterns.activeObject.example;public interface Servant&lt;T&gt; &#123; public T call() throws Exception;&#125; 1234567891011121314151617181920package designpatterns.activeObject.example;import designpatterns.activeObject.demo.User;public class UserServant implements Servant&lt;User&gt; &#123; @Override public User call() throws Exception &#123; try &#123; // 模拟耗时操作,调用该方法的线程,要挂起5s Thread.sleep(5 * 1000); &#125; catch (InterruptedException e) &#123;&#125; User user = new User(); user.setAge(25); user.setName("penghb"); return user; &#125;&#125; MethodRequest负责将客户端代码对Proxy实例的异步方法的调用封装为一个对象。123456789101112131415161718192021package designpatterns.activeObject.example;public class MethodRequest&lt;T&gt; &#123; private Future&lt;T&gt; future; private Servant&lt;T&gt; servant; public MethodRequest(Future&lt;T&gt; future, Servant&lt;T&gt; servant) &#123; this.future = future; this.servant = servant; &#125; public void call() &#123; try &#123; T result = servant.call(); future.setResult(result); future.setDone(true); &#125; catch (Exception e) &#123; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132package designpatterns.activeObject.example;import java.util.ArrayList;import java.util.List;// Activation List负责存储所有由代理创建的，等待执行的方法请求。// 从运行时来看,Activation List会被包括调用者线程及其Active Object线程并发存取访问，所以Activation List实现应当是线程安全的.// Activation List的实际上就是一个线程同步机制保护下的Method Request队列，对该队列的所有操作(insert/remove)都应该是线程安全的。// 从本质上讲,Activation List所基于的就是典型的生产者/消费者并发编程模型，调用者线程作为生产者把// Method Request放入该队列，Active Object线程作为消费者从该队列拿出Method Request, 并执行。public class ActivationList &#123; private List&lt;MethodRequest&gt; requestList = new ArrayList&lt;&gt;(); public synchronized void insertTask(MethodRequest request) &#123; requestList.add(request); &#125; public synchronized void removeTask(MethodRequest request) &#123; requestList.remove(request); &#125; public synchronized boolean isEmpty() &#123; return requestList.size() == 0; &#125; public synchronized MethodRequest popFirst() &#123; MethodRequest methodRequest = requestList.get(0); requestList.remove(0); return methodRequest; &#125;&#125; 12345678910111213141516171819202122package designpatterns.activeObject.example;public class StartThread implements Runnable &#123; private ActivationList activationList; public StartThread(ActivationList activationList) &#123; this.activationList = activationList; &#125; @Override public void run() &#123; while (true) &#123; if (!activationList.isEmpty()) &#123; MethodRequest request = activationList.popFirst(); request.call(); &#125; &#125; &#125;&#125; 123456789101112131415package designpatterns.activeObject.example;// scheduler:调度者运行在Active Object线程中,调度者来决定下一个执行的方法请求，// 而调度策略可以基于很多种标准，比如根据方法请求被插入的顺序FIF或者LIFO，比如根据方法请求的优先级等等。public class TaskScheduler &#123; private ActivationList activationList = new ActivationList(); public TaskScheduler() &#123; new Thread(new StartThread(activationList)).start(); &#125; public void insertRequest(MethodRequest methodRequest) &#123; activationList.insertTask(methodRequest); &#125;&#125; 最后是代理类。123456789101112131415161718package designpatterns.activeObject.example;// 代理 (Proxy)负责以下功能：// 1.proxy和servant有着相同的接口签名,或者proxy比servant接口更简单好用。这样可以方便调用者无差别的对待proxy和servant,或者更容易使用代理// 2.创建client需要的future对象,并快速返回,避免调用者线程长时间等待.客户端可以通过future对象获取实际的运算结果// 3.将调用者的方法调用转换成相应的方法请求 (Method Request)，将request和servant传给scheduler进行调度执行// 4.代理是运行在调用者线程中的,它对原始的耗时服务进行了封装,让客户端无差异的使用代理和真实对象.public class Proxy &#123; // 对任务进行调度 private static TaskScheduler taskScheduler = new TaskScheduler(); public static &lt;T&gt; Future&lt;T&gt; execute(Servant&lt;T&gt; servant) &#123; Future&lt;T&gt; future = new Future&lt;T&gt;(); MethodRequest&lt;T&gt; request = new MethodRequest&lt;T&gt;(future, servant); taskScheduler.insertRequest(request); return future; &#125;&#125; 测试类123456789101112131415161718192021package designpatterns.activeObject.example;import designpatterns.activeObject.demo.User;public class Test &#123; public static void main(String[] args) &#123; // 获取用户信息 Future&lt;User&gt; future = Proxy.execute(new UserServant()); // 后台获取用户信息时，当前线程可以继续执行 System.out.println("出去玩"); System.out.println("去吃饭"); // 如果获取用户信息还没有结束,那么当前线程挂起,等候计算完成. try &#123; User user = future.get(); System.out.println("用户信息:" + user); &#125; catch (InterruptedException e) &#123;&#125; &#125;&#125; java中的支持虽然模式的参与者较多，但其中大部分的参与者我们可以利用JDK自身提供的类来实现，以节省编码时间。 参与者名称 可以借用的JDK类 备注 Scheduler Java Executor Framework中的java.util.concurrent.ExecutorService接口的相关实现类，如java.util.concurrent.ThreadPool Executor ExecutorService接口所定义的submit(Callable task)方法相当于提交MethodRequest ActivationQueue java.util.concurrent.LinkedBlockingQueue 若Scheduler采用java.util. concurrent.ThreadPoolExecutor，则java.util.concurrent.LinkedBlocking Queue实例作为ThreadPool Executor构造器的参数传入即可 MethodRequest java.util.concurrent.Callable接口的实现类 Callable接口比起Runnable接口的优势在于它定义的call方法有返回值，便于将该返回值传递给Future实例。通常使用callable接口的匿名实现类即可 Future java.util.concurrent.Future ExecutorService接口所定义的submit(Callable task)方法的返回值类型就是java.util.concurrent. Future 以上是根据自己的理解简单举的一个例子，JDK中的实现肯定是精细的多的，有兴趣的同学可以自己写写demo，或者看看源码更详细深入的进行理解。 总结Active Object 给我们的应用带来的好处： 极大提高了应用的并发性以及简化了线程同步带来的复杂性。并发性的提高得益于调用者线程与Active Object线程的并发执行。简化的线程同步复杂性主要表现在所有线程同步细节封装在调度者内(也就是Java的Executor对象 )，Active Object调用者并不需要关心。 在Active Object中，方法的执行顺序可以不同于方法的调用顺序。用Java的话说，也就是任务执行的顺序可以不同于任务提交的顺序。在一定情况下，这可以帮助优化我们应用的性能，提高应用的QPS及其响应速度。在Java Executor框架下，你可以根据当前的计算资源，确定优化的执行策略(Execution Policy)，该执行策略的内容包括：任务将分配在多少线程上执行，以什么顺序执行，多少任务可以同时执行等等。 当然，Active Object 也有缺点： 额外的性能开销。这涉及到从调用者线程到Active Object线程的上下文切换，线程同步，额外的内存拷贝等。 难于调试。Active Object引入了方法的异步执行，从调试者的角度看，调试这样的方法调用不像普通方法那样直截了当，并且这其中涉及到了线程的调度，同步等。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记－－java内存区域]]></title>
    <url>%2F2018%2F01%2F27%2Fjava%2Fjvm%2FjvmMemory1%2F</url>
    <content type="text"><![CDATA[java与c++之间有一堵由内存动态分配和垃圾回收技术所围成的‘墙’，墙外面的人想进来，墙里面的人却想出来。java虽然不容易出现内存泄露和内存溢出的问题，但是一旦出现问题，如果不了解jvm是如何使用内存的，排查问题就会显得尤为困难，以前也零零散散的看过一些文章，这次我打算深入系统的去学习一下jvm。 jvm内存模型根据java虚拟机规范，java虚拟机所管理的内存将会包括以下几个运行时数据区域： 程序计数器程序计数器也叫PC寄存器，它是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。java虚拟机的多线程工作是通过多线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个时刻，一个处理器（多核的指一个内核）都只会执行一条线程中的指令。因此，每个线程都有自己的程序计数器（线程私有）。如果线程正在执行java方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果执行的是native方法，这个计数器则为空。这快内存区域是java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 java虚拟机栈java虚拟机栈也是线程私有的，他的生命周期和线程一样。每个方法之行时都会创建一个栈帧（Stack Frame）用于存放局部变量表、操作数栈、动态链接、方法出口等信息。在java虚拟机规范中，对这个区域定义了两种异常状态：如果线程请求的栈的深度大于虚拟机所允许的深度，抛出StackOverflowError异常；虚拟机栈动态扩展时（虚拟机规范中也允许固定长度的虚拟机栈）无法申请到足够的内存也会抛出OutOfMemoryError。 本地方法栈本地方法栈和java虚拟机栈的作用非常相似，他们之间的区别就是java虚拟机栈的为java方法服务的，本地方法栈是为native方法服务。 java堆java堆是所有线程共享的一块内存空间，一般来说它是java虚拟机管理的最大的一块内存。这快内存的唯一目的就是存放对象实例的，但是随着JIT编译技术的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会使得在堆上分配变得不是那么绝对了。 方法区方法区与java堆一样，也是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它也有一个别名叫做Non-Heap（非堆）。在HotSpot虚拟机上，很多人都把方法区称为‘永久代’，其实两者本质上并不相同，仅仅是HotSpot虚拟机的设计团队把GC分代回收扩展到方法区而已。但是用永久代来实现方法区并不是一个非常好的主意，因为这样更容易产生内存溢出的问题，因此HotSpot虚拟机从JDK7开始已经慢慢放弃永久代并逐渐改为采用本地内存，直到JDK8为止，已经完全摒弃了永久代，取而代之的是一个叫Metaspace（元空间） 的东西。下面我们就来看看 Metaspace 与 PermGen space 的区别。 运行时常量池（Runtime Constant Pool）是方法区的一部分（JDK7以后已经放在堆中），Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入的运行时常量池中。 元空间（Metaspace）元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小： -XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。 -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。 除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性： -XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集。 -XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集。在jdk8中JVM参数PermSize 和 MaxPermSize会被忽略，并且在启动时会有警告信息。 元空间的特点： 充分利用了Java语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。 每个加载器有专门的存储空间 只进行线性分配 不会单独回收某个类 省掉了GC扫描及压缩的时间 元空间里的对象的位置是固定的 如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉 元空间的内存分配模型 绝大多数的类元数据的空间都从本地内存中分配 用来描述类元数据的类也被删除了 为元数据分配了多个虚拟内存空间 给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型; sun/反射/代理对应的类加载器的块会小一些 归还内存块，释放内存块列表 一旦元空间的数据被清空了，虚拟内存的空间会被回收掉 减少碎片的策略 总结1.字符串存在永久代中，容易出现性能问题和内存溢出。2.在JDK8中完全移除了永久代。3.元空间的大小最好还是设置并监控一下，不然出现内存泄露的情况会无限制的消耗本机内存。 参考《深入理解java虚拟机》]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlalchemy使用总结]]></title>
    <url>%2F2018%2F01%2F19%2Fpython%2Fsqlalchemy%2F</url>
    <content type="text"><![CDATA[最近工作中需要用python脚本维护数据库的历史数据，所以找到了sqlalchemy，它是一款python的orm框架，在这里总结一下使用方法。官网 安装12345pip install SQLAlchemy&gt;&gt;&gt; import sqlalchemy&gt;&gt;&gt; sqlalchemy.__version__&apos;1.2.0&apos;&gt;&gt;&gt; 引入并查看版本没有问题就代表安装成功了，接下来就可以正式使用了。连接mysql数据库，需要用到mysql连接驱动，我用的是MySQLdb，同学们可以自行安装一下。 连接下面进入正题：123456789101112131415from sqlalchemy.orm import sessionmakerfrom sqlalchemy import create_engine# 通过数据库连接url创建数据库引擎# mysql+mysqldb代表的连接mysql的驱动 **user**代表的是登陆数据库的账号，**pwd**代表登陆数据库密码，localhost代表连接数据库的ip：端口号，然后是数据库name，设置编码# 如果想回显SQLAlchemy操作数据库的日志，设置echo=True# Engine实例只有直到触发数据库事件时才真正去连接数据库engine = create_engine("mysql+mysqldb://user:pwd@localhost:3306/\dbname?charset=utf8", echo=True)# 通过绑定数据库引擎获取数据库会话类DBSession = sessionmaker(bind=engine)# 获取数据库会话session = DBSession() 个人理解session就是一个数据库连接。上面的方式是通过数据库连接池进行连接的，如果不想使用数据库连接池的话在创建engine对象时也可以使用poolclass=NullPool参数进行创建。 映射在数据库中定义一个数据表对应在Python代码中则是定义一个类（也就是通常所说的Model），要维持从类到表的关系，首先就要先声明一个映射。declarative_base类维持了一个从类到表的关系，通常一个应用使用一个base实例，所有实体类都应该继承此类对象123456789101112from sqlalchemy import Column, String, Integer, BIGINTfrom sqlalchemy.ext.declarative import declarative_baseBase = declarative_base()class Student(Base): # 表的名字: __tablename__ = 'student' # 表的结构: id = Column("id", BIGINT, primary_key=True) name = Column(String(30), nullable=False) age = Column(Integer) 这里需要注意的是：declarative_base()生成的类，该类的子类一般都必须与数据库中的一张表对应。 创建及删除表上面的Student类和student表之间只是创建了一个映射，数据库中并没有该表，需要创建该表需要执行下面的语句。123456# 创建所有定义的数据表，会在数据库中执行`CREATE TABLE ...`语句# 已经存在的数据表不会做操作Base.metadata.create_all(engine)# 删除所有定义的数据表Base.metadata.drop_all(engine) 数据状态以ORM方式来对数据库中的数据做增删查改操作是通过Session实例来完成的，在学习了解如何以ORM方式操作数据之前首先我们要对数据的状态有个基本的了解。首先在ORM中，数据库中的数据表对应于Python中的类，而数据表中的记录对应于类的实例对象。因此，对数据表中的记录进行增删查改在Python中实际上就是对实例对象的操作。数据实例对象有四种状态，分别是1.Transient - （瞬时的） 表示该实例对象不在session中，当然也没有保存到数据库中，主键一般情况下为None（如果一个Persistent状态的对象进行事务回滚后虽然主键有值，但却是Transient状态）。 2.Pending - （挂起的） 调用session.add()后，Transient状态的对象就会变成Pending状态的对象，这个时候它只是在session中，并没有保存到数据库，因此主键依旧为None。只有触发了session.flush()操作才会保存到数据库使得主键有值，比如查询操作就会触发flush。 3.Persistent - （持久的） session和数据库中都有对应的记录存在，为持久状态。 4.Detached - （游离的） 数据库中可能有记录，但是session中不存在。对这种对象的操作不会触发任何SQL语句。 对于数据状态的解释请看官方文档 操作上面介绍完了一些基本情况下面来看一下真正的对数据的操作。 增加12student = Student('小菜鸟', 25)session.add(student) 执行完add方法后，student对象处于pending状态，不会触发INSERT语句，当然student.id也为None，如果在add方后有查询(session.query)，那么会flush一下，把数据刷一遍，把所有的pending信息先flush再执行query。可以调用session.commit()方法进行flush.可以调用session.add_all([data1, data2])进行批量添加。 查询SQLAlchemy的查询非常灵活,query接收类或属性参数，以及多个类12345for instance in session.query(Student).order_by(Student.name): print instance.namefor name in session.query(Student.name): print name 上面的两种方式都可以进行查询，当然查询肯定不限于这么简单的查询，下面讲解复杂查询是如何操作的。常用的过滤查询：1.equals1query.filter(Student.age == 12) 2.not equal1234 query.filter(Student.age != 12)3.LIKE```python query.filter(Student.name.like('%菜%') 4.IN:1query.filter(Student.name.in_(['f','s','d']) 5.NOT IN:1query.filter(~Student.name.in_(['ed','x']) 6.IS NULL:1filter(Student.name==None) 7.IS NOT NULL:1filter(Student.name!=None) 8.AND12from sqlalchemy import and_filter(and_(Student.name == '小菜鸟',Student.age==25)) 或者多次调用filter或filter_by1filter(Student.name =='小菜鸟').filter(Student.age==25) 还可以是：1query.filter(Student.name =='小菜鸟', Student.age==25) 9.OR12from sqlalchemy import or_query.filter(or_(Student.name =='小菜鸟', Student.age==25)) filter函数还可以接收text对象，text是SQL查询语句的字面对象，比如：1session.query(Student).filter(text("age&lt;22")).order_by(text("id")).all() 下面在看一下对返回值的操作：1.all() 返回查询到的所有的结果。这个方法比较危险的地方是，如果数据量大且没有使用limit子句限制的话，所有的结果都会加载到内存中。它返回的是一个列表，如果查询不到任何结果，返回的是空列表。 2.first() 返回查询到的第一个结果，如果没有查询到结果，返回None。 3.scalar() 这个方法与.one_or_none()的效果一样。如果查询到很多结果，抛出sqlalchemy.orm.exc.MultipleResultsFound异常。如果只有一个结果，返回它，没有结果返回None。 4.one() 如果只能查询到一个结果，返回他，否则抛出异常。没有结果时抛sqlalchemy.orm.exc.NoResultFound，有超过一个结果时抛sqlalchemy.orm.exc.MultipleResultsFound。 5.one_or_none() 比起.one()来，区别只是查询不到任何结果时不再抛出异常而是返回None。 6.get() 这是个比较特殊的方法。它用于根据主键来返回查询结果，因此它有个参数就是要查询的对象的主键。如果没有该主键的结果返回None，否则返回这个结果。 countcount有两种，一是统计查询了多少条结果：1session.query(Student).filter(Student.name =='小菜鸟').count() 第二种是做分组操作时返回的数量：1session.query(func.count(), Student.name).group_by(Student.name).all() 删除查询先讲到这里，下面看看删除操作1session.query(Student).filter(Student.age == 25).delete() 修改替换一个已有主键的记录：123student = Student(id=1, name='ooxx')session.merge(student)session.commit() 也可以像delete方法一样进行查询并更新。 以上就是我对这次使用的总结，如果有不正确的地方欢迎指正。该篇博文主要参考SQLAlchemy 学习笔记]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>orm</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Reverse Linked List]]></title>
    <url>%2F2018%2F01%2F15%2FleetCode%2FreverseLinkedList%2F</url>
    <content type="text"><![CDATA[原题：Reverse a singly linked list. 题目大意反转单链表 解题思路比较简单的一道题，每次把头结点的下一个结点换到第一位。代码实现（java）：12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode n = head; while (head.next != null)&#123; ListNode h = head.next; head.next = h.next; h.next = n; n = h; &#125; return n; &#125;&#125; python实现：123456789101112131415161718192021# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ if head is None or head.next is None: return head n = head while head.next is not None: h = head.next head.next = h.next h.next = n n = h return n]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CountDownLatch的使用及分析（jdk1.8）]]></title>
    <url>%2F2018%2F01%2F02%2Fjava%2FcountDownLatch%2F</url>
    <content type="text"><![CDATA[建议参考CyclicBarrie一起阅读.java.util.concurrent.CountDownLatch是在jdk1.5中开始提供的，主要实现了一个类似计数器的功能。比如当前有一个或多个任务 需要其他几个任务都结束后才能运行，这时候CountDownLatch就派上用场了。其实这种场景利用 wait notify也是可以实现的，只不过实现起来比较复杂，没有CountDownLatch这么简单，下面先看一个例子，再继续分析。 实例1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args) &#123; CountDownLatch countDownLatch = new CountDownLatch(2); new Thread(() -&gt; &#123; try &#123; System.out.println("线程" + Thread.currentThread().getName() + "运行开始"); Thread.sleep(3000); System.out.println("线程" + Thread.currentThread().getName() + "运行完毕"); countDownLatch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); new Thread(() -&gt; &#123; try &#123; System.out.println("线程" + Thread.currentThread().getName() + "运行开始"); Thread.sleep(3000); System.out.println("线程" + Thread.currentThread().getName() + "运行完毕"); countDownLatch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); try &#123; System.out.println("等待2个线程执行完毕..."); countDownLatch.await(); System.out.println("2个线程已经执行完毕"); System.out.println("继续执行主线程"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; 输出：1234567线程Thread-0运行开始线程Thread-1运行开始等待2个线程执行完毕...线程Thread-0运行完毕线程Thread-1运行完毕2个线程已经执行完毕继续执行主线程 从上面的例子可以看出主线程等待线程Thread-0和线程Thread-1执行完成后开始继续执行。 源码分析 可以看出CountDownLatch的方法列表中的方法比较少，主要方法await和countDown。 构造函数12345678910public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count); &#125; Sync(int count) &#123; setState(count); &#125; private volatile int state; CountDownLatch只提供了这一个构造方法，内部是由Sync继承同步器AbstractQueuedSynchronizer实现的，主要是将计数值传递给AbstractQueuedSynchronizer的同步状态的属性state。 await()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//使当前线程等待，直到计数器值为0，除非线程被中断了。public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; //检测是否中断，中断则抛出异常 if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg); &#125;//获取同步器AbstractQueuedSynchronizer的state，判断是否为0 protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; //采用公平锁，为当前线程创建节点并排队 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; //循环等待共享锁的释放 for (;;) &#123; //获取node的前驱结点 final Node p = node.predecessor(); //如果前驱结点是头结点 if (p == head) &#123; //在共享模式下获取同步状态 int r = tryAcquireShared(arg); //state已经为0了，需要执行的线程都已经完毕了 if (r &gt;= 0) &#123; //将当前结点设置为头结点 setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; //检查并更新未能获取的节点的状态。如果线程阻塞，则返回true。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125;//执行到此处时，线程会阻塞，直到有其他线程唤醒此线程，执行await()之后，例子中的主线程阻塞在这。 private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted(); &#125; countDown()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//countDown操作实际上就是减少计数器值的过程，调用一次减1直到值为0public void countDown() &#123; sync.releaseShared(1); &#125;// public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false; &#125;//死循环加上CAS的方式保证state的减1操作，当计数值等于0，代表所有子线程都执行完毕，被await阻塞的线程可以唤醒了 protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0;//尝试唤醒等待的线程 &#125; &#125; private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; //头结点如果状态是SIGNAL，则置为0，并调用unparkSuccessor唤醒下个结点 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; //被唤醒的节点状态会置成0，在下一次循环中被设置成PROPAGATE状态。 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125; &#125;//真正的唤醒线程方法 private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; //处理当前节点：非CANCELLED状态重置为0； if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); //寻找下个节点：如果是CANCELLED状态，说明节点中途溜了，从队列尾开始寻找排在最前还在等着的节点 Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; //唤醒下个节点里的线程 if (s != null) LockSupport.unpark(s.thread); &#125; await方法还有个限定时间的方法，内部在循环的时候增加了对时间的判断，这里就不做分析了，可以自行查阅。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springAop中的动态代理（jdk和cglib）]]></title>
    <url>%2F2017%2F12%2F18%2Fdesignpatterns%2Fdynproxy%2F</url>
    <content type="text"><![CDATA[根据静态代理的介绍大家会发现，一个目标类对应着一个代理类，但是实际项目开发中，如果有多个目标类需要代理，那静态代理肯定不是理想中的解决方案，那么动态代理就是我们需要的。动态代理是JDK5引入的，在动态代理中，代理类并不是java代码实现的，而是运行期由JVM根据反射等机制动态的生成，和静态代理比，动态代理可以很好的对多个类进行统一处理，java中的动态代理分为jdk代理和cglib代理。 jdk动态代理java.lang.reflect.Proxy（类）和java.lang.reflect.InvocationHandler（接口）是jdk动态代理最核心的两个类，这里不会详细介绍这两个类，主要看一下相关方法。 Subject定义的目标类的接口1234public interface Subject &#123; public void eat();&#125; RealSubject要被代理的目标类1234567public class RealSubject implements Subject &#123; @Override public void eat() &#123; System.out.println("eat"); &#125;&#125; 敲黑板！！！此处是重点动态创建代理对象的类12345678910111213141516171819202122232425262728public class MyProxy implements InvocationHandler &#123; //目标对象 private Object object; //与具体的实现类绑定关系 public Object newProxyInstance(Object object)&#123; this.object = object; //获取生成代理对象的类加载器,负责将类的字节码装载到Java虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中。 每次生成动态代理类对象时都需要指定一个类加载器对象 ClassLoader loader = object.getClass().getClassLoader(); //获取当前类（即object）实现的接口列表 Class&lt;?&gt;[] interfaces = object.getClass().getInterfaces(); //根据传入的参数返回一个代理对象 return Proxy.newProxyInstance(loader, interfaces, this); &#125; //该方法负责集中处理动态代理类上的所有方法调用。第一个参数既代理类实例，第二个参数是被调用的方法对象,第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //原对象方法调用之前处理 System.out.println("before"); //目标方法执行 Object result = method.invoke(object, args); //原对象方法调用之后处理 System.out.println("after"); return result; &#125;&#125; 先看一下执行结果123beforeeatafter 分析动态代理的实现步骤123456789101112// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用InvocationHandler handler = new InvocationHandlerImpl(..);// 通过 Proxy 为包括 Interface 接口在内的一组接口动态创建代理类的类对象Class clazz = Proxy.getProxyClass(classLoader, new Class[] &#123; Interface.class, ... &#125;);// 通过反射从生成的类对象获得构造函数对象Constructor constructor = clazz.getConstructor(new Class[] &#123; InvocationHandler.class &#125;);// 通过构造函数对象创建动态代理类实例Interface Proxy = (Interface)constructor.newInstance(new Object[] &#123; handler &#125;); Proxy类的静态方法newProxyInstance对上面具体步骤的后三步做了封装，简化了动态代理对象的获取过程。 newProxyInstance方法123456// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发InvocationHandler handler = new InvocationHandlerImpl(..);// 通过 Proxy 直接创建动态代理类实例Interface proxy = (Interface)Proxy.newProxyInstance( classLoader, new Class[] &#123; Interface.class &#125;, handler ); 源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@CallerSensitive//为了避免双重反射的注解，就是堵漏洞的public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; //执行权限检查 checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. * 查找或生成指定的代理类 */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler.使用指定的调用处理程序调用其构造函数 */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; 获取代理类的方法getProxyClass0：12345678910private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; //检查实现的接口数，65535这个数字好特殊，端口数好像也是这个，这个数字是由虚拟机所决定的，2^16-1个 if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException("interface limit exceeded"); &#125; //如果由给定的加载器实现给定的接口定义的代理类存在，这将简单地返回缓存的副本;否则，它将通过ProxyClassFactory创建代理类 return proxyClassCache.get(loader, interfaces); &#125; 继续跟着代码可以看到真正实现代理类的是私有类ProxyClassFactory123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; //所有代理类名称的前缀 private static final String proxyClassNamePrefix = "$Proxy"; //用于生成唯一代理类名称的下一个数字 private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; //验证类加载器是否将此接口的名称解析为同一个Class对象。 Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + " is not visible from class loader"); &#125; //验证Class对象实际上代表一个接口。 if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + " is not an interface"); &#125; //验证这个接口不是重复的。 if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( "repeated interface: " + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; //记录一个非公开代理接口的包，以便在同一个包中定义代理类。验证所有非公开的代理接口是否在同一个包中。 for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? "" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( "non-public interfaces from different packages"); &#125; &#125; &#125; if (proxyPkg == null) &#123; //如果没有非公开的代理接口，请使用com.sun.proxy包 proxyPkg = ReflectUtil.PROXY_PACKAGE + "."; &#125; //为要生成的代理类选择一个名称。 long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; //生成指定的代理类。 byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125; &#125; JDK中动态代理，实现的步骤为：1.创建代理类的源码；2.对源码进行编译成字节码；3.将字节码加载到内存；4.实例化代理类对象并返回给调用者； 反编译生成的代理类,可以看出是继承Proxy类的，由于java是单继承的，所以jdk动态代理只能代理接口，不能代理抽象类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import designpatterns.dynproxy.Subject;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy1 extends Proxy implements Subject&#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; public $Proxy1(InvocationHandler paramInvocationHandler) &#123; super(paramInvocationHandler); &#125; public final boolean equals(Object paramObject) &#123; try &#123; return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void eat() &#123; try &#123; this.h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() &#123; try &#123; return ((Integer)this.h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] &#123; Class.forName("java.lang.Object") &#125;); m3 = Class.forName("designpatterns.dynproxy.Subject").getMethod("eat", new Class[0]); m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]); m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 总结优点：动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使我们的类职责更加单一，复用性更强。缺点：诚然，Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。 cglib代理上面说jdk动态代理通过反射类Proxy和InvocationHandler回调接口实现，要求委托类必须实现一个接口，只能对该类接口中定义的方法实现代理，这在实际编程中有一定的局限性。cglib代理并不要求委托类必须实现接口，是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。 实例委托类123456public class RealSubject &#123; public void eat() &#123; System.out.println("eat"); &#125;&#125; 生成代理类12345678910111213141516171819202122232425public class MyMethodInterceptor&#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class&lt;?&gt; clazz)&#123; enhancer.setSuperclass(clazz); enhancer.setCallback(new MethodInterceptor()&#123; /** * 拦截所有目标类方法的调用 * * o目标实例对象 * method 目标方法的反射对象 * objects方法的参数 * methodProxy代理类的实例 */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("Before:" + method); Object object = methodProxy.invokeSuper(o, objects); System.out.println("After:" + method); return object; &#125; &#125;); return enhancer.create(); &#125;&#125; 测试类12345678public class Test &#123; public static void main(String[] args) &#123; MyMethodInterceptor myMethodInterceptor = new MyMethodInterceptor(); RealSubject realSubject = (RealSubject) myMethodInterceptor.getProxy(RealSubject.class); realSubject.eat(); &#125;&#125; 结果123Before:public void designpatterns.cglibproxy.RealSubject.eat()eatAfter:public void designpatterns.cglibproxy.RealSubject.eat() 代理对象的生成过程由Enhancer类实现，大概步骤如下：1、生成代理类Class的二进制字节码；2、通过Class.forName加载二进制字节码，生成Class对象；3、通过反射机制获取实例构造，并初始化代理类对象。 Enhancer类，Enhancer是CGLib的字节码增强器，可以方便的对类进行扩展，内部调用GeneratorStrategy.generate方法生成代理类的字节码。该Enhancer动态创建一个给定类型的子类，拦截所有的方法调用。除了Proxy类之外，这对于类和接口类型都适用。 有兴趣的同学可以自行反编译生成的代理类进行分析。这里就不做具体介绍了。 jdk和cglib动态代理实现的区别1.jdk动态代理生成的代理类和委托类实现了相同的接口；2.cglib动态代理中生成的字节码更加复杂，生成的代理类是委托类的子类，且不能处理被final关键字修饰的方法；3.jdk采用反射机制调用委托类的方法，cglib采用类似索引的方式直接调用委托类方法； 由于本人知识有限，如有错误欢迎指正。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－－代理模式(Proxy)]]></title>
    <url>%2F2017%2F12%2F13%2Fdesignpatterns%2Fproxy%2F</url>
    <content type="text"><![CDATA[今天有朋友问我动态代理用在什么场景下，这里先回顾下静态代理，后续会讲解java中动态代理。 定义代理模式：为其他对象提供一种代理以控制对这个对象的访问。 结构图 实例Subject接口，定义了RealSubject和Proxy的公用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。123456public interface Subject &#123; public void eat(); public void sleep();&#125; RealSubject类，定义Proxy所代表的真实实体。123456789101112public class RealSubject implements Subject &#123; @Override public void eat() &#123; System.out.println("eat"); &#125; @Override public void sleep() &#123; System.out.println("sleep"); &#125;&#125; Proxy类，保存一个引用使得代理类可以访问实体。12345678910111213141516171819202122public class Proxy implements Subject &#123; private Subject subject; public Proxy(Subject subject)&#123; this.subject = subject; &#125; @Override public void eat() &#123; System.out.println("eat before"); subject.eat(); System.out.println("eat after"); &#125; @Override public void sleep() &#123; System.out.println("sleep before"); subject.sleep(); System.out.println("sleep after"); &#125;&#125; 测试类1234567public class Test &#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(new RealSubject()); proxy.eat(); proxy.sleep(); &#125;&#125; 输出123456eat beforeeateat aftersleep beforesleepsleep after 应用1.远程代理：就是为一个对象在不同的地址空间提供局部代理。这样可以隐藏一个对象存在于不同地址空间的事实。2.虚拟代理：根据需要创建很大开销的对象，通过它来存放实例化需要很长时间的真实对象。3.安全代理：用来控制真是对象访问时的权限。4.智能指引：指当调用真实的对象时，代理处理另外一些事。 总结优点：可以在不修改目标类的前提下,对目标类功能扩展。缺点：代理类需要与目标类实现同一个接口，所以会有很多代理类，类太多。并且，一旦接口增加方法，目标类与代理类都要维护，增加了维护成本。 并且静态代理一定是要目标类存在的前提下，但是实际项目中编译之前有可能并不知道要代理哪个类，这就需要由动态代理来解决了。下篇博文会详细的介绍java中的动态代理。 参考《大话设计模式》 本文为博主原创文章，如需转载请注明出处。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Delete Node in a Linked List]]></title>
    <url>%2F2017%2F12%2F12%2FleetCode%2FdeleteNodeinaLinkedList%2F</url>
    <content type="text"><![CDATA[原题：Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. 题目大意给一个链表，并且给一个当前结点，要求删除当前结点。 解题思路因为不知道当前结点的前一个结点，所以可以把下一个结点copy到当前结点，删除下一个结点。代码实现（java）：1234567891011121314/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125; python实现：1234567891011121314# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteNode(self, node): """ :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. """ node.val = node.next.val node.next = node.next.next]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--First Unique Character in a String]]></title>
    <url>%2F2017%2F12%2F12%2FleetCode%2FfirstUniqueCharacterinaString%2F</url>
    <content type="text"><![CDATA[原题：Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. Example1 s = “leetcode”return 0. s = “loveleetcode”,return 2. Note You may assume the string contain only lowercase letters. 题目大意找出给定字符串的第一个出现的唯一的字符。 解题思路全是小写字母，可以定义长度26的数组，然后遍历字符串，看每个值的下标再数组的位置，出现一次加一，在遍历字符串，根据数组中的值，找出第一个出现的唯一值。代码实现（java）：123456789101112131415class Solution &#123; public int firstUniqChar(String s) &#123; int[] cas = new int[26]; for (int i = 0; i &lt; s.length(); i++)&#123; cas[s.charAt(i) - 'a']++; &#125; for (int i = 0; i &lt; s.length(); i++)&#123; if (1 == cas[s.charAt(i) - 'a']) return i; &#125; return -1; &#125;&#125; python实现：1234567891011121314151617class Solution(object): def firstUniqChar(self, s): """ :type s: str :rtype: int """ cas = set() if s == '': return -1 for item in s: if item not in cas: if s.count(item) == 1: return s.index(item) else: cas.add(item) return -1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Sum of Left Leaves]]></title>
    <url>%2F2017%2F12%2F11%2FleetCode%2FsumofLeftLeaves%2F</url>
    <content type="text"><![CDATA[原题：Find the sum of all left leaves in a given binary tree. Example1 3 / \ 9 20 / \ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 题目大意查找给定二叉树中所有左叶的总和 解题思路遍历二叉树。找出左叶子。代码实现（java）：1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; if (root == null) return 0; int res = 0; if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) &#123; res += root.left.val; &#125; else &#123; res += sumOfLeftLeaves(root.left); &#125; res += sumOfLeftLeaves(root.right); return res; &#125;&#125; python实现：12345678910111213141516171819# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sumOfLeftLeaves(self, root): """ :type root: TreeNode :rtype: int """ res = 0 if root: if root.left and (root.left.left or root.left.right) is None: res += root.left.val res += self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Majority Element]]></title>
    <url>%2F2017%2F12%2F11%2FleetCode%2FmajorityElement%2F</url>
    <content type="text"><![CDATA[原题：Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 题目大意给定size为n的数组，查找出主元素，就是出现次数大于n/2次的元素。你可以假定数组非空，而且主元素一定存在。 解题思路因为主元素出现次数大于n/2次，所以可以利用相消法，定义count记录当前元素的数量，遍历时遇到他自己就加1，不是自己就减1，count为0时就换元素。代码实现（java）：123456789101112131415161718class Solution &#123; public int majorityElement(int[] nums) &#123; int element = 0; int count = 0; for (int i = 0; i &lt; nums.length; i++)&#123; if (count == 0)&#123; element = nums[i]; count = 1; &#125; else &#123; if (element == nums[i]) count++; else count--; &#125; &#125; return element; &#125;&#125; python实现：123456789101112131415161718class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ count = 1 element = nums[0] for i in range(1, len(nums)): if count == 0: element = nums[i] count += 1 else: if nums[i] == element: count += 1 else: count -= 1 return element]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Convert BST to Greater Tree]]></title>
    <url>%2F2017%2F12%2F06%2FleetCode%2FconvertBSTtoGreaterTree%2F</url>
    <content type="text"><![CDATA[原题：Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example1 Input: The root of a Binary Search Tree like this: 5 / \ 2 13 Output: The root of a Greater Tree like this: 18 / \ 20 13 题目大意给定一个二叉搜索树（BST），将其转换为一个大树，使得原始BST的每个键被改变为原始键加上所有比BST中的原始键大的键的总和。 解题思路最开始的想法是中序遍历转成数组，然后依次累加，后来看到一种思路可以直接右根左遍历，然后累加。代码实现（java）：1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int sum = 0; public TreeNode convertBST(TreeNode root) &#123; convert(root); return root; &#125; public void convert(TreeNode node) &#123; if (node == null) return; convert(node.right); node.val += sum; sum = node.val; convert(node.left); &#125;&#125; python实现：1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): sum = 0 def convertBST(self, root): """ :type root: TreeNode :rtype: TreeNode """ self.sum = 0 def convert(root): if not root: return convert(root.right) root.val += self.sum self.sum = root.val convert(root.left) convert(root) return root]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Construct String from Binary Tree]]></title>
    <url>%2F2017%2F12%2F06%2FleetCode%2FconstructStringfromBinaryTree%2F</url>
    <content type="text"><![CDATA[原题：You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree. Example1 Input: Binary tree: [1,2,3,4] 1 / \ 2 3 / 4 Output: “1(2(4))(3)” Explanation: Originallay it needs to be “1(2(4)())(3()())”,but you need to omit all the unnecessary empty parenthesis pairs.And it will be “1(2(4))(3)”. Example2 Input: Binary tree: [1,2,3,null,4] 1 / \ 2 3 \ 4 Output: “1(2()(4))(3)” Explanation: Almost the same as the first example,except we can’t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. 题目大意将二叉树序列化为字符串，形式为”root(left)(right)”，空节点表示为”()”。所有不产生歧义的空括号可以省去。 解题思路先序遍历的变种，按照先序遍历的方法做一些调整。代码实现（java）：123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public String tree2str(TreeNode t) &#123; if(t == null) return ""; StringBuilder sb = new StringBuilder(); sb.append(t.val); if(t.left != null &amp;&amp; t.right == null) sb.append("(").append(tree2str(t.left)).append(")"); else if(t.right != null) sb.append("(").append(tree2str(t.left)).append(")") .append("(").append(tree2str(t.right)).append(")"); return sb.toString(); &#125;&#125; python实现：123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def tree2str(self, t): """ :type t: TreeNode :rtype: str """ if not t: return "" res = str(t.val) if t.left or t.right: res += '(' + self.tree2str(t.left) + ')' if t.right: res += '(' + self.tree2str(t.right) + ')' return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Count Binary Substrings]]></title>
    <url>%2F2017%2F12%2F05%2FleetCode%2FcountBinarySubstrings%2F</url>
    <content type="text"><![CDATA[原题：Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0’s and 1’s, and all the 0’s and all the 1’s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur. Example1 Input: “00110011”Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1’s and 0’s: “0011”, “01”, “1100”, “10”, “0011”, and “01”. Notice that some of these substrings repeat and are counted the number of times they occur. Also, “00110011” is not a valid substring because all the 0’s (and 1’s) are not grouped together. Example2 Input: “10101”Output: 4Explanation: There are 4 substrings: “10”, “01”, “10”, “01” that have equal number of consecutive 1’s and 0’s. Note s.length will be between 1 and 50,000. s will only consist of “0” or “1” characters. 题目大意给一个字符串s，计算具有相同数字0和1的非空（连续）子字符串的数量，并且这些子字符串中的全部0和全部1被连续分组。子串发生多次被计数的次数。 解题思路纪录当前的0或者1的数量，然后和后面的1或者0的数量进行对比。代码实现（java）：1234567891011121314151617181920212223242526 class Solution &#123; public int countBinarySubstrings(String s) &#123; int zeros = 0; int ones = 0; int res = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (i == 0) &#123; if (s.charAt(i) == '1') ones++; else zeros++; &#125; else &#123; if (s.charAt(i) == '1') &#123; ones = (s.charAt(i - 1) == '1') ? ones + 1 : 1; if (zeros &gt;= ones) res++; &#125; else if (s.charAt(i) == '0') &#123; zeros = (s.charAt(i - 1) == '0') ? zeros + 1 : 1; if (ones &gt;= zeros) res++; &#125; &#125; &#125; return res; &#125;&#125; python实现：1234567891011121314151617181920212223class Solution(object): def countBinarySubstrings(self, s): """ :type s: str :rtype: int """ ones = zeros = res = 0 for i in range(len(s)): if i == 0: if s[i] == '1': ones += 1 else: zeros += 1 else: if s[i] == '1': ones = ones + 1 if s[i - 1] == '1' else 1 if zeros &gt;= ones: res += 1 else: zeros = zeros + 1 if s[i - 1] == '0' else 1 if ones &gt;= zeros: res += 1 return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－－策略模式(Strategy)]]></title>
    <url>%2F2017%2F12%2F05%2Fdesignpatterns%2Fstrategy%2F</url>
    <content type="text"><![CDATA[定义在《大话设计模式》一书中，程杰老师是这样描述策略模式的： 策略模式（Strategy）：它定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。 结构下面是策略模式的结构图： 实例该书中举了一个很形象的收银系统，打折和满减。面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。打一折和打九折只是形式不同，抽象分析出来，所有的打折算法都是一样的，所以打折算法应该是一个类；满减算法应该是一个类。 策略模式代码实现定义了一个收银的接口Cash，三种收银策略CashNormal（正常）、CashRebate（打折）、CashReturn（满减）；还有使用某种具体策略的类Context。 策略接口（收银接口）：123456package designpatterns.strategy;public interface Cash &#123; double acceptCash(double money);&#125; 三种策略实现类：正常收费123456789package designpatterns.strategy;public class CashNormal implements Cash &#123; @Override public double acceptCash(double money) &#123; return money; &#125;&#125; 打折123456789101112131415package designpatterns.strategy;public class CashRebate implements Cash &#123; private double moneyRebate = 1; public CashRebate(double moneyRebate)&#123; this.moneyRebate = moneyRebate; &#125; @Override public double acceptCash(double money) &#123; return money * moneyRebate; &#125;&#125; 满减12345678910111213141516171819202122package designpatterns.strategy;public class CashReturn implements Cash &#123; //返利条件 private double moneyCondition = 0; //返利的值 private double moneyReturn = 0; public CashReturn(double moneyCondition, double moneyReturn)&#123; this.moneyCondition = moneyCondition; this.moneyReturn = moneyReturn; &#125; @Override public double acceptCash(double money) &#123; if (money &gt;= moneyCondition) return money - Math.floor(money / moneyCondition) * moneyReturn; return money; &#125;&#125; 使用具体策略的类1234567891011121314package designpatterns.strategy;public class Context &#123; private Cash cash; public Context(Cash cash)&#123; this.cash = cash; &#125; public double result(double money)&#123; return cash.acceptCash(money); &#125;&#125; 测试类1234567891011121314151617package designpatterns.strategy;public class StrategyTest &#123; public static void main(String[] args) &#123; Context context; context = new Context(new CashNormal()); System.out.println("正常收费： " + context.result(100)); context = new Context(new CashRebate(0.8)); System.out.println("打八折收费： " + context.result(100)); context = new Context(new CashReturn(100, 30)); System.out.println("满100减30: " + context.result(100)); &#125;&#125; 结果123正常收费： 100.0打八折收费： 80.0满100减30: 70.0 解析策略模式是一种定义一系列算法的方法，从概念上讲，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。 优点1.通过共同实现的接口，可以把公用功能抽取出来2.简化单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。3.消除类中的条件判断语句。4.扩展性良好。 缺点1.选择具体实现的职责由客户端对象承担，并转给策略模式的Context对象，并没有解除客户端的选择判断的压力。2.新增策略就要新增策略类。 总结策略模式时用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种可能发生的变化。 但是在策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式使用对象，这本身并没有解除客户端需要选择判断的压力，解决这一问题的方法是使用策略模式和工厂模式结合，选择具体实现的职责也由策略使用类Context来承担。这就最大化的减轻了客户端的职责。 这里就不给出实现代码了，有兴趣的同学可以自行实现。 参考《大话设计模式》 本文为博主原创文章，如需转载请注明出处。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Max Area of Island]]></title>
    <url>%2F2017%2F11%2F27%2FleetCode%2FmaxAreaofIsland%2F</url>
    <content type="text"><![CDATA[Max Area of Island原题：Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example1 [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally. Example2 [[0,0,0,0,0,0,0,0]] Given the above grid, return 0. Note The length of each dimension in the given grid does not exceed 50. 题目大意给定二维数组，相邻的1为陆地 只能上下左右算相邻，对角不算，求最大面积。 解题思路两层循环，依次判断四个方向上的值。代码实现（java）：123456789101112131415161718192021222324 class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; int res = 0; for(int i = 0; i &lt; grid.length; i++)&#123; for(int j = 0; j &lt; grid[0].length; j++)&#123; if(grid[i][j] == 1) res = Math.max(res, find(grid, i, j)); &#125; &#125; return res; &#125; private int find(int [][] grid, int i, int j)&#123; if(i &lt; 0 || i &gt;= grid.length || j &lt; 0 || j &gt;= grid[0].length) return 0; int res = 0; if(grid[i][j] == 1)&#123; grid[i][j] = 0; res = 1 + find(grid, i - 1, j) + find(grid, i + 1, j) + find(grid, i, j - 1) + find(grid, i, j + 1); &#125; return res; &#125;&#125; python实现：123456789101112131415161718192021class Solution(object): def maxAreaOfIsland(self, grid): """ :type grid: List[List[int]] :rtype: int """ res = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j]: res = max(res, self.find(grid, i, j)) return res def find(self, grid, i, j): if i &lt; 0 or i &gt;= len(grid) or j &lt; 0 or j &gt;= len(grid[0]): return 0 res = 0 if grid[i][j] == 1: grid[i][j] = 0 res = 1 + self.find(grid, i - 1, j) + self.find(grid, i + 1, j) + self.find(grid, i, j - 1) + self.find(grid, i, j + 1) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Self Dividing Numbers]]></title>
    <url>%2F2017%2F11%2F27%2FleetCode%2FselfDividingNumbers%2F</url>
    <content type="text"><![CDATA[Self Dividing Numbers原题：A self-dividing number is a number that is divisible by every digit it contains. For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. Also, a self-dividing number is not allowed to contain the digit zero. Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible. Example1 Input:left = 1, right = 22Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] Note The boundaries of each input argument are 1 &lt;= left &lt;= right &lt;= 10000. 题目大意给定区间，找到区间内特定的数字。特定的数字：比如128，能同时被它的个位，十位，百位整除，这就是自分数。 解题思路暴力做法，判断区间中的每一个数，检查是否符合规范。代码实现（java）：123456789101112131415161718192021222324252627class Solution &#123; public List&lt;Integer&gt; selfDividingNumbers(int left, int right) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(left &gt; right ) return list; for(int i= left ; i &lt;= right ; i++)&#123; if(isvalid(i)) list.add(i); &#125; return list; &#125; public static boolean isvalid(int num)&#123; int n = num; while (num != 0) &#123; int c = num % 10; if (c == 0) return false; else &#123; if (n % c != 0) return false; &#125; num /= 10; &#125; return true; &#125;&#125; python实现：1234567891011121314151617181920class Solution(object): def selfDividingNumbers(self, left, right): """ :type left: int :type right: int :rtype: List[int] """ res = [] for i in range(left, right+1): n = i count = 1 while i: num = i % 10 if not num or n % num != 0: count = 0 break i /= 10 if count: res.append(n) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two Sum IV - Input is a BST]]></title>
    <url>%2F2017%2F11%2F26%2FleetCode%2FtwoSumIV%2F</url>
    <content type="text"><![CDATA[Two Sum IV - Input is a BST原题：Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example1 Input: 5 / \ 3 6 / \ \2 4 7Target = 9Output: True Example2 Input: 5 / \ 3 6 / \ \2 4 7Target = 28Output: False 题目大意给一个BSTTree,在给定一个值，判定树中的两个数的和是否能组成给定的值。 解题思路遍历树中的数据然后比较即可。代码实现（java）：12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean findTarget(TreeNode root, int k) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); inOrder(root, list); int i = 0; int j = list.size() - 1; while (i &lt; j)&#123; if (list.get(i) + list.get(j) == k) return true; else if (list.get(i) + list.get(j) &lt; k) i++; else j--; &#125; return false; &#125; private void inOrder(TreeNode root, List list) &#123; if (root != null)&#123; inOrder(root.left, list); list.add(root.val); inOrder(root.right, list); &#125; &#125;&#125; python实现：12345678910111213141516171819202122232425262728293031# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def findTarget(self, root, k): """ :type root: TreeNode :type k: int :rtype: bool """ if root is None: return False s = set() queue = [root] while(queue): treeNode = queue.pop(0) s.add(treeNode.val) if(treeNode.left): queue.append(treeNode.left) if(treeNode.right): queue.append(treeNode.right) for n in s: if (k - n) in s and 2 * (k - n) != k: return True return False]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树－－java实现]]></title>
    <url>%2F2017%2F11%2F25%2Falgorithm%2FrbTree%2F</url>
    <content type="text"><![CDATA[前面介绍了二叉搜索树，它可以支持任何一种基本动态集合的操作，其时间复杂度O(n)。因此，如果搜索树的高度较低时，这些集合操作执行的会较快。然而如果树的高度较高时，这些操纵可能并不比在链表上执行得快。红黑树是许多平衡搜索树的一种，可以保证在最坏的情况下基本动态集合操作的时间复杂度为O(lgn)。 红黑树性质红黑树是二叉搜索树，它在每个结点上增加了一个存储位来表示结点的颜色，可以是红色或者黑色。红黑树确保没有一条路径会比其他路径长出两倍，因而是近似于平衡的。一棵红黑树是满足下面红黑性质的二叉搜索树：1.每个结点或是红色的或是黑色的。2.根结点是黑色的。3.每个叶子结点（NIL）是黑色的。（这里的叶子结点为null或NIL）4.如果一个结点是红色的，则它的两个叶子结点都是黑色的。5.对每个结点，从该结点到其后代叶结点的简单路径上，均包含相同数目的黑色结点。 时间复杂度红黑树的时间复杂度为: O(lgn) 从某个结点x出发到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高。 一棵有n个内部结点的红黑树的高度至多为2lg(n+1) 旋转红黑树的基本操作有插入、删除运行时间为O(lgn)。由于这两个操作对树做了修改，可能违反红黑树的性质，为了维护这些性质，通过旋转改变树中的某些结点的颜色以及指针。旋转分为两种：左旋和右旋。如下图： 左旋的java代码实现如下（参考《算法导论》）：123456789101112131415private void rotateLeft(Node x)&#123; Node y = x.right; //设置y结点，为x结点的右结点 //旋转开始 x.right = y.left; //x的右结点设置为y的左结点 if (y.left != null) y.left.parent = x; //把y左结点的父结点指向x结点 y.parent = x.parent; //把y的父结点改为x的父结点 if (x.parent == null) this.root = y; //如果x的父结点为空。那么y就是root结点 else if (x == x.parent.left) //x为它父结点的左结点 x.parent.left = y; //把x的父结点的左结点改为y结点 else x.parent.right = y; //把x的父结点的右结点改为y y.left = x; //y结点的左结点为x x.parent = y; //x的父结点为y &#125; 下图是一个左旋修改红黑树的例子： 右旋的操作和左旋的代码是对称的，左旋和右旋的时间复杂度均为O(1)。旋转过程中只改变了指针，其他属性不变。 右旋的java代码实现：123456789101112131415private void rotateRight(Node y)&#123; Node&lt;K&gt; x = y.left; //设置x结点，为y结点的左结点 //旋转开始 y.left = x.right; //y的左结点设置为x的右结点 if (x.right != null) x.right.parent = y; //把x右结点的父结点指向y结点 x.parent = y.parent; //把x的父结点改为y的父结点 if (y.parent == null) this.root = x; //如果y的父结点为空。那么x就是root结点 else if (y == y.parent.left) //y为它父结点的左结点 y.parent.left = x; //把y的父结点的左结点改为x结点 else y.parent.right = x; //把y的父结点的右结点改为x结点 x.right = y; //x结点的右结点为y y.parent = x; //y的父结点为x &#125; 总结：1.在任何一棵有n的结点的红黑树中，有n-1种可能的旋转。2.对x进行左旋，意味着，将x的右孩子变为x的父亲节点；即将x变成了一个左节点(x成了为y的左孩子)。 因此，左旋中的左，意味着被旋转的节点将变成一个左节点。3.对y进行右旋，意味着，将y的左结点变为y的父亲结点；即将y变成了一个右节点(y成了为x的右孩子)。 因此，右旋中的右，意味着被旋转的节点将变成一个右节点。 插入我们可以在O(lgn)的时间内完成向一棵n个结点的红黑树中插入一个新的结点。为了做到这一点，利用二叉搜索树的insert过程的一个略作修改的版本将结点z插入到树中，为了保证红黑树的性质继续保持，我们调用一个辅助方法fixUp对结点重新着色并旋转。insert方法：12345678910111213141516171819202122232425private void insert(Node&lt;K&gt; z)&#123; Node&lt;K&gt; y = null; Node&lt;K&gt; x = this.root; int com; while (x != null)&#123; // 如果根结点不为空，循环比较z的key的大小 y = x; com = z.key.compareTo(x.key); if (com &lt; 0) x = x.left; else x = x.right; &#125; z.parent = y; // y是x结点的父结点，把z结点定义为y结点的子结点 if (y == null) this.root = z; //如果y为null的话，z即为root结点 else&#123; com = z.key.compareTo(y.key); if (com &lt; 0) //如果z的key小于y的key，即为左结点 y.left = z; else y.right = z;//反之为右结点 &#125; z.color = RED;//新增结点颜色定义为红色，不违反红黑树性质的第五条 fixUp(z);//做颜色上的调整 &#125; 利用fixUp做着色和旋转处理，结点初始值为红色，为什么是红色呢 因为红色的话可以少违反一条性质（性质5）：12345678910111213141516171819202122232425262728293031323334353637383940414243private void fixUp(Node&lt;K&gt; z)&#123; while (z.parent != null &amp;&amp; z.parent.color)&#123; //若当前z结点的父结点是红色 if (z.parent == z.parent.parent.left)&#123; //若z的父结点是z的祖父结点的左结点 Node&lt;K&gt; y = z.parent.parent.right; //定义y结点为z的祖父结点的右结点 if (y != null &amp;&amp; y.color)&#123; //case1: 如果y是红色 z.parent.color = BLACK; //z的父结点为黑色 y.color = BLACK; //z的叔叔结点为黑色 z.parent.parent.color = RED; //祖父结点为红色 z = z.parent.parent; //将祖父节点设为当前节点(红色节点) &#125;else &#123; if (z == z.parent.right)&#123; //case2: y是黑色，且当前结点为右结点 z = z.parent; //将父节点作为新的当前节点。 rotateLeft(z); //以新的当前节点为支点进行左旋。 &#125; //case3: y是黑色，且当前节点是左结点。 z.parent.color = BLACK; //设置父结点为黑色 z.parent.parent.color = RED; //祖父结点为红色 rotateRight(z.parent.parent); //以z的祖父结点为支点右旋 &#125; &#125;else &#123; //若z的父结点是z的祖父结点的右结点 Node&lt;K&gt; y = z.parent.parent.left; //定义y结点为z的祖父结点的左结点 //case1：y结点是红色 if (y.color) &#123; z.parent.color = BLACK; y.color = BLACK; z.parent.parent.color = RED; z = z.parent.parent; //将祖父节点设为当前节点(红色节点) &#125; else &#123; //case2：y是黑色，且当前节点是左结点 if (z == z.parent.left)&#123; z = z.parent; //将父节点作为新的当前节点。 rotateRight(z); //以新的当前节点为支点进行右旋。 &#125; //case3: y是黑色，且当前节点是右结点。 z.parent.color = BLACK; //设置父结点为黑色 z.parent.parent.color = RED; //祖父结点为红色 rotateLeft(z.parent.parent); //以z的祖父结点为支点左旋 &#125; &#125; &#125; this.root.color = BLACK; &#125; 下图给出了fixUp的工作原理： 总体来说，插入就是插入一个新的结点，按照红黑树的性质对树的结构进行调整。 删除与n个结点的红黑树上的其他基本操作一样，删除一个结点要花费的时间也是O(lgn)。与插入操作相比删除操作更复杂一些。从一棵红黑树中删除结点的过程是基于二叉搜索树的delete过程的。同样也需要一个transplant子过程：123456789private void transplant(Node&lt;K&gt; u, Node&lt;K&gt; v)&#123; if (u.parent == null) this.root = v; else if (u == u.parent.left) u.parent.left = v; else u.parent.right = v; v.parent = u.parent; &#125; 这段代码不做讲解了，可以参考前一篇博文。delete方法:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private void delete(Node&lt;K&gt; z)&#123; //z是被删除结点 //x是取代节点的右孩子，也是需要调整的节点。 Node&lt;K&gt; x, parent; boolean color; if ((z.left != null) &amp;&amp; (z.right != null) ) &#123; //被删除节点的左右结点都不为空的情况。 Node&lt;K&gt; y = z; //被删节点的后继节点。用它来取代被删节点的位置，然后再将被删节点去掉。 y = y.right; //获取后继节点 while (y.left != null) y = y.left; if (z.parent != null) &#123; //要删除的结点不是根结点 if (z.parent.left == z) z.parent.left = y; else z.parent.right = y; &#125; else &#123; this.root = y; //是根结点 &#125; x = y.right; parent = y.parent; //保存取代节点的颜色 color = y.color; //被删除节点是它的后继节点的父节点 if (parent == z) &#123; parent = y; &#125; else &#123; //x不为空 if (x != null) x.parent = parent; parent.left = x; y.right = z.right; z.right.parent = y; &#125; y.parent = z.parent; y.color = z.color; y.left = z.left; z.left.parent = y; if (color == BLACK) deleteFixUp(x, parent); return ; &#125; if (z.left != null) &#123; x = z.left; &#125; else &#123; x = z.right; &#125; parent = z.parent; //保存取代节点的颜色 color = z.color; if (x != null) x.parent = parent; //不是根节点 if (parent != null) &#123; if (parent.left == z) parent.left = x; else parent.right = x; &#125; else &#123; this.root = x; &#125; if (color == BLACK) deleteFixUp(x, parent); &#125; deleteFixUp方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private void deleteFixUp(Node&lt;K&gt; x, Node&lt;K&gt; parent)&#123; Node&lt;K&gt; w; while ((x == null || x.color == BLACK) &amp;&amp; (x != this.root)) &#123; if (parent.left == x) &#123; //如果x是它父结点的左结点 w = parent.right; if (w.color == RED) &#123; //case1: x的兄弟w是红色的 //因为w必须有黑色子结点，所以可以改变w和x.parent的颜色，然后对x.parent做一次左旋 w.color = BLACK; parent.color = RED; rotateLeft(parent); w = parent.right; &#125; if ((w.left == null || w.left.color == BLACK) &amp;&amp; (w.right == null || w.right.color == BLACK)) &#123; //case2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的 //因为w也是黑色，所以从x上去掉一重黑色，使x只有一重黑色而w为红色，在原来的x.parent上新增一重额外的黑色，通过将x.parent作为新的结点来重复循环实现。 w.color = RED; x = parent; parent = x != null ? x.parent : null; &#125; else &#123; if (w.right == null || w.right.color == BLACK) &#123; //case3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色 //交换w和其左孩子的颜色，然后对w进行右旋 w.left.color = BLACK; w.color = RED; rotateRight(w); w = parent.right; &#125; //case4: x的兄弟w是黑色的；并且w的右孩子是红色的 //修改w，x.parent, w.right颜色，对x.parent进行左旋，设置x为root结束循环 w.color = parent != null ? parent.color : BLACK; parent.color = BLACK; w.right.color = BLACK; rotateLeft(parent); x = this.root; break; &#125; &#125; else &#123; //x是父结点的右结点时情况和上面相反 w = parent.left; if (w.color == RED) &#123; w.color = BLACK; parent.color = RED; rotateRight(parent); w = parent.left; &#125; if ((w.left == null || w.left.color == BLACK) &amp;&amp; (w.right == null || w.right.color == BLACK)) &#123; w.color = RED; x = parent; parent = x != null ? x.parent : null; &#125; else &#123; if (w.left == null || w.left.color == BLACK) &#123; w.right.color = BLACK; w.color = RED; rotateLeft(w); w = parent.left; &#125; w.color = parent != null ? parent.color : BLACK; parent.color = BLACK; w.left.color = BLACK; rotateRight(parent); x = this.root; break; &#125; &#125; &#125; if (x != null) x.color = BLACK; &#125; 下图给出了deleteFixUp的几种情况: 参考《算法导论》第3版https://www.cnblogs.com/skywang12345/p/3245399.html]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1-bit and 2-bit Characters]]></title>
    <url>%2F2017%2F11%2F21%2FleetCode%2F1-bitAnd2-bitCharacters%2F</url>
    <content type="text"><![CDATA[1-bit and 2-bit Characters原题：We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11). Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example1 Input:bits = [1, 0, 0]Output: TrueExplanation:The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character. Example2 Input:bits = [1, 1, 1, 0]Output: FalseExplanation:The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character. Note 1 &lt;= len(bits) &lt;= 1000. bits[i] is always 0 or 1. 题目大意读懂题发现该题并不难，就是给一个字符串，由0和10或11组成，最后一位总是0.问给定的字符串最后一位的0属于0还是10 解题思路做循环判断就行，如果遇到1指针加2遇到0指针加1然后判断长度。代码实现（java）：12345678910111213class Solution &#123; public boolean isOneBitCharacter(int[] bits) &#123; int i = 0; while( i &lt; bits.length - 1)&#123; if(bits[i] == 1) i += 2; else i++; &#125; return i == bits.length - 1; &#125;&#125; python实现：123456789101112131415class Solution(object): def isOneBitCharacter(self, bits): """ :type bits: List[int] :rtype: bool """ i = 0 while(i &lt; len(bits)): if i == len(bits) - 1: return True if bits[i] == 1: i += 2 else: i += 1 return False]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Invert Binary Tree]]></title>
    <url>%2F2017%2F11%2F21%2FleetCode%2FinvertBinaryTree%2F</url>
    <content type="text"><![CDATA[Invert Binary Tree原题：Invert a binary tree. Example1 Input: 4 / \ 2 7 / \ / \1 3 6 9Output: 4 / \ 7 2 / \ / \9 6 3 1 题目大意如例子反转二叉树。 解题思路可以用递归或者借助栈或者bfs（广度优先搜索）做解，这里附上递归的代码。代码实现（java）：123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; TreeNode node = root.right; root.right = root.left; root.left = node; invertTree(root.left); invertTree(root.right); return root; &#125;&#125; python实现：12345678910111213141516171819# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def invertTree(self, root): """ :type root: TreeNode :rtype: TreeNode """ if root == None: return root node = root.left root.left = self.invertTree(root.right) root.right = self.invertTree(node) return root]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum Depth of Binary Tree]]></title>
    <url>%2F2017%2F11%2F20%2FleetCode%2FmaximumDepthofBinaryTree%2F</url>
    <content type="text"><![CDATA[Maximum Depth of Binary Tree原题：Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 题目大意给定一个二叉树，求最大的深度。 解题思路可以用递归和非递归两种方法实现。代码实现（java）：12345678910111213141516/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null) return 0; return Math.max(maxDepth(root.left),maxDepth(root.right))+1; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null) return 0; int level = 0; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int curNum = 1; int nextNum = 0; while(!queue.isEmpty()) &#123; TreeNode n = queue.poll(); curNum--; if(n.left!=null) &#123; queue.add(n.left); nextNum++; &#125; if(n.right!=null) &#123; queue.add(n.right); nextNum++; &#125; if(curNum == 0) &#123; curNum = nextNum; nextNum = 0; level++; &#125; &#125; return level; &#125;&#125; python实现：12345678910111213141516# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if root == None: return 0 return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Average of Levels in Binary Tree]]></title>
    <url>%2F2017%2F11%2F20%2FleetCode%2FaverageofLevelsinBinaryTree%2F</url>
    <content type="text"><![CDATA[Average of Levels in Binary Tree原题：Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array. Example1 Input: 3 / \ 9 20 / \ 15 7Output: [3, 14.5, 11]Explanation:The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Note The range of node’s value is in the range of 32-bit signed integer. 题目大意给定一个非空的二叉树，求每一层的平均值。 解题思路这里想到了广度优先搜索，利用广度优先搜索算法求解。代码实现（java）：1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123; List&lt;Double&gt; list = new ArrayList&lt;&gt;(); if (root == null) return list; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty())&#123; int size = queue.size(); long sum = 0; for (int i = 0; i &lt; size; i++)&#123; TreeNode node = queue.poll(); sum += node.val; if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; double res = (double)sum/size; list.add(res); &#125; return list; &#125;&#125; python实现：1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def averageOfLevels(self, root): """ :type root: TreeNode :rtype: List[float] """ res = [] queue = [root] while queue: res.append(1.0 * sum([n.val for n in queue]) / len(queue)) nqueue = [] for n in queue: if n.left: nqueue.append(n.left) if n.right: nqueue.append(n.right) queue = nqueue return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ransom Note]]></title>
    <url>%2F2017%2F11%2F17%2FleetCode%2FransomNote%2F</url>
    <content type="text"><![CDATA[Ransom Note原题：Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note You may assume that both strings contain only lowercase letters. canConstruct(“a”, “b”) -&gt; falsecanConstruct(“aa”, “ab”) -&gt; falsecanConstruct(“aa”, “aab”) -&gt; true 题目大意给两个字符串，第二个字符串要包含第一个字符串的所有字母，每个字母只能用一次（忽略大小写）。 解题思路利用数组统计每次字母出现的次数，然后进行比较。代码实现（java）：1234567891011121314class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; int[] words = new int[26]; for(int i = 0; i &lt; magazine.length(); i++)&#123; words[magazine.charAt(i) - 'a']++; &#125; for(int i = 0; i &lt; ransomNote.length(); i++)&#123; if(--words[ransomNote.charAt(i) - 'a'] &lt; 0) return false; &#125; return true; &#125;&#125; python实现：python用collections.Counter类统计字符个数，然后比较即可。12345678910111213141516171819from collections import Counterclass Solution(object): def canConstruct(self, ransomNote, magazine): """ :type ransomNote: str :type magazine: str :rtype: bool """ if ransomNote == '': return True if magazine == '': return False ransomNoteCount = Counter(ransomNote) magazineCount = Counter(magazine) for i in ransomNoteCount.keys(): if None == magazineCount.get(i) or ransomNoteCount[i] &gt; magazineCount.get(i): return False else: return True]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intersection of Two Arrays]]></title>
    <url>%2F2017%2F11%2F17%2FleetCode%2FintersectionOfTwoArrays%2F</url>
    <content type="text"><![CDATA[Intersection of Two Arrays原题：Given two arrays, write a function to compute their intersection. Example1 Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note Each element in the result must be unique. The result can be in any order. 题目大意给两个数组，求两个数组的交集，顺序可以随便，但是结果中的元素唯一。 解题思路解题思路有很多，这里自己看代码吧，不做解释了。代码实现（java）：1234567891011121314151617181920212223class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i = 0; i &lt; nums1.length; i++)&#123; set.add(nums1[i]); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; nums2.length; i++)&#123; if(set.contains(nums2[i]))&#123; list.add(nums2[i]); set.remove(nums2[i]); &#125; &#125; int[] res = new int[list.size()]; for(int i = 0; i &lt; list.size(); i++)&#123; res[i] = list.get(i); &#125; return res; &#125;&#125; python实现：12345678class Solution(object): def intersection(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] """ return list(set(nums1) &amp; set(nums2))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock II]]></title>
    <url>%2F2017%2F11%2F16%2FleetCode%2FbestTimetoBuyAndSellStockII%2F</url>
    <content type="text"><![CDATA[Best Time to Buy and Sell Stock II原题：Say you have an array for which the i^th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题目大意假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。设计一个算法来找到最大的利润。你可以完成尽可能多的交易(多次买卖股票)。然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。 解题思路运用贪心算法，每次把比前一个大的差值都加入结果中。代码实现（java）：123456789101112class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices == null || prices.length == 0) return 0; int res = 0; for(int i = 1; i &lt; prices.length; i++)&#123; if(prices[i] &gt; prices[i - 1]) res += prices[i] - prices[i - 1]; &#125; return res; &#125;&#125; python实现：123456789101112class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ res = 0 for i in range(1, len(prices)): c = prices[i] - prices[i - 1] if c &gt; 0: res += c return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum Moves to Equal Array Elements]]></title>
    <url>%2F2017%2F11%2F16%2FleetCode%2FminimumMovestoEqualArrayElements%2F</url>
    <content type="text"><![CDATA[Minimum Moves to Equal Array Elements原题：Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Example1 Input:[1,2,3] Output:3 Explanation:Only three moves are needed (remember each move increments two elements): [1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] Note The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won’t exceed 10,000. 题目大意给定一个数组，每次把n-1个数字＋1，问最少多少次所有的元素能相等。 解题思路n－1个元素＋1相当于微加一的数字减1，答案就是所有元素与最小值的差值的和。代码实现（java）：123456789101112131415class Solution &#123; public int minMoves(int[] nums) &#123; int min = Integer.MAX_VALUE; for(int i : nums)&#123; min = Math.min(min, i); &#125; int res = 0; for(int i : nums)&#123; res += i - min; &#125; return res; &#125;&#125; python实现：1234567class Solution(object): def minMoves(self, nums): """ :type nums: List[int] :rtype: int """ return sum(nums) - len(nums)*min(nums)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Range Addition II]]></title>
    <url>%2F2017%2F11%2F16%2FleetCode%2FrangeAdditionII%2F</url>
    <content type="text"><![CDATA[Range Addition II原题：Given an m * n matrix M initialized with all 0’s and several update operations. Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 &lt;= i &lt; a and 0 &lt;= j &lt; b. You need to count and return the number of maximum integers in the matrix after performing all the operations. Example1 Input:m = 3, n = 3operations = [[2,2],[3,3]]Output: 4Explanation:Initially, M =[[0, 0, 0], [0, 0, 0], [0, 0, 0]] After performing [2,2], M =[[1, 1, 0], [1, 1, 0], [0, 0, 0]] After performing [3,3], M =[[2, 2, 1], [2, 2, 1], [1, 1, 1]] So the maximum integer in M is 2, and there are four of it in M. So return 4. Note The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won’t exceed 10,000. 题目大意输入m＊n的数组，operations数组里面的是这个范围内的数字增加1，求最大值的数量。 解题思路如果ops为空结果为m*n，不为空即为ops中最小值的乘积。代码实现（java）：1234567891011121314class Solution &#123; public int maxCount(int m, int n, int[][] ops) &#123; if(ops == null || ops.length == 0) return m*n; int a = Integer.MAX_VALUE, b = Integer.MAX_VALUE; for (int i = 0; i &lt; ops.length; i++)&#123; a = Math.min(ops[i][0], a); b = Math.min(ops[i][1], b); &#125; return a*b; &#125;&#125; python实现：1234567891011121314151617class Solution(object): def maxCount(self, m, n, ops): """ :type m: int :type n: int :type ops: List[List[int]] :rtype: int """ if not ops: return m*n a = 40000 b = 40000 for i in range(len(ops)): a = min(a, ops[i][0]) b = min(b, ops[i][1]) return a*b]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Construct the Rectangle]]></title>
    <url>%2F2017%2F11%2F16%2FleetCode%2FconstructTheRectangle%2F</url>
    <content type="text"><![CDATA[Construct the Rectangle原题：For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements: The area of the rectangular web page you designed must equal to the given target area. The width W should not be larger than the length L, which means L &gt;= W. The difference between length L and width W should be as small as possible. You need to output the length L and the width W of the web page you designed in sequence. Example1 Input: 4Output: [2, 2]Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2. Note The given area won’t exceed 10,000,000 and is a positive integer The web page’s width and length you designed must be positive integers. 题目大意给定一个数字area，求L*M=area，并且L和M的差值最小。 解题思路得到area的开根数，然后循环，如果遇到能整除的，除数和商就是解。代码实现（java）：123456789101112class Solution &#123; public int[] constructRectangle(int area) &#123; int l = 0, w = 0; for(int i = 1; i &lt;= (int)Math.sqrt(area); i++)&#123; if(area % i == 0)&#123; l = area/i; w = i; &#125; &#125; return new int[]&#123;l, w&#125;; &#125;&#125; python实现：123456789class Solution(object): def constructRectangle(self, area): sqrt = int(math.sqrt(area)) l, w = area, 1 for x in range(sqrt, 0, -1): if area % x == 0: l, w = area / x, x break return [l, w]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Move Zeroes]]></title>
    <url>%2F2017%2F11%2F15%2FleetCode%2FmoveZeroes%2F</url>
    <content type="text"><![CDATA[Move Zeroes原题：Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note You must do this in-place without making a copy of the array. Minimize the total number of operations. 题目大意给定一个数组 里面有0和非0的数，把所有非0的数都移动到前面，0移到后面。 解题思路定义一个标记count，依次移动非0的数，最后剩余长度补0.代码实现（java）：1234567891011121314class Solution &#123; public void moveZeroes(int[] nums) &#123; int length = nums.length; int count = 0; for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] != 0) nums[count++] = nums[i]; &#125; while(count &lt; length) nums[count++] = 0; &#125;&#125; python实现：12345678910class Solution(object): def moveZeroes(self, nums): count = 0 for i in range(len(nums)): if(nums[i] is not 0): nums[count] = nums[i] count += 1 for i in range(count, len(nums)): nums[i] = 0]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel Sheet Column Number]]></title>
    <url>%2F2017%2F11%2F15%2FleetCode%2FexcelSheetColumnNumber%2F</url>
    <content type="text"><![CDATA[Excel Sheet Column Number原题：Given a column title as appear in an Excel sheet, return its corresponding column number. Example1 A -&gt; 1 B -&gt; 2 C -&gt; 3 … Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 题目大意相当于要把字符串转int，26进制转10进制，不过A是从1开始的。 解题思路按进制转换的思路做，A－&gt;1,AA-&gt; 26*1+1。代码实现（java）：123456789101112class Solution &#123; public int titleToNumber(String s) &#123; if(s.length() == 0 || s == null) return -1; int sum = 0; for (int i = 0; i &lt; s.length(); i++)&#123; sum = 26*sum + s.charAt(i)-'A' + 1; &#125; return sum; &#125;&#125; python实现：12345678910class Solution(object): def titleToNumber(self, s): """ :type s: str :rtype: int """ sum = 0 for c in s: sum = sum*26 + ord(c) - ord('A') + 1 return sum]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Employee Importance]]></title>
    <url>%2F2017%2F11%2F05%2FleetCode%2FemployeeImportance%2F</url>
    <content type="text"><![CDATA[Employee Importance原题：You are given a data structure of employee information, which includes the employee’s unique id, his importance value and his direct subordinates’ id. For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct. Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates. Example1 Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1Output: 11Explanation:Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11. Note One employee has at most one direct leader and may have several subordinates. The maximum number of employees won’t exceed 2000. 题目大意题目意思就是题目自定了一个数据结构，第一个值为id，第二个值为权重，第三个值为下属。一个公司每个人对应一个数据结构，给你一个人的id，让你返回他以及他的所有下属的权重和。 解题思路第一种思路：把id作为key把员工对象作为value，放在map对象中，利用递归求和。第二种思路：还是利用map，借助一个链表结构活着也可以是一个队列或者栈进行进栈和出栈操作。代码实现（java）：1234567891011121314151617181920212223242526272829303132/*// Employee infoclass Employee &#123; // It's the unique id of each node; // unique id of this employee public int id; // the importance value of this employee public int importance; // the id of direct subordinates public List&lt;Integer&gt; subordinates;&#125;;*/class Solution &#123; public int getImportance(List&lt;Employee&gt; employees, int id) &#123; Map&lt;Integer, Employee&gt; map = new HashMap&lt;&gt;(); for(Employee employee : employees)&#123; map.put(employee.id, employee); &#125; return dfs(map, id); &#125; private int dfs(Map&lt;Integer, Employee&gt; map, int id)&#123; int res = 0; Employee cur = map.get(id); res += cur.importance; for(int subId : cur.subordinates)&#123; res += dfs(map, subId); &#125; return res; &#125;&#125; 123456789101112131415161718192021222324252627282930313233/*// Employee infoclass Employee &#123; // It's the unique id of each node; // unique id of this employee public int id; // the importance value of this employee public int importance; // the id of direct subordinates public List&lt;Integer&gt; subordinates;&#125;;*/class Solution &#123; public int getImportance(List&lt;Employee&gt; employees, int id) &#123; Map&lt;Integer, Employee&gt; map = new HashMap&lt;&gt;(); for(Employee employee : employees)&#123; map.put(employee.id, employee); &#125; int res = 0; LinkedList&lt;Employee&gt; list = new LinkedList&lt;&gt;(); list.add(map.get(id)); while (!list.isEmpty())&#123; Employee employee = list.poll(); res += employee.importance; for (int i : employee.subordinates)&#123; list.add(map.get(i)); &#125; &#125; return res; &#125;&#125; python实现：123456789101112131415161718192021222324"""# Employee infoclass Employee(object): def __init__(self, id, importance, subordinates): # It's the unique id of each node. # unique id of this employee self.id = id # the importance value of this employee self.importance = importance # the id of direct subordinates self.subordinates = subordinates"""class Solution(object): def getImportance(self, employees, id): """ :type employees: Employee :type id: int :rtype: int """ map = &#123;employee.id: employee for employee in employees&#125; def dfs(id): importance = sum([dfs(id) for id in map[id].subordinates]) return importance + map[id].importance return dfs(id)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Trim a Binary Search Tree]]></title>
    <url>%2F2017%2F11%2F04%2FleetCode%2FtrimABinarySearchTree%2F</url>
    <content type="text"><![CDATA[Trim a Binary Search Tree原题：Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree. Example1 Example2 题目大意给定一个数求这个数的补数，补数就是这个数的二进制数，从最高的第一个1起开始翻转。之前的0不翻转。 解题思路利用位运算求出来共有多少位需要翻转，y-1就是所有需要翻转的位数都为1的一个值，然后进行异或运算。代码实现（java）：1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode trimBST(TreeNode root, int L, int R) &#123; TreeNode res = null; if(root == null) return null; if(root.val &lt;= R &amp;&amp; root.val &gt;= L)&#123; root.left = trimBST(root.left, L, R); root.right = trimBST(root.right, L, R); res = root; &#125; if(root.val &lt; L) res = trimBST(root.right, L, R); if(root.val &gt; R) res = trimBST(root.left, L, R); return res; &#125;&#125; python实现：123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def trimBST(self, root, L, R): """ :type root: TreeNode :type L: int :type R: int :rtype: TreeNode """ if not root: return root if root.val &lt; L: return self.trimBST(root.right, L, R) if root.val &gt; R: return self.trimBST(root.left, L, R) root.left = self.trimBST(root.left, L, R) root.right = self.trimBST(root.right, L, R) return root]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Number Complement]]></title>
    <url>%2F2017%2F11%2F04%2FleetCode%2FnumberComplement%2F</url>
    <content type="text"><![CDATA[Number Complement原题：Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Example1 Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example2 Input: 1Output: 0Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. Note The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation. 题目大意给定一个数求这个数的补数，补数就是这个数的二进制数，从最高的第一个1起开始翻转。之前的0不翻转。 解题思路利用位运算求出来共有多少位需要翻转，y-1就是所有需要翻转的位数都为1的一个值，然后进行异或运算。代码实现（java）：1234567891011class Solution &#123; public int findComplement(int num) &#123; int x = num, y = 1; while(x != 0)&#123; x = x &gt;&gt; 1; y = y &lt;&lt; 1; &#125; return num^(y-1); &#125;&#125; python实现：123456789101112class Solution(object): def findComplement(self, num): """ :type num: int :rtype: int """ x = num y = 1 while x is not 0: x = x &gt;&gt; 1 y = y &lt;&lt; 1 return num^(y - 1)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Merge Two Binary Trees]]></title>
    <url>%2F2017%2F11%2F04%2FleetCode%2FmergeTwoBinaryTrees%2F</url>
    <content type="text"><![CDATA[Merge Two Binary Trees原题：Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example Note The merging process must start from the root nodes of both trees. 题目大意合并两棵二叉树，把相同结点上的数字相加组成新的结点值。 解题思路利用递归，把相同位置的结点相加。代码实现（java）：123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if(t1 == null) return t2; if(t2 == null) return t1; t1.left = mergeTrees(t1.left, t2.left); t1.right = mergeTrees(t1.right, t2.right); t1.val += t2.val; return t1; &#125;&#125; python实现：12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def mergeTrees(self, t1, t2): """ :type t1: TreeNode :type t2: TreeNode :rtype: TreeNode """ if t1 is None: return t2 if t2 is None: return t1 t1.left = self.mergeTrees(t1.left, t2.left) t1.right = self.mergeTrees(t1.right, t2.right) t1.val += t2.val return t1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Hamming Distance]]></title>
    <url>%2F2017%2F11%2F04%2FleetCode%2FhammingDistance%2F</url>
    <content type="text"><![CDATA[Hamming Distance原题：The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Example Input: x = 1, y = 4Output: 2Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑The above arrows point to positions where the corresponding bits are different. Note 0 ≤ x, y &lt; 2^31. 题目大意求两个数字的汉明距离（汉明距离就是两个数字的二进制相异的位的总数）。 解题思路两种解题思路，一种就是都转成二进制树，然后循环遍历，这里就不贴代码了，第二种就是利用位运算，异或然后&amp;1就能算出来汉明距离。代码实现（java）：123456789class Solution &#123; public int hammingDistance(int x, int y) &#123; int res = 0, e = x ^ y; for(int i = 0; i &lt; 32; i++)&#123; res += (e&gt;&gt;i) &amp; 1; &#125; return res; &#125;&#125; python实现：12345678910111213class Solution(object): def hammingDistance(self, x, y): """ :type x: int :type y: int :rtype: int """ e = x ^ y res = 0 for i in range(0, 31): res += (e &gt;&gt; i) &amp; 1 return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树--java实现]]></title>
    <url>%2F2017%2F11%2F03%2Falgorithm%2FbinaryTree%2F</url>
    <content type="text"><![CDATA[前一段时间看jdk1.8中的hashmap源码的时候发现应用到了红黑树，想补一下红黑树的知识，这里先介绍一下二叉搜索树的结构。如果有不正确的地方欢迎指正～～ 什么是二叉搜索树二叉搜索树又名二叉查找树和二叉排序树。二叉搜索树是以一棵二叉树来组织的，如下图所示，这样的一棵树可以使用链表的数据结构来表示，每一个结点就是一个对象。每个结点包含key（值），left（左孩子），right（右孩子）和p（双亲）。如果某个孩子结点和父结点不存在，则相应属性值为NIL。根结点是树中唯一父结点指针为NIL的结点。 设x是二叉搜索树中的一个结点。如果y是x的左子树结点那么y.key&lt;=x.key。如果y是x的右子树结点，那么y.key&gt;=x.key。 定义介绍完了，下面就来看看二叉搜索树的基本操作。 java实现123456789101112131415161718192021222324252627public class BinaryTree&lt;K extends Comparable&lt;K&gt;&gt;&#123; static final class TreeNode&lt;K&gt;&#123; //结点中的值 K key; //左孩子 TreeNode&lt;K&gt; left; //右孩子 TreeNode&lt;K&gt; right; //父结点 TreeNode&lt;K&gt; p; TreeNode(K key) &#123; this(key, null, null, null); &#125; TreeNode(K key, TreeNode&lt;K&gt; left, TreeNode&lt;K&gt; right, TreeNode&lt;K&gt; p) &#123; this.key = key; this.left = left; this.right = right; this.p = p; &#125; &#125; //根结点 private TreeNode&lt;K&gt; root;&#125; 插入非递归操作。1234567891011121314151617181920212223242526272829303132public void insert(K k)&#123; //创建结点 TreeNode&lt;K&gt; treeNode = new TreeNode&lt;&gt;(k); if (root == null) root = treeNode; else &#123; //当前结点 TreeNode&lt;K&gt; currentNode = root; TreeNode&lt;K&gt; parent = null; int b; //查找结点插入位置 while (currentNode != null)&#123; //记录父结点 parent = currentNode; //比较结点值 b = k.compareTo(currentNode.key); if(b &lt; 0) currentNode = currentNode.left; else currentNode = currentNode.right; &#125; //找到位置后和父结点比较，插入 b = k.compareTo(parent.key); treeNode.p = parent; if (b &lt; 0) parent.left = treeNode; else parent.right = treeNode; &#125; &#125; 递归操作。12345678910111213141516public void insertRecursion(K k)&#123; insertRec(k, root); &#125; private TreeNode&lt;K&gt; insertRec(K k, TreeNode&lt;K&gt; x)&#123; if(x==null) return new TreeNode&lt;K&gt;(k); int b = k.compareTo(x.key); if(b &lt; 0) x.left = insertRec(k, x.left); else if(b &gt; 0) x.right = insertRec(k, x.right); return x; &#125; 查寻非递归操作。1234567891011121314151617public TreeNode&lt;K&gt; search(K k)&#123; //从根结点开始查找 TreeNode&lt;K&gt; currentNode = root; int b; //循环判断结点值是否相等 while (currentNode != null &amp;&amp; currentNode.key != k)&#123; b = k.compareTo(currentNode.key); //当前结点值赋为左结点 if (b &lt; 0) currentNode = currentNode.left; //当前结点值赋为右结点 else currentNode = currentNode.right; &#125; return currentNode; &#125; 递归操作。12345678910111213141516private TreeNode&lt;K&gt; s(TreeNode&lt;K&gt; x, K k)&#123; if (x==null) return x; int cmp = k.compareTo(x.key); if (cmp &lt; 0) return s(x.left, k); else if (cmp &gt; 0) return s(x.right, k); else return x; &#125; public TreeNode&lt;K&gt; searchRecursion(K k) &#123; return s(root, k); &#125; 最大值和最小值最大值一定在结点的右子树中。最小值一定在结点的左子树中。12345678910111213public TreeNode&lt;K&gt; min(TreeNode&lt;K&gt; x)&#123; while (x != null)&#123; x = x.left; &#125; return x; &#125; public TreeNode&lt;K&gt; max(TreeNode&lt;K&gt; x)&#123; while (x != null)&#123; x = x.right; &#125; return x; &#125; 前驱和后继结点的前驱：是该结点的左子树中的最大结点。结点的后继：是该结点的右子树中的最小结点。12345678910111213141516171819202122232425262728293031public TreeNode&lt;K&gt; predecessor(TreeNode&lt;K&gt; x)&#123; //如果x结点的左子树不为空，则左子树中的最大值即为前驱结点 if (x.left != null) return max(x.left); //如果x没有左孩子。则有两种可能： //1.x是一个右孩子，则x的前驱结点为它的父结点。 //2.x是一个左孩子，则查找x的最低的父结点，并且该父结点要具有右孩子，找到的这个最低的父结点就是x的前驱结点。 TreeNode&lt;K&gt; parent = x.p; while (parent != null &amp;&amp; parent.left == x)&#123; x = parent; parent = parent.p; &#125; return parent; &#125; public TreeNode&lt;K&gt; successor(TreeNode&lt;K&gt; x)&#123; //如果x结点的右子树不为空，则右子树中的最小值即为后继结点 if (x.right != null) return min(x.right); //如果x没有右孩子。则有两种可能： //1.x是一个左孩子，则x的后继结点为它的父结点。 //2.x是一个右孩子，则查找x的最低的父结点，并且该父结点要具有左孩子，找到的这个最低的父结点就是x的后继结点。 TreeNode&lt;K&gt; parent = x.p; while (parent != null &amp;&amp; parent.right == x)&#123; x = parent; parent = parent.p; &#125; return parent; &#125; 遍历二叉搜索树允许通过一个简单的递归算法按顺序输出二叉搜索树的所有元素。 先序遍历若二叉树非空，则执行以下操作：1.访问根结点；2.先序遍历左子树；3.先序遍历右子树。1234567891011public void preinorder()&#123; preinorder(root); &#125; private void preinorder(TreeNode&lt;K&gt; x)&#123; if (x != null)&#123; System.out.print(x.key + " "); preinorder(x.left); preinorder(x.right); &#125; &#125; 中序遍历若二叉树非空，则执行以下操作：1.中序遍历左子树；2.访问根结点；3.中序遍历右子树。1234567891011public void inorder()&#123; inorder(root); &#125; private void inorder(TreeNode&lt;K&gt; x)&#123; if (x != null)&#123; inorder(x.left); System.out.print(x.key + " "); inorder(x.right); &#125; &#125; 后序遍历若二叉树非空，则执行以下操作：1.后序遍历左子树；2.后序遍历右子树；3.访问根结点。1234567891011public void postinorder()&#123; postinorder(root); &#125; private void postinorder(TreeNode&lt;K&gt; x)&#123; if (x != null)&#123; postinorder(x.left); postinorder(x.right); System.out.print(x.key + " "); &#125; &#125; 删除从一棵二叉搜索树中删除一个结点x的整个策略分为三种情况：1.如果z没有孩子结点，那么只是简单的将它删除，并修改它的父结点用null来作为孩子来替换x。2.如果z只有一个孩子，那么将这个孩子提升到树中z的位置并修改z的父结点用x的孩子来替换x。3.如果z有两个孩子，那么z的后继y（一定在z的右子树中），并让y占据树中z的位置。z的原来右子树部分部分成为y的新的右子树，并且z的左子树成为y的新的左子树。如图所示： 为了再二叉搜索树中移动子树，定义一个子过程transplant，它是用另一棵子树替换一棵子树并成为其双亲结点的孩子结点。当transplant用一棵以v为根的子树来替换一棵以u为根的子树时，结点u的双亲变为结点v的双亲，并且最后v成为u的双亲的相应孩子。transplant没有处理v.left和v.right的更新；这些更新由transplant的调用者处理。123456789101112131415161718192021222324252627282930313233343536373839404142434445private void transplant(TreeNode&lt;K&gt; u, TreeNode&lt;K&gt; v)&#123; //u是根的情况 if(u.p == null) root = v; //如果u是一个左孩子，对u.p.left进行更新 else if (u == u.p.left) u.p.left = v; //如果u是一个右孩子，对u.p.right进行更新 else u.p.right = v; //如果v非null更新v.p if (v != null) v.p = u.p; &#125; private void delete(TreeNode&lt;K&gt; z)&#123; //没有左孩子 if (z.left == null) transplant(z, z.right); //有左孩子但是没有右孩子 else if (z.right == null) transplant(z, z.left); //有两个孩子的情况 else &#123; //查找后继结点 TreeNode&lt;K&gt; y = min(z.right); //如果y不是z的左孩子，将y移除原来的位置，并替换树中的z if (y.p != z)&#123; //用y的右孩子替换y并成为y的双亲的一个孩子 transplant(y, y.right); //将z的右孩子转为y的右孩子 y.right = z.right; y.right.p = y; &#125; //如果y是z的右孩子，用y替换z并成为z的双亲的孩子，用z的左孩子替换y的左孩子 transplant(z, y); y.left = z.left; y.left.p = y; &#125; &#125; public void remove(K k)&#123; delete(search(k)); &#125; 总结1.如果x是一棵有n个结点子树的根，那么遍历的这棵树需要O(n)时间。2.在一棵高度为h的二叉搜索树上，动态集合上的操作search，min，max，successor，predecessor可以在O(h)时间内完成。3.在一棵高度为h的二叉搜索树上，实现动态的集合操作insert和remove的运行时间均为O(h)。 参考《算法导论》第三版 本文为原创文章，如需转载请注明出处。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadPoolExecutor源码分析（JDK1.8）]]></title>
    <url>%2F2017%2F11%2F02%2Fjava%2FthreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[为什么使用线程池合理利用线程池能够带来三个好处。1.降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。2.提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。3.提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 java中如何创建线程池简要类图关系 Executor: 是Java线程池的超级接口；提供一个execute(Runnable command)方法;我们一般用它的继承接口ExecutorService。ExecutorService: 是一个比Executor使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回Future的方法AbstractExecutorService: ExecutorService执行方法的默认实现ScheduledExecutorService: 一个可定时调度任务的接口ThreadPoolExecutor: 线程池，可以通过调用Executors以下静态工厂方法来创建线程池并返回一个ExecutorService对象Executors: 是java.util.concurrent包下的一个类，提供了若干个静态方法，用于生成不同类型的线程池。Executors一共可以创建下面这四类线程池： 1.newFixedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。2.newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。3.newScheduledThreadPool 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。4.newSingleThreadExecutor 创建一个使用单个worker线程的Executor，以无界队列方式来运行该线程。它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 ThreadPoolExecutor在java线程池中，最核心的类是ThreadPoolExecutor，它是线程池的实现类，创建ThreadPoolExecutor一般使用Executors工厂模式创建，Executors类提供了一系列工厂方法用于创建线程池。下面我们一起来深入看一下ThreadPoolExecutor。 属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 整个线程池的控制状态，包含了两个属性：有效线程的数量、线程池的状态（runState）。 * workerCount,有效线程的数量 * runState, 线程池的状态 * * ctl 包含32位数据，低29位存线程数，高3位存runState,这样runState有5个值： * * RUNNING: 接受新任务，处理任务队列中的任务 * SHUTDOWN: 不接受新任务，处理任务队列中的任务 * STOP: 不接受新任务，不处理任务队列中的任务 * TIDYING: 所有任务完成，线程数为0，然后执行terminated() * TERMINATED: terminated() 已经完成 * 具体值： * RUNNING:-536870912 * SHUTDOWN:0 * STOP:536870912 * TIDYING:1073741824 * TERMINATED:1610612736 */private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); // 29位的偏移量 private static final int COUNT_BITS = Integer.SIZE - 3; // 最大容量（2^29 - 1） private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // 阻塞队列 private final BlockingQueue&lt;Runnable&gt; workQueue; // 可重入锁 private final ReentrantLock mainLock = new ReentrantLock(); // 存放工作线程集合 private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); // 终止条件 private final Condition termination = mainLock.newCondition(); // 最大线程池容量 private int largestPoolSize; // 已完成任务数量 private long completedTaskCount; // 线程工厂 private volatile ThreadFactory threadFactory; // 拒绝执行处理器 private volatile RejectedExecutionHandler handler; // 线程等待运行时间 private volatile long keepAliveTime; // 是否运行核心线程超时 private volatile boolean allowCoreThreadTimeOut; // 核心池的大小 private volatile int corePoolSize; // 最大线程池大小 private volatile int maximumPoolSize; 围绕ctl的几个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 这个方法用于取出runState的值 因为CAPACITY值为：00011111111111111111111111111111 * ~为按位取反操作，则~CAPACITY值为：11100000000000000000000000000000 * 再同参数做&amp;操作，就将低29位置0了，而高3位还是保持原先的值，也就是runState的值 * * @param c * 该参数为存储runState和workerCount的int值 * @return runState的值 */private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY;&#125;/** * 这个方法用于取出workerCount的值 * 因为CAPACITY值为：00011111111111111111111111111111，所以&amp;操作将参数的高3位置0了 * 保留参数的低29位，也就是workerCount的值 * * @param c * ctl, 存储runState和workerCount的int值 * @return workerCount的值 */private static int workerCountOf(int c) &#123; return c &amp; CAPACITY;&#125;/** * 将runState和workerCount存到同一个int中 * “|”运算的意思是，假设rs的值是101000，wc的值是000111，则他们位或运算的值为101111 * * @param rs * runState移位过后的值，负责填充返回值的高3位 * @param wc * workerCount移位过后的值，负责填充返回值的低29位 * @return 两者或运算过后的值 */private static int ctlOf(int rs, int wc) &#123; return rs | wc;&#125;// 只有RUNNING状态会小于0private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN;&#125; 构造方法ThreadPoolExecutor类一共有四个构造方法，前三个构造方法最终都是调用的最后一个构造方法，这里我们主要分析一下最后一个构造方法。123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。keepAliveTime（线程活动保持时间）：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0。unit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。workQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列:1.ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。2.LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。3.SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。4.PriorityBlockingQueue：一个具有优先级得无限阻塞队列。threadFactory: 用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。handler: 表示当拒绝处理任务时的策略，有以下四种取值:ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 增加任务以及执行execute我们只能向线程池提交任务, 而被提交的任务最终能否执行以及能否立即执行, 则都由线程池自己来控制。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ // 1. 如果运行的线程小于corePoolSize,则尝试使用用户定义的Runnalbe对象创建一个新的线程，调用addWorker函数会原子性的检查runState和workCount，通过返回false来防止在不应该添加线程时添加了线程 // 2. 如果一个任务能够成功入队列，在添加一个线城时仍需要进行双重检查（因为在前一次检查后该线程死亡了），或者当进入到此方法时，线程池已经shutdown了，所以需要再次检查状态，若有必要，当停止时还需要回滚入队列操作，或者当线程池没有线程时需要创建一个新线程 // 3. 如果无法入队列，那么需要增加一个新线程，如果此操作失败，那么就意味着线程池已经shutdown或者已经饱和了，所以拒绝任务 //获取线程池控制状态 int c = ctl.get(); //用workerCountOf方法根据ctl的值获取当前有效线程数，如果小于核心线程数，尝试添加任务 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; //如果线程池处于RUNNING状态则尝试把请求加入等待队列 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; //再次检查，获取线程池控制状态 int recheck = ctl.get(); //线程池不处于RUNNING状态，将命令从等待队列中移除 if (! isRunning(recheck) &amp;&amp; remove(command)) //拒绝执行命令 reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //如果请求加入等待队列失败，则尝试创建新线程 else if (!addWorker(command, false)) reject(command); &#125; 说明：当在客户端调用submit时（submit也是提交任务的方法和execute的区别是submit会有一个Future对象的返回值），之后会间接调用到execute函数，其在将来某个时间执行给定任务，此方法中并不会直接运行给定的任务。此方法中主要会调用到addWorker函数来开辟新的线程，其中，addWorker函数源码如下 addWorker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//firstTask 等待执行的任务 //core 是否把任务添加到核心线程中执行，true用核心线程数判断执行，false用最大线程数判断执行private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); //获取线程池控制状态 int rs = runStateOf(c); // Check if queue empty only if necessary. //状态大于等于SHUTDOWN，初始的ctl为RUNNING，小于SHUTDOWN //状态为SHUTDOWN //第一个任务为null //worker队列不为空 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) //直接返回 return false; for (;;) &#123; //worker数量 int wc = workerCountOf(c); //worker数量大于等于最大容量 if (wc &gt;= CAPACITY || // worker数量大于等于核心线程池大小或者最大线程池大小 wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //比较并增加worker的数量跳出外层循环 if (compareAndIncrementWorkerCount(c)) break retry; //获取线程池控制状态 c = ctl.get(); // Re-read ctl // 此次的状态与上次获取的状态不相同 if (runStateOf(c) != rs) // 跳过剩余部分，继续循环 continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; // worker开始标识 boolean workerStarted = false; // worker被添加标识 boolean workerAdded = false; Worker w = null; try &#123; //把任务封装在Worker中，最后都会在Worker中执行，并创建一个新线程。 w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; //锁，保证线程同步 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. //获取线程池状态 int rs = runStateOf(ctl.get()); // 如果线程池处于RUNNING状态执行添加任务操作,或线程池处于SHUTDOWN 状态，firstTask 为空。 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // 将worker添加到worker集合 workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; //设置worker已被添加标识 workerAdded = true; &#125; &#125; finally &#123; //释放锁 mainLock.unlock(); &#125; if (workerAdded) &#123; //线程执行 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; addWorker完成如下几件任务1.原子性的增加workerCount。2.将用户给定的任务封装成为一个worker，并将此worker添加进workers集合中。3.启动worker对应的线程，并启动该线程，运行worker的run方法。4.如果失败了回滚worker的创建动作，即将worker从workers集合中删除，并原子性的减少workerCount。 该方法中创建了一个Worker实例，下面我们一起看看该内部类的源码。 WorkerWorker是真正的任务，是由任务执行线程完成，它是ThreadPoolExecutor的核心。每个线程池中，有为数不等的Worker对象，每个Worker对象中，包含一个需要立即执行的新任务和已经执行完成的任务数量，Worker本身，是一个Runnable对象，不是Thread对象它内部封装一个Thread对象，用此对象执行本身的run方法，而这个Thread对象则由ThreadPoolExecutor提供的ThreadFactory对象创建新的线程。（将Worker和Thread分离的好处是，如果我们的业务代码，需要对于线程池中的线程，赋予优先级、线程名称、线程执行策略等其他控制时，可以实现自己的ThreadFactory进行扩展，无需继承或改写ThreadPoolExecutor。）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** Thread this worker is running in. Null if factory fails. */ //worker持有的线程 final Thread thread; /** Initial task to run. Possibly null. */ //worker正在执行的任务 ，可能为null. Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; /** * 创建Worker时会同时创建一个新线程. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; /把Worker传递给新建的线程，当线程执行是会调用Worker的run方法。 this.thread = getThreadFactory().newThread(this); &#125; /** Delegates main run loop to outer runWorker */ //线程执行时会调用该方法 public void run() &#123; runWorker(this); &#125; // Lock methods // // The value 0 represents the unlocked state. // The value 1 represents the locked state. protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; public void lock() &#123; acquire(1); &#125; public boolean tryLock() &#123; return tryAcquire(1); &#125; public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125; &#125; 既然Worker是一个Runnable对象那么看一下它的run方法。 runWorker1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253final void runWorker(Worker w) &#123; //获取当前线程 Thread wt = Thread.currentThread(); //获取w的任务 Runnable task = w.firstTask; w.firstTask = null; //释放锁（设置state为0，允许中断） w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; //任务不为null或者阻塞队列还存在任务 while (task != null || (task = getTask()) != null) &#123; //获取锁 w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt //线程池的运行状态至少应该高于STOP || 线程被中断 &amp;&amp; 再次检查，线程池的运行状态至少应该高于STOP &amp;&amp; // wt线程（当前线程）没有被中断 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) //中断wt线程（当前线程） wt.interrupt(); try &#123; //beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等 beforeExecute(wt, task); Throwable thrown = null; try &#123; //执行任务 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; //增加worker完成的任务数量 w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125; &#125; 此函数中会实际执行给定任务（即调用用户重写的run方法），并且当给定任务完成后，会继续从阻塞队列中取任务，直到阻塞队列为空（即任务全部完成）。 getTask从阻塞队列中获取任务。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? //无限循环，确保操作成功 for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. //当线程池处于STOP及以上状态时，线程数减一，该线程不使用。 //当线程处于SHUTDOWN 状态时，并且workQueue请求队列为空，释放该线程。 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; //获取当前线程数 int wc = workerCountOf(c); // Are workers subject to culling? //如果调用allowCoreThreadTimeOut方法设置为true，则所有线程都有超时时间。 //如果当前线程数大于核心线程数则该线程有超时时间。 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; //worker数量大于maximumPoolSize if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) //workerCount大于1或者worker阻塞队列为空（在阻塞队列不为空时，需要保证至少有一个wc） &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; // 比较并减少workerCount if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; //poll方法从阻塞队列中取出对象，如果队列为空，则当前线程阻塞keepAliveTime时间再尝试取出，还是没有就返回null，记录超时状态，在重新进入for循环时才试图终结Worker。 //take()方法没有超时时间，会一直获取。也就是说在这里不断获取任务， //也就是如果线程池处于RUNNING、SHUTDOWN状态时，只要等待队列不为空，那么线程就会一直执行。这也就是线程重用的原理。 try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125; &#125; 说明：此函数用于从workerQueue阻塞队列中获取Runnable对象，由于是阻塞队列，所以支持有限时间等待（poll）和无限时间等待（take）。在该函数中还会响应shutDown和、shutDownNow函数的操作，若检测到线程池处于SHUTDOWN或STOP状态，则会返回null，而不再返回阻塞队列中的Runnalbe对象。 processWorkerExitrunWorker方法的finally语句块中有一个processWorkerExit方法，processWorkerExit方法是在worker退出时调用到的方法，而引起worker退出的主要因素如下： 1.阻塞队列已经为空，即没有任务可以运行了。 2.调用了shutDown或shutDownNow函数下面来看一下这个方法。123456789101112131415161718192021222324252627282930313233343536private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; //如果线程被中断，则需要减少workCount if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted decrementWorkerCount(); final ReentrantLock mainLock = this.mainLock; //获取锁 mainLock.lock(); try &#123; //将worker完成的任务数添加到总的完成任务中 completedTaskCount += w.completedTasks; //从workers中移除worker workers.remove(w); &#125; finally &#123; //释放锁 mainLock.unlock(); &#125; //这个方法是尝试终止的方法下面会介绍 tryTerminate(); //获取线程池控制状态 int c = ctl.get(); //小于STOP的运行状态 if (runStateLessThan(c, STOP)) &#123; if (!completedAbruptly) &#123; int min = allowCoreThreadTimeOut ? 0 : corePoolSize; if (min == 0 &amp;&amp; ! workQueue.isEmpty()) min = 1; if (workerCountOf(c) &gt;= min) return; // replacement not needed &#125; //添加worker addWorker(null, false); &#125; &#125; 说明：此函数会根据是否中断了空闲线程来确定是否减少workerCount的值，并且将worker从workers集合中移除并且会尝试终止线程池。 结束线程池shutdown1234567891011121314151617public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //检查shutdown权限 checkShutdownAccess(); //把线程池的状态置为SHUTDOWN advanceRunState(SHUTDOWN); //中断所有空闲线程 interruptIdleWorkers(); //调用shutdown方法 onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); &#125; 说明：shutdown是把线程池状态转为SHUTDOWN，这时等待队列中的任务可以继续执行，但是不会接受新任务了，通过中断方式停止空闲的（根据没有获取锁来确定）线程。 shutdownNowshutdownNow与shutdown相似，shutdownNow会尝试停止所有的活动执行任务、暂停等待任务的处理，并返回等待执行的任务列表，但是其会终止所有的worker，而并非空闲的worker。12345678910111213141516public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(STOP); interruptWorkers(); //清空队列 tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); return tasks; &#125; tryTerminate该方法是一个终止线程池的方法。12345678910111213141516171819202122232425262728293031323334353637383940final void tryTerminate() &#123; //无限循环，确保操作成功 for (;;) &#123; //获取线程池控制状态 int c = ctl.get(); //线程池的运行状态为RUNNING || 线程池的运行状态最小要大于TIDYING || 线程池的运行状态为SHUTDOWN &amp;&amp; workQueue队列不为null if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) //不能终止，直接返回 return; //线程池正在运行的worker数量不为0 if (workerCountOf(c) != 0) &#123; // Eligible to terminate //仅仅中断一个空闲的worker interruptIdleWorkers(ONLY_ONE); return; &#125; final ReentrantLock mainLock = this.mainLock; //获取锁 mainLock.lock(); try &#123; //比较并设置线程池控制状态为TIDYING if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; terminated(); &#125; finally &#123; //设置线程池控制状态为TERMINATED ctl.set(ctlOf(TERMINATED, 0)); //释放在termination条件上等待的所有线程 termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#125; // else retry on failed CAS &#125; &#125; 1.tryTerminate()方法尝试终止线程池活动，满足终止条件的因素有两个：首先，ctl状态为STOP,或者为SHUTDOWN且任务队列为空（STOP状态之所以一直都不用判断workQueue是因为上面讲到的，shutdownNow()方法调用了drainQueue()方法清空了workQueue所以其必然为空，这里解释一下）；其次，ctl计数为0。第二个条件的满足是由一连串连锁反应保证的，shutdownNow()方法置ctl状态为STOP,使得所有worker调用getTask()方法满足rs&gt;=SHUTDOWN条件从而调用decrementWorkerCount()方法，这将最终导致ctl计数为0，同时所有work都将从getTask()方法获得null，最终导致runWorker()方法调用processWorkerExit（）方法，将workers数组真正清空。shutdown（）方法稍微复杂，它置ctl状态为SHUTDOWN，但是线程池仍将继续运行，直至所有workers将工作队列中的任务全部完成，之后的逻辑和stop状态下的完全一样，不再多说。 2.在保证了上述两个条件之后，tryTerminate()方法获取住所mainLock，置ctl状态为TIDYING,之后执行terminated方法，最后置ctl状态为TERMINATED。 interruptIdleWorkers1234567891011121314151617181920212223242526private void interruptIdleWorkers(boolean onlyOne) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //遍历workers队列 for (Worker w : workers) &#123; Thread t = w.thread; //线程未被中断并且成功获得锁 if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; try &#123; //中断线程 t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; finally &#123; //释放锁 w.unlock(); &#125; &#125; //若只中断一个，则跳出循环 if (onlyOne) break; &#125; &#125; finally &#123; mainLock.unlock(); &#125; &#125; 说明：此函数将会中断正在等待任务的空闲worker。 总结ThreadPoolExecutor是线程池框架的一个核心类，通过对ThreadPoolExecutor的分析，可以知道其对资源进行了复用，并非无限制的创建线程，可以有效的减少线程创建和切换的开销，关于ThreadPoolExecutor的源码就分析到这里。 参考http://blog.csdn.net/qq_22929803/article/details/52347381http://www.jianshu.com/p/6e65757a7b33http://blog.csdn.net/clevergump/article/details/50688008]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码分析(JDK1.8)]]></title>
    <url>%2F2017%2F10%2F27%2Fjava%2FconcurrentHashMap%2F</url>
    <content type="text"><![CDATA[在日常开发中，常常要使用HashMap，但是在多线程环境下HashMap是线程不安全的，可以使用Hashtable，或者Collections.synchronizedMap(new HashMap&lt;&gt;())。但是ConcurrentHashMap通常是一个更好的选择。在实现上Hashtable和Collections.synchronizedMap(new HashMap&lt;&gt;())都是对整个map加锁，ConcurrentHashMap是对map中的所有桶加了锁。 1.6中的实现：ConcurrentHashMap采用分段锁的机制，实现并发的更新操作，底层由Segment数组和HashEntry数组组成。Segment继承ReentrantLock用来充当锁的角色，每个Segment对象守护每个散列映射表的若干个桶。HashEntry用来封装映射表的键/值对；每个桶是由若干个HashEntry对象链接起来的链表。一个 ConcurrentHashMap实例中包含由若干个Segment对象组成的数组，下面我们通过一个图来演示一下 ConcurrentHashMap的结构： JDK1.8中改进：1.取消segments字段，（Segment虽保留，但已经简化属性，仅仅是为了兼容旧版本。）直接采用transient volatile HashEntry table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。2.将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。（这点和HashMap是一样的）对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中。如果hash之后散列的很均匀，那么table数组中的每个队列长度主要为0或者1。但实际情况并非总是如此理想，虽然ConcurrentHashMap类默认的加载因子为0.75，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。 ConcurrentHashMap的定义12public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable 属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 //最大的表容量。 private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认的初始表容量。必须是2的幂 private static final int DEFAULT_CAPACITY = 16; //最大(两个)数组大小。 static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //此表的默认并发级别。(1.8中已经不使用了，为了兼容以前的版本) private static final int DEFAULT_CONCURRENCY_LEVEL = 16; //这个表的装载因子。 private static final float LOAD_FACTOR = 0.75f; //链表转红黑树的阀值，如果table[i]下面的链表长度大于8时就转化为树 static final int TREEIFY_THRESHOLD = 8; //红黑树转链表的阀值，小于等于6时转为链表，仅在扩容时才可能树转链表 static final int UNTREEIFY_THRESHOLD = 6; //数组可以转化为树的表的最小容量，（否则，如果一个bin中的节点太多，表将被调整大小。）该值应至少为4 * TREEIFY_THRESHOLD以避免调整大小和树化阈值之间的冲突。 static final int MIN_TREEIFY_CAPACITY = 64; //每个转移步骤的最小重新排列数。范围是细分为允许多个resizer线程。这个值作为一个下限，以避免resizers遇到内存争夺过多，该值至少应该是DEFAULT_CAPACITY。 private static final int MIN_TRANSFER_STRIDE = 16; //用来控制扩容的时候 单线程进入的变量 private static int RESIZE_STAMP_BITS = 16; //用来控制扩容的时候 单线程进入的变量 private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS; //可以帮助调整大小的最大线程数 private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1; //节点的标识 static final int MOVED = -1; // hash for forwarding nodes static final int TREEBIN = -2; // hash for roots of trees static final int RESERVED = -3; // hash for transient reservations static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash //装数据的数组，第一次插入数据的时候初始化,大小为2^n. transient volatile Node&lt;K,V&gt;[] table; //扩容时使用 private transient volatile Node&lt;K,V&gt;[] nextTable; //记录容器的容量大小(但返回的不一定是当前Map的真实元素个数)，通过CAS无锁更新 private transient volatile long baseCount; //hash表初始化或扩容时的一个控制位标识量。 //负数代表正在进行初始化或扩容操作 //-1代表正在初始化 //-N 表示有N-1个线程正在进行扩容操作 //正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小 //默认是table大小的0.75 倍，用公式0.75（n - (n &gt;&gt;&gt; 2)）计算。 private transient volatile int sizeCtl; //自旋锁（锁定通过 CAS）在调整大小和/或创建CounterCells时使用。在CounterCell类更新value中会使用，功能类似显示锁和内置锁，性能更好(在Striped64类也有应用) private transient volatile int cellsBusy; 构造方法ConcurrentHashMap有5个构造方法这里着重介绍第5个构造方法。123456789101112131415161718192021222324//看一下最后一个参数concurrencyLevel,表示能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数。public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; //检查参数的有效性 if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (initialCapacity &lt; concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads long size = (long)(1.0 + (long)initialCapacity / loadFactor); int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); this.sizeCtl = cap; &#125; //返回给定所需容量，table的大小总是2的幂次方 private static final int tableSizeFor(int c) &#123; int n = c - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; 上面的代码先用一系列的移位和 | 操作把n变成二进制表示的形式，然后加1，就会变成2^k了。12//计算节点的位置 h 是 key的hash n 是table的大小int index = (n - 1) &amp; h; table的大小n是2^k，那么n-1就会是0..1….1的形式，并且小于n，通过与h按位与就可以得到对应的index了。而在扩容时，ConcurrentHashMap会将table的大小变为原来的2倍，这样，计算index时就变成了(2n-1)&amp;h，那么n-1为0011的话，2n-1就是0111，这样扩容后的index要么等于扩容前的index，否则就等于index+n，减小了扩容时的计算量。(这和HashMap的方式相同)。 注意，ConcurrentHashMap在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。 重要的内部类NodeNode是最核心的内部类，它包装了key-value键值对，所有插入ConcurrentHashMap的数据都包装在这里面。它与HashMap中的定义很相似，但是但是有一些差别它对value和next属性设置了volatile同步锁(与JDK7的Segment相同)，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。 TreeNode树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap继承自Node类，而并非HashMap中的继承自LinkedHashMap.Entry类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。 TreeBin这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。 ForwardingNode在transfer操作中使用，一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找。生命周期：仅存活于扩容操作。 主要方法initTable当put方法调用table==null时会执行此方法初始化table。123456789101112131415161718192021222324252627//初始化表，使用sizeCtl中记录的大小。private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; //进入循环 while ((tab = table) == null || tab.length == 0) &#123; //如果sizeCtl&lt;0说明已经有其它线程正在进行扩容，即正在初始化或初始化完成,其它线程通过Thread.yield()让出CPU时间片，等待table非空即可。 if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin //利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; //这里注意table的大小为sizeCtl table = tab = nt; sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; break; &#125; &#125; return tab; &#125; helpTransfer这是扩容过程中的一个辅助方法。在多线程情况下，如果发现其它线程正在扩容，则帮助转移元素。（只有这种情况会被调用）从某种程度上说，其“优先级”很高，只要检测到扩容，就会放下其他工作，先扩容。12345678910111213141516171819202122//调用这个方法之前，nextTable对象一定已经存在的。final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123; //返回用于调整大小为n的表的大小的标记位。 int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; //开始扩容 transfer(tab, nextTab); break; &#125; &#125; return nextTab; &#125; return table; &#125; addCount12345678910111213141516171819202122232425262728293031323334353637383940414243private final void addCount(long x, int check) &#123; CounterCell[] as; long b, s; //利用CAS方法把当前ConcurrentHashMap的元素个数+1 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123; CounterCell a; long v; int m; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123; //多线程CAS发生失败的时候执行 fullAddCount(x, uncontended); return; &#125; if (check &lt;= 1) return; s = sumCount(); &#125; //如果check值大于等于0 则需要检验是否需要进行扩容操作 if (check &gt;= 0) &#123; Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; int rs = resizeStamp(n); //正在进行初始化或扩容操作 if (sc &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; //如果已经有其他线程在执行扩容操作 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; //当前线程是唯一的或是第一个发起扩容的线程 此时nextTable=null else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); &#125; &#125; &#125; transfer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range if (nextTab == null) &#123; // initiating try &#123; @SuppressWarnings("unchecked") //构造一个nextTable对象 它的容量是原来的两倍 Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; transferIndex = n; &#125; int nextn = nextTab.length; //构造一个连节点指针 用于标志位 ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); //并发扩容的关键属性 如果等于true 说明这个节点已经处理过 boolean advance = true; //循环的关键变量，判断是否已经扩容完成，完成就return，退出循环 boolean finishing = false; // to ensure sweep before committing nextTab //死循环 for (int i = 0, bound = 0;;) &#123; Node&lt;K,V&gt; f; int fh; //循环的关键控制i，i--操作保证了倒序遍历数组 while (advance) &#123; int nextIndex, nextBound; if (--i &gt;= bound || finishing) advance = false; //nextIndex=transferIndex=n=tab.length(默认16) else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; advance = false; &#125; //用CAS计算得到的transferIndex else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound; i = nextIndex - 1; advance = false; &#125; &#125; //i&lt;0，i&gt;=n说明已经遍历完旧的数组tab，i+n&gt;=nextn说明已经扩容完成 if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; //所有节点复制完毕 if (finishing) &#123; nextTable = null; table = nextTab; //扩容阈值设置为原来容量的1.5倍，相当于现在容量的0.75倍 sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; &#125; //利用CAS更新扩容阈值,sc-1表明新加入一个线程参与扩容 if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; //如果有两个线程，值肯定不相等，所以直接返回（保持只有一个线程执行） if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; //finishing和advance保证线程已经扩容完成了可以退出循环 finishing = advance = true; i = n; // recheck before commit &#125; &#125; //如果tab[i]为null，那么就把fwd插入到tab[i]，表明这个节点已经处理过了 else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); //f.hash=-1,说明该节点为ForwardingNode，说明该节点已经处理过了 else if ((fh = f.hash) == MOVED) advance = true; // already processed else &#123; //把当前节点加锁 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; //ln原位置节点，hn新位置节点 Node&lt;K,V&gt; ln, hn; //这是一个链表Node节点 if (fh &gt;= 0) &#123; int runBit = fh &amp; n; //构造两个链表，一个是原链表；另一个是原链表的反序排列 Node&lt;K,V&gt; lastRun = f; for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; else &#123; hn = lastRun; ln = null; &#125; for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; //在nextTable的i位置上插入一个链表 setTabAt(nextTab, i, ln); //在nextTable的i+n的位置上插入另一个链表 setTabAt(nextTab, i + n, hn); //在table的i位置上插入forwardNode节点 表示已经处理过该节点 setTabAt(tab, i, fwd); //设置advance为true 返回到上面的while循环中 就可以执行i--操作 advance = true; &#125; //对TreeBin对象进行处理，与上面的过程类似 else if (f instanceof TreeBin) &#123; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; //构造正序和反序两个链表 for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; //如果扩容后已经不再需要tree的结构，反向转换为链表结构 ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; //在nextTable的i位置上插入一个链表 setTabAt(nextTab, i, ln); //在nextTable的i+n的位置上插入另一个链表 setTabAt(nextTab, i + n, hn); //在table的i位置上插入fwd节点，表示已经处理过该节点 setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125; &#125; put既然上面说的ConcurrentHashMap的构造函数不会初始化table，会延迟到第一次put，那么我们就来看看put方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public V put(K key, V value) &#123; return putVal(key, value, false); &#125;//计算hash值 static final int spread(int h) &#123; return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS; &#125;//putVal操作采用CAS+synchronized实现并发插入或更新操作 final V putVal(K key, V value, boolean onlyIfAbsent) &#123; //ConcurrentHashMap 不允许插入null键，HashMap允许插入一个null键 if (key == null || value == null) throw new NullPointerException(); //算出hash值（即数组下标） int hash = spread(key.hashCode()); int binCount = 0; //死循环，直到插入成功 for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) //初始化table tab = initTable(); //去除tab中的节点赋值给f //如果table[i]==null(即该位置的节点为空，没有发生碰撞)，则利用CAS操作直接存储在该位置，如果CAS操作成功则退出死循环。 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; //table[i]!=null(即该位置已经有其它节点，发生碰撞) //检查table[i]的节点的hash是否等于MOVED，如果等于，则检测到正在扩容，则帮助其扩容 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; //结点上锁 这里的结点可以理解为hash值相同组成的链表的头结点 synchronized (f) &#123; //避免多线程，需要重新检查 if (tabAt(tab, i) == f) &#123; //fh〉0 说明这个节点是一个链表的节点 不是树的节点 if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; //hash和key都相同 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; //如果没有找到值为key的节点，新建Node加入链表。 if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; //首节点为TreeBin，为红黑树结构，按照红黑树的方式插入数据。 else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; //如果链表长度达到阀值需要调整结构变为红黑树。 if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; //将当前ConcurrentHashMap的元素数量+1，有可能触发扩容操作。 addCount(1L, binCount); return null; &#125; tryPresize这个方法也是扩容操作。在putAll和链表转红黑树的时候使用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private final void tryPresize(int size) &#123; //给定的容量若&gt;=MAXIMUM_CAPACITY的一半，直接扩容到允许的最大值，否则调用函数扩容 int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1); int sc; //没有正在初始化或扩容，或者说表还没有被初始化 while ((sc = sizeCtl) &gt;= 0) &#123; Node&lt;K,V&gt;[] tab = table; int n; //没有被初始化 if (tab == null || (n = tab.length) == 0) &#123; n = (sc &gt; c) ? sc : c; //期间没有其他线程对表操作，则CAS将SIZECTL状态置为-1，表示正在进行初始化 if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; //重复检查 if (table == tab) &#123; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = nt; //无符号右移2位(即0.75*n) sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; //更新扩容阀值 sizeCtl = sc; &#125; &#125; &#125; //若想要扩容的值不大于原阀值，或现有容量&gt;=最值，什么都不用做了 else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) break; else if (tab == table) &#123; //返回一个标志位 int rs = resizeStamp(n); //执行扩容操作 if (sc &lt; 0) &#123; Node&lt;K,V&gt;[] nt; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); &#125; &#125; &#125; treeifyBin链表转红黑树方法。123456789101112131415161718192021222324252627private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123; Node&lt;K,V&gt; b; int n, sc; if (tab != null) &#123; //容量小于64，扩容 if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) tryPresize(n &lt;&lt; 1); else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123; synchronized (b) &#123; if (tabAt(tab, index) == b) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) hd = p; else tl.next = p; tl = p; &#125; //在原来index的位置，用TreeBin替换掉原来的Node对象 setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd)); &#125; &#125; &#125; &#125; &#125; get上面介绍完put相关的方法了，下面来看看get方法。1234567891011121314151617181920212223public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; //计算hash值 int h = spread(key.hashCode()); //根据hash值确定节点位置 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; //eh&lt;0，说明这个节点在树上，直接查找树 else if (eh &lt; 0) return (p = e.find(h, key)) != null ? p.val : null; //链表，找到对应的值并返回 while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null; &#125; containsValue查询当前ConcurrentHashMap是否包含该value值。有可能需要遍历一遍ConcurrentHashMap。12345678910111213141516public boolean containsValue(Object value) &#123; //判断value是否为null，这里和HashMap不同 if (value == null) throw new NullPointerException(); Node&lt;K,V&gt;[] t; //如果table不为空遍历table。 if ((t = table) != null) &#123; Traverser&lt;K,V&gt; it = new Traverser&lt;K,V&gt;(t, t.length, 0, t.length); for (Node&lt;K,V&gt; p; (p = it.advance()) != null; ) &#123; V v; if ((v = p.val) == value || (v != null &amp;&amp; value.equals(v))) return true; &#125; &#125; return false; &#125; replaceNoderemove的核心方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//注意：cv才是key-value中的value！final V replaceNode(Object key, V value, Object cv) &#123; int hash = spread(key.hashCode()); for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; //该table第一个元素为空，直接跳过 if (tab == null || (n = tab.length) == 0 || (f = tabAt(tab, i = (n - 1) &amp; hash)) == null) break; else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; boolean validated = false; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; validated = true; for (Node&lt;K,V&gt; e = f, pred = null;;) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; V ev = e.val; //value为null或value和查到的值相等 if (cv == null || cv == ev || (ev != null &amp;&amp; cv.equals(ev))) &#123; oldVal = ev; if (value != null) e.val = value; else if (pred != null) pred.next = e.next; else setTabAt(tab, i, e.next); &#125; break; &#125; pred = e; if ((e = e.next) == null) break; &#125; &#125; //以树的方式find、remove else if (f instanceof TreeBin) &#123; validated = true; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; r, p; if ((r = t.root) != null &amp;&amp; (p = r.findTreeNode(hash, key, null)) != null) &#123; V pv = p.val; if (cv == null || cv == pv || (pv != null &amp;&amp; cv.equals(pv))) &#123; oldVal = pv; if (value != null) p.val = value; else if (t.removeTreeNode(p)) setTabAt(tab, i, untreeify(t.first)); &#125; &#125; &#125; &#125; &#125; if (validated) &#123; if (oldVal != null) &#123; if (value == null) addCount(-1L, -1); return oldVal; &#125; break; &#125; &#125; &#125; return null; &#125; clear移除ConcurrentHashMap中所有的元素。12345678910111213141516171819202122232425262728293031323334public void clear() &#123; long delta = 0L; // negative number of deletions int i = 0; Node&lt;K,V&gt;[] tab = table; while (tab != null &amp;&amp; i &lt; tab.length) &#123; int fh; Node&lt;K,V&gt; f = tabAt(tab, i); //为空，直接跳过 if (f == null) ++i; else if ((fh = f.hash) == MOVED) &#123; tab = helpTransfer(tab, f); i = 0; // restart &#125; else &#123; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; Node&lt;K,V&gt; p = (fh &gt;= 0 ? f : (f instanceof TreeBin) ? ((TreeBin&lt;K,V&gt;)f).first : null); //首先删除链、树的末尾元素，避免产生大量垃圾 while (p != null) &#123; --delta; p = p.next; &#125; //利用CAS无锁置null setTabAt(tab, i++, null); &#125; &#125; &#125; &#125; if (delta != 0L) addCount(delta, -1); &#125; 总结ConcurrentHashMap是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于HashTable和同步包装器包装的HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。1.6中采用ReentrantLock 分段锁的方式，使多个线程在不同的segment上进行写操作不会发现阻塞行为;1.8中直接采用了内置锁synchronized，因为1.8的虚拟机对内置锁已经优化的足够快了。 思考ConcurrentHashMap能完全代替HashTable吗？ 参考http://blog.csdn.net/fjse51/article/details/55260493http://blog.csdn.net/u010723709/article/details/48007881http://www.itdadao.com/articles/c15a1157176p0.htmlhttp://www.importnew.com/22007.htmlhttps://www.waitig.com/concurrenthashmap-java8.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bit Operation(位运算)]]></title>
    <url>%2F2017%2F10%2F26%2FoperatingSystem%2FbitOperation%2F</url>
    <content type="text"><![CDATA[位运算最近在看一些源码的时候，发现里面大量的运用了位运算，所以在这里总结一下位运算。 什么是位运算？按位操作符用来操作整数基本数据类型中的单个”比特“（bit），即二进制。按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。 位运算符的使用&amp;(按位“与”操作符)如果两个输入位都是1，则输出位为1；否则输出位为0. |（按位“或”操作符）如果两个输入位只要有一个为1，则输出位为1；否则输出位为0. ^(按位“异或”操作符)如果输入位的某一个为1，但不全是1，则输出位为1；否则输出位为0. ~(按位“非”操作符)生成与输入位相反的值。－－若输入1，输出0；输入0，输出1. &lt;&lt;(左移操作符)按照操作符右侧指定的位数，将操作符左侧的操作数向左移动（在低位补0）。a&lt;&lt;b相当于a乘以2的b次方。 &gt;&gt;(右移操作符)按照操作符右侧指定的位数，将操作符左侧的操作数向右移动。“有符号”右移操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1.相当于a除以2的b次方（取整）。 &gt;&gt;&gt;(无符号右移操作符)无论正负都在高位插入0，这个操作符在c和c++中是没有的，是java中增加的。 下面列举了一些常见的二进制位的变换操作。 功能 示例 位运算 去掉最后一位 (101101-&gt;10110) x &gt;&gt; 1 在最后加一个0 (101101-&gt;1011010) x &lt;&lt; 1 在最后加一个1 (101101-&gt;1011011) x &lt;&lt; 1+1 把最后一位变成1 (101100-&gt;101101) x &#x7C; 1 把最后一位变成0 (101101-&gt;101100) x &#x7C; 1-1 最后一位取反 (101101-&gt;101100) x ^ 1 把右数第k位变成1 (101001-&gt;101101,k=3) x &#x7C; (1 &lt;&lt; (k-1)) 把右数第k位变成0 (101101-&gt;101001,k=3) x &amp; ~ (1 &lt;&lt; (k-1)) 右数第k位取反 (101001-&gt;101101,k=3) x ^ (1 &lt;&lt; (k-1)) 取末三位 (1101101-&gt;101) x &amp; 7 取末k位 (1101101-&gt;1101,k=5) x &amp; (1 &lt;&lt; k-1) 取右数第k位 (1101101-&gt;1,k=4) x &gt;&gt; (k-1) &amp; 1 把末k位变成1 (101001-&gt;101111,k=4) x &#x7C; (1 &lt;&lt; k-1) 末k位取反 (101001-&gt;100110,k=4) x ^ (1 &lt;&lt; k-1) 把右边连续的1变成0 (100101111-&gt;100100000) x &amp; (x+1) 把右起第一个0变成1 (100101111-&gt;100111111) x &#x7C; (x+1) 把右边连续的0变成1 (11011000-&gt;11011111) x &#x7C; (x-1) 取右边连续的1 (100101111-&gt;1111) (x ^ (x+1)) &gt;&gt; 1 去掉右起第一个1的左边 (100101000-&gt;1000) x &amp; (x ^ (x-1)) （未完待续。。。）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Find the Difference]]></title>
    <url>%2F2017%2F10%2F25%2FleetCode%2FfindTheDifference%2F</url>
    <content type="text"><![CDATA[Find the Difference原题：Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example1 Input:s = “abcd”t = “abcde”Output:eExplanation:‘e’ is the letter that was added. 题目大意给定两个字符串s，t。 t是由s增加了一个字符而得到的，找出增加的字符。 解题思路有很多解法，可以用异或，可以转成Unicode码，可以利用map key的形式，这里用异或的形式。代码实现（java）：1234567891011121314class Solution &#123; public char findTheDifference(String s, String t) &#123; char c = 0; for(int i = 0; i &lt; s.length(); i++)&#123; c ^= s.charAt(i); &#125; for(int i = 0; i &lt; t.length(); i++)&#123; c ^= t.charAt(i); &#125; return c; &#125;&#125; python实现（python是不是比java代码简单许多呢）：123class Solution(object): def findTheDifference(self, s, t): return chr(reduce(operator.xor, map(ord, s + t)))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Find All Numbers Disappeared in an Array]]></title>
    <url>%2F2017%2F10%2F25%2FleetCode%2FfindAllNumbersDisappearedInAnArray%2F</url>
    <content type="text"><![CDATA[Find All Numbers Disappeared in an Array原题：Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example1 Input:[4,3,2,7,8,2,3,1]Output:[5,6] 题目大意给定一个数组，1 ≤ a[i] ≤ n，n是数组的长度。其中有的数字出现一次，有的数字出现两次，有的不出现，找出不出现的数字。 解题思路要求不能使用额外的空间。循环数组，取到每个元素的值i－1获得该元素对应的下标，把该值置为负数，再遍历一遍数组，元素为正数的位置n＋1 即为没有出现的值。代码实现（java）：123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(nums == null || nums.length == 0) return res; for(int i = 0; i &lt; nums.length; i++)&#123; int val = Math.abs(nums[i]) - 1; if(nums[val] &gt; 0) nums[val] = -nums[val]; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) &#123; res.add(i + 1); &#125; &#125; return res; &#125;&#125; python实现：123456789101112class Solution(object): def findDisappearedNumbers(self, nums): res = [] for i in range(len(nums)): val = abs(nums[i]) - 1 if nums[val] &gt; 0: nums[val] = -nums[val] for i in range(len(nums)): if nums[i] &gt; 0: res.append(i + 1) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Sum of Two Integers]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FsumOfTwoIntegers%2F</url>
    <content type="text"><![CDATA[Sum of Two Integers原题：Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example1 Given a = 1 and b = 2, return 3. 题目大意给两个数字a, b 求ab的和，不能使用＋/-. 解题思路第一个想法就是使用位运算，但是没有什么好的思路。网上查了一下：这里用到了一个半加法的思想, 即两位单独的位相加其结果可以用异或得到, 进位可以用与得到. 然后对于两个数字来说同样可以延伸这个思想.举个例子: 11+5, 其二进制形式为11: 1011, 5: 0101 那么两个位置都为1的地方就需要进位, 所以进位值就为0001. 原位置两个数相加的结果为那个位置值的异或即1110, 即两个位置值如果不一样就为1, 一样的话要么两个位置原来值都为0结果也为0, 要么进位, 那么结果依然是0. 接下来就要把进位位和下一位相加, 所以进位值左移一位,即0001变为0010, 重复上面操作可得新的进位值为0010, 原位置异或(即相加)结果为1100. 继续重复上面操作直到进位为0, 可得到最终结果10000, 即16代码实现（java）：123456789class Solution &#123; public int getSum(int a, int b) &#123; if(b == 0) return a; int r = a ^ b; int curry = (a &amp; b) &lt;&lt; 1; return getSum(r, curry); &#125;&#125; python实现就显得太不要脸了，哈哈：1234class Solution(object): def getSum(self, a, b): res = [a, b] return sum(res)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Detect Capital]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FdetectCapital%2F</url>
    <content type="text"><![CDATA[Detect Capital原题：Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: 1.All letters in this word are capitals, like “USA”.2.All letters in this word are not capitals, like “leetcode”.3.Only the first letter in this word is capital if it has more than one letter, like “Google”.Otherwise, we define that this word doesn’t use capitals in a right way. Example1 Input: “USA”Output: True Example2 Input: “FlaG”Output: False Note The input will be a non-empty word consisting of uppercase and lowercase latin letters. 题目大意给定一个字符串，如果全是大写或者小写或者首字母为大写其余全是小写 返回true 否则返回false 解题思路没什么好说的了就是判断了。代码实现（java）：1234567891011121314class Solution &#123; public boolean detectCapitalUse(String word) &#123; if (word == null) return false; if (word.equals(word.toLowerCase()) || word.equals(word.toUpperCase())) return true; if (Character.isUpperCase(word.charAt(0)))&#123; String str = word.substring(1, word.length()); if (str.equals(str.toLowerCase())) return true; &#125; return false; &#125;&#125; python实现：12345class Solution(object): def detectCapitalUse(self, word): if(word == word.upper() or word == word.lower() or word == word.capitalize()): return True return False]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Max Consecutive Ones]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FmaxConsecutiveOnes%2F</url>
    <content type="text"><![CDATA[Max Consecutive Ones原题：Given a binary array, find the maximum number of consecutive 1s in this array. Example1 Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 题目大意给定一个数组，求出里面连续1的最大个数。 解题思路第一种思路是把数组变为字符串根据0分割，求出最长的字符串。代码实现（java）：123456789101112131415class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int res = 0; StringBuilder in = new StringBuilder(); for(int num : nums)&#123; in.append(num); &#125; String[] strs = in.toString().split("0"); for(String str : strs)&#123; if(res &lt; str.length()) res = str.length(); &#125; return res; &#125;&#125; 第二种思路是把每次到0之前的长度算出来和最后结果比较把大的赋值给返回值，在去比较下一轮。代码实现（java）：1234567891011class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int res = 0; int count = 0; for(int num : nums)&#123; count = (num == 1) ? ++count : 0; res = Math.max(res, count); &#125; return res; &#125;&#125; python第二种思路实现：12345678class Solution(object): def findMaxConsecutiveOnes(self, nums): res = 0 count = 0 for i in range(len(nums)): count = count + 1 if nums[i] == 1 else 0; res = max(res, count) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Binary Number with Aliternating Bits]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FbinaryNumberWithAliternatingBits%2F</url>
    <content type="text"><![CDATA[Binary Number with Alternating Bits原题：Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example1 Input: 5Output: TrueExplanation:The binary representation of 5 is: 101 Example2 Input: 7Output: FalseExplanation:The binary representation of 7 is: 111. Example3 Input: 11Output: FalseExplanation:The binary representation of 11 is: 1011. Example4 Input: 10Output: TrueExplanation:The binary representation of 10 is: 1010. 题目大意给定一个数，判断这个数的二进制相邻的两个数都不相同。 解题思路求出二进制数，依次判断。代码实现（java）：1234567891011class Solution &#123; public boolean hasAlternatingBits(int n) &#123; String str = Integer.toBinaryString(n); for (int i = 0; i &lt; str.length() - 1; i++)&#123; if (str.charAt(i) == str.charAt(i + 1)) &#123; return false; &#125; &#125; return true; &#125;&#125; python实现：1234567class Solution(object): def hasAlternatingBits(self, n): str = bin(n).replace("0b", "") for i in range(len(str) - 1): if str[i] == str[i + 1]: return False return True]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Single Number]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FsingleNumber%2F</url>
    <content type="text"><![CDATA[Single Number原题：Given an array of integers, every element appears twice except for one. Find that single one. Note Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 题目大意给定一个数组，里面的元素有的出现两次，只有一个出现一次，找出出现一次的。 解题思路利用位运算：a^a=0 a^0=a。代码实现（java）：123456789class Solution &#123; public int singleNumber(int[] nums) &#123; int res = 0; for(int num : nums)&#123; res ^= num; &#125; return res; &#125;&#125; python实现：123456class Solution(object): def singleNumber(self, nums): res = 0 for i in range(len(nums)): res ^= nums[i] return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Nim Game]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FnimGame%2F</url>
    <content type="text"><![CDATA[Nim Game原题：You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. 题目大意题目说给我们一堆石子，每次可以拿一个两个或三个，两个人轮流拿，拿到最后一个石子的人获胜，现在给我们一堆石子的个数，问我们能不能赢。 解题思路因为每个人都取不到4个，假设自己后走，要保证每轮自己和对方取得数量的和是4，这样就能确保每轮完后都有4的倍数个石头被取走。这样，如果我们先走的话，先把n除4的余数个石头拿走，这样不管怎样，到最后都会留4个下来，对方取1个你就取3个，对方取2个你就取2个，就必赢了。代码实现（java）：12345class Solution &#123; public boolean canWinNim(int n) &#123; return (n &amp; 3) != 0; &#125;&#125; python实现：123class Solution(object): def canWinNim(self, n): return (n &amp; 3) != 0]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Longest Uncommon Subsequence I]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FlongestUncommonSubsequence1%2F</url>
    <content type="text"><![CDATA[Longest Uncommon Subsequence I原题：Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1. Example1 Input: “aba”, “cdc”Output: 3Explanation: The longest uncommon subsequence is “aba” (or “cdc”),because “aba” is a subsequence of “aba”,but not a subsequence of any other strings in the group of two strings. Note Both strings’ lengths will not exceed 100. Only letters from a ~ z will appear in input strings. 题目大意给定一组两个的字符串，您需要找到这组两个字符串中最长的不常见的子序列。 最长的不常见的子序列被定义为这些字符串之一的最长子序列，并且该子序列不应该是其他字符串的任何子序列。子序列是可以通过删除一些字符而不改变剩余元素的顺序从一个序列导出的序列。 简而言之，任何字符串本身都是一个子序列，空字符串是任何字符串的子序列。输入将是两个字符串，输出需要是最长的不常见子序列的长度。 如果最长不常见的子序列不存在，则返回-1。 解题思路因为最长子字符串就是本身，所以答案也就出来了。代码实现（java）：12345678class Solution &#123; public int findLUSlength(String a, String b) &#123; if(a.equals(b)) return -1; else return Math.max(a.length(), b.length()); &#125;&#125; python实现：123class Solution(object): def findLUSlength(self, a, b): return -1 if a == b else max(len(a), len(b))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Next Greater Element1]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FnextGreaterElement1%2F</url>
    <content type="text"><![CDATA[Next Greater Element I原题：You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number. Example1 Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1]Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. Note All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000. 题目大意给出两个数组，数组1和数组2 找出数组1中每个元素在数组2中右边最大的一位数字，如果没有返回－1. 解题思路把数组2的元素作为key，下标作为value放入map中，外层循环数组1，内层循环数组2，从map中取出当前数组1中的值的value＋1，作为起始点。判断大小。代码实现（java）：12345678910111213141516171819class Solution &#123; public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int[] res = new int[nums1.length]; for (int i = 0; i &lt; nums2.length; i++) map.put(nums2[i], i); for (int i = 0; i &lt; nums1.length; i++) &#123; int ind = -1; for (int j = map.get(nums1[i]) + 1; j &lt; nums2.length; j++) &#123; if (nums2[j] &gt; nums1[i]) &#123; ind = j; break; &#125; &#125; res[i] = ind == -1 ? -1 : nums2[ind]; &#125; return res; &#125;&#125; python实现：1234567891011121314class Solution(object): def nextGreaterElement(self, findNums, nums): map = &#123;&#125; res = [] for i in range(len(nums)): map.setdefault(nums[i], i) for i in range(len(findNums)): count = -1 for j in range(map.get(findNums[i]) + 1, len(nums)): if(nums[j] &gt; findNums[i]): count = j break res.append(-1 if count == -1 else nums[count]) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Island Perimeter]]></title>
    <url>%2F2017%2F10%2F19%2FleetCode%2FislandPerimeter%2F</url>
    <content type="text"><![CDATA[Island Perimeter原题：You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example [[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] Answer: 16Explanation: The perimeter is the 16 yellow stripes in the image below: 题目大意给出一个多维数组，为1的元素是岛屿，求岛屿的周长。 解题思路依次判断。代码实现（java）：12345678910111213141516171819202122class Solution &#123; public int islandPerimeter(int[][] grid) &#123; int w = grid.length; int h = grid[0].length; int res = 0; for (int i = 0; i &lt; w; i++)&#123; for (int j = 0; j &lt; h; j++)&#123; if(grid[i][j] == 1)&#123; if(i == 0 || grid[i - 1][j] == 0) res++; if(i == w - 1 || grid[i + 1][j] == 0) res++; if(j == 0 || grid[i][j - 1] == 0) res++; if(j == h - 1 || grid[i][j + 1] == 0) res++; &#125; &#125; &#125; return res; &#125;&#125; python实现：1234567891011121314151617class Solution(object): def islandPerimeter(self, grid): w = len(grid) h = len(grid[0]) res = 0 for i in range(w): for j in range(h): if grid[i][j] == 1: if j-1 &lt; 0 or grid[i][j-1] == 0: res += 1 if j+1 &gt;= h or grid[i][j+1] == 0: res += 1 if i-1 &lt; 0 or grid[i-1][j] == 0: res += 1 if i+1 &gt;= w or grid[i+1][j] == 0: res += 1 return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Reshape the Matrix]]></title>
    <url>%2F2017%2F10%2F19%2FleetCode%2FreshapeTheMatrix%2F</url>
    <content type="text"><![CDATA[Reshape the Matrix原题：In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data. You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were. If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example1 Input:nums =[[1,2], [3,4]]r = 1, c = 4Output:[[1,2,3,4]]Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. Example2 Input:nums =[[1,2], [3,4]]r = 2, c = 4Output:[[1,2], [3,4]]Explanation:There is no way to reshape a 2 2 matrix to a 2 4 matrix. So output the original matrix. Note The height and width of the given matrix is in range [1, 100]. The given r and c are all positive. 题目大意给出多维数组然后转换，不符合要求输出原数组。 解题思路两层循环。代码实现（java）：12345678910111213141516171819class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int w = nums.length, h = nums[0].length; if (w * h != r * c) return nums; int[][] res = new int[r][c]; int row = 0, col = 0; for (int i = 0; i &lt; w; i++) &#123; for (int j = 0; j &lt; h; j++) &#123; res[row][col] = nums[i][j]; col++; if (col == c) &#123; col = 0; row++; &#125; &#125; &#125; return res; &#125;&#125; 找规律，代码实现：123456789101112131415class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int w = nums.length; int h = nums[0].length; if (w * h == r * c) &#123; int[][] res = new int[r][c]; for (int i = 0; i &lt; r * c; i++) &#123; res[i / c][i % c] = nums[i / h][i % h]; &#125; return res; &#125; else &#123; return nums; &#125; &#125;&#125; python实现：12345678910111213141516class Solution(object): def matrixReshape(self, nums, r, c): w, h = len(nums), len(nums[0]) if w * h != r * c: return nums res = [] row = col = 0 for x in range(r): result = [] for y in range(c): result.append(nums[row][col]) col += 1 if col == h: row += 1 col = 0 res.append(result) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Fizz Buzz]]></title>
    <url>%2F2017%2F10%2F19%2FleetCode%2FfizzBuzz%2F</url>
    <content type="text"><![CDATA[Fizz Buzz原题：Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example n = 15,Return:[ “1”, “2”, “Fizz”, “4”, “Buzz”, “Fizz”, “7”, “8”, “Fizz”, “Buzz”, “11”, “Fizz”, “13”, “14”, “FizzBuzz”] 题目大意输入一个数，遍历的输出从1到这个数，遇到三的倍数输出“Fizz”，遇到5的倍数输出“Buzz”，遇到3和5共同的倍数输出“FizzBuzz”。 解题思路循环判断。代码实现（java）：123456789101112class Solution &#123; public List&lt;String&gt; fizzBuzz(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int i = 1; i &lt; n + 1; i++)&#123; if (i % 15 == 0) list.add("FizzBuzz"); else if (i % 3 == 0) list.add("Fizz"); else if (i % 5 == 0) list.add("Buzz"); else list.add(String.valueOf(i)); &#125; return list; &#125;&#125; AC后看到一位大神的代码，他是重写了AbstractList中的get方法，代码实现：123456789101112131415161718192021222324class Solution &#123; private int size = 0; private final List&lt;String&gt; fizzbuzzList = new AbstractList&lt;String&gt;() &#123; @Override public String get(int index) &#123; final int i = index + 1; return i % 15 == 0 ? "FizzBuzz" : i % 5 == 0 ? "Buzz" : i % 3 == 0 ? "Fizz" : String.valueOf(i); &#125; @Override public int size() &#123; return Solution.this.size; &#125; &#125;; public List&lt;String&gt; fizzBuzz(int n)&#123; this.size = n; return fizzbuzzList; &#125;&#125; python实现：123456789101112131415class Solution(object): def fizzBuzz(self, n): res = []; x = 1 while x &lt;= n: if x % 3 == 0 and x % 5 == 0: res.append("FizzBuzz") elif x % 3 == 0: res.append("Fizz") elif x % 5 == 0: res.append("Buzz") else: res.append(str(x)) x += 1 return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threadlocal--源码分析]]></title>
    <url>%2F2017%2F10%2F18%2Fjava%2FthreadLocal%2F</url>
    <content type="text"><![CDATA[Threadlocal详解这个类其实并不是一个线程，只是Thread的一个局部变量。看看官网的解释： 该类提供线程本地变量。这些变量与一般的变量不同，每个线程访问一个线程（通过get或set方法）有自己独立的变量初始化副本。 参数threadLocalHashCode每个对象都有一个HashCode来标示自己的唯一性1234567891011/** * ThreadLocals rely on per-thread linear-probe hash maps attached * to each thread (Thread.threadLocals and * inheritableThreadLocals). The ThreadLocal objects act as keys, * searched via threadLocalHashCode. This is a custom hash code * (useful only within ThreadLocalMaps) that eliminates collisions * in the common case where consecutively constructed ThreadLocals * are used by the same threads, while remaining well-behaved in * less common cases. */ private final int threadLocalHashCode = nextHashCode(); nextHashCode原子类保证线程安全，保证每个对象的hashcode唯一，并且是静态的123456/** * The next hash code to be given out. Updated atomically. Starts at * zero. */ private static AtomicInteger nextHashCode = new AtomicInteger(); HASH_INCREMENT是为了减少碰撞选定的这个值123456/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */ private static final int HASH_INCREMENT = 0x61c88647; nextHashCode()返回原始值，加上HASH_INCREMENT.为了让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table123456/** * Returns the next hash code. */ private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT); &#125; 方法initialValue123protected T initialValue() &#123; return null; &#125; 返回此线程局部变量的当前线程的初始值。返回值为null需要子类覆盖这个方法。 withInitial123public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) &#123; return new SuppliedThreadLocal&lt;&gt;(supplier); &#125; 创建线程局部变量。SuppliedThreadLocal类 get()123456789101112131415161718192021public T get() &#123; //获取当前线程t Thread t = Thread.currentThread(); //返回当前线程t的成员变量ThreadLocalMap ThreadLocalMap map = getMap(t); //map不为null，则获取以当前线程为key的ThreadLocalMap的Entry，如果e不为null，则直接返回该Entry的value； if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; //如果map为null或者e为null，返回setInitialValue()的值。setInitialValue()调用重写的initialValue()返回新值（如果没有重写initialValue将返回默认值null），并将新值存入当前线程的ThreadLocalMap（如果当前线程没有ThreadLocalMap，会先创建一个）。 return setInitialValue(); &#125; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; 返回该线程局部变量的当前线程的值复制。如果变量当前线程没有值，setInitialValue需要从初始化的地方取值。 setInitialValue初始化值的方法1234567891011121314151617private T setInitialValue() &#123; //调用重写的initialValue，返回新值 T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //当前线程的ThreadLocalMap不为空，则直接赋值 if (map != null) map.set(this, value); // 为当前线程创造一个ThreadLocalMap(this, firstValue)并赋初值，this为当前线程 else createMap(t, value); return value; &#125; void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; set12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; ThreadLocalMap下面看看ThreadLocal重要的内部类–ThreadLocalMapThreadLocalMap 是定义在 ThreadLocal 中的静态内部类，它是一种 Hash 的 Map，以 ThreadLocal 为 Key。但是 并不是用的继承自 Object 对象的 hashcode() 方法产生 hash 值 常量123456789101112131415161718192021222324/** * The initial capacity -- MUST be a power of two. */ //Map的初始容量 private static final int INITIAL_CAPACITY = 16; /** * The table, resized as necessary. * table.length MUST always be a power of two. */ //Entry类型的数组，用于存储数据 private Entry[] table; /** * The number of entries in the table. */ //表中的存储数目 private int size = 0; /** * The next size value at which to resize. */ //需要扩容时对应size的阈值。 private int threshold; // Default to 0 构造方法构造函数的第一个参数就是本ThreadLocal实例(this)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。注意一个细节，计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是2的指数，因为这可以使得hash发生冲突的次数减小。1234567ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; set123456789101112131415161718192021222324252627282930313233343536private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; 这里面解决冲突的方式和hashMap不同。如果key == null的话 替换当前的key和value。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; // Back up to check for prior stale entry in current run. // We clean out whole runs at a time to avoid continual // incremental rehashing due to garbage collector freeing // up refs in bunches (i.e., whenever the collector runs). int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // Find either the key or trailing null slot of run, whichever // occurs first for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // If we find key, then we need to swap it // with the stale entry to maintain hash table order. // The newly stale slot, or any other stale slot // encountered above it, can then be sent to expungeStaleEntry // to remove or rehash all of the other entries in run. if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // Start expunge at preceding stale entry if it exists if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // If we didn't find stale entry on backward scan, the // first stale entry seen while scanning for key is the // first still present in the run. if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // If key not found, put new entry in stale slot tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // If there are any other stale entries in run, expunge them if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); &#125; 该方法中会清理没用的entry,调用cleanSomeSlots方法实现的。123456789101112131415private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed; &#125; 总结1.线程间数据隔离（每个线程在自己线程里使用自己的局部变量，各线程间的ThreadLocal对象互不影响）；2.ThreadLocal的应用场景非常多，（获取数据库连接，各大框架都有应用，比如Spring）3.每个Thread里都含有一个ThreadLocalMap的成员变量；4.当应用线程池的时候，由于线程池的线程一般会复用，Thread不结束，这时候用完更需要remove了。5.对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Distribute Candies]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FdistributeCandies%2F</url>
    <content type="text"><![CDATA[Distribute Candies原题：Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. You need to return the sum of the points you could get in all the rounds. Example1 Input: candies = [1,1,2,2,3,3]Output: 3Explanation:There are three different kinds of candies (1, 2 and 3), and two candies for each kind.Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.The sister has three different kinds of candies. Example2 Input: candies = [1,1,2,3]Output: 2Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].The sister has two different kinds of candies, the brother has only one kind of candies. Note The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000]. 题目大意把不同种类的糖平均分两份，一份哥哥一份妹妹，求妹妹获得糖的最多种类数 解题思路求出糖的种类，如果种类大于糖数量的一半，则妹妹最多分的数量为糖数量的一半，否则为糖的种类两种实现（java）：代码实现（java）：1234567891011class Solution &#123; public int distributeCandies(int[] candies) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int candy : candies)&#123; set.add(candy); &#125; if (set.size() &gt; candies.length/2) return candies.length/2; return set.size(); &#125;&#125; 123456789class Solution &#123; public int distributeCandies(int[] candies) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int candy : candies)&#123; set.add(candy); &#125; return Math.min(set.size(), candies.length &gt;&gt; 1); &#125;&#125; python实现：123class Solution(object): def distributeCandies(self, candies): return min(len(set(candies)), len(candies) &gt;&gt; 1)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Baseball Game]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FbaseballGame%2F</url>
    <content type="text"><![CDATA[Baseball Game原题：You’re now a baseball game point recorder. Given a list of strings, each string can be one of the 4 following types: 1.Integer (one round’s score): Directly represents the number of points you get in this round.2.”+” (one round’s score): Represents that the points you get in this round are the sum of the last two valid round’s points.3.”D” (one round’s score): Represents that the points you get in this round are the doubled data of the last valid round’s points.4.”C” (an operation, which isn’t a round’s score): Represents the last valid round’s points you get were invalid and should be removed.Each round’s operation is permanent and could have an impact on the round before and the round after. You need to return the sum of the points you could get in all the rounds. Example1 Input: [“5”,”2”,”C”,”D”,”+”]Output: 30Explanation:Round 1: You could get 5 points. The sum is: 5.Round 2: You could get 2 points. The sum is: 7.Operation 1: The round 2’s data was invalid. The sum is: 5.Round 3: You could get 10 points (the round 2’s data has been removed). The sum is: 15.Round 4: You could get 5 + 10 = 15 points. The sum is: 30. Example2 Input: [“5”,”-2”,”4”,”C”,”D”,”9”,”+”,”+”]Output: 27Explanation:Round 1: You could get 5 points. The sum is: 5.Round 2: You could get -2 points. The sum is: 3.Round 3: You could get 4 points. The sum is: 7.Operation 1: The round 3’s data is invalid. The sum is: 3.Round 4: You could get -4 points (the round 3’s data has been removed). The sum is: -1.Round 5: You could get 9 points. The sum is: 8.Round 6: You could get -4 + 9 = 5 points. The sum is 13.Round 7: You could get 9 + 5 = 14 points. The sum is 27. Note The size of the input list will be between 1 and 1000. Every integer represented in the list will be between -30000 and 30000. 题目大意输入一组字符串：1.数字表示分数2.’+’表示当前轮次的分数等于上两轮分数之和3.’D’表示当前轮次的分数等于上一轮分数加倍4.’C’表示清除上一次的分数 解题思路根据不同的情况做判断，先想到了栈，然后又想到了数组。两种实现（java）：代码实现（java）：1234567891011121314151617181920212223class Solution &#123; public int calPoints(String[] ops) &#123; if (ops == null || ops.length == 0) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int res = 0; for (String op : ops)&#123; if ("C".equals(op))&#123; res -= stack.pop(); &#125;else if ("D".equals(op))&#123; stack.push(stack.peek() * 2); res += stack.peek(); &#125;else if ("+".equals(op))&#123; stack.push(stack.peek() + stack.get(stack.size()-2)); res += stack.peek(); &#125;else &#123; stack.push(Integer.valueOf(op)); res += stack.peek(); &#125; &#125; return res; &#125;&#125; 用栈实现运行时间11ms，用数组实现运行时间8ms，见代码：123456789101112131415161718192021222324252627class Solution &#123; public int calPoints(String[] ops) &#123; if (ops == null || ops.length == 0) return 0; int[] points = new int[ops.length]; int top = -1; int res = 0; for(String op : ops)&#123; if("C".equals(op))&#123; res -= points[top--]; &#125;else if("D".equals(op))&#123; int p = points[top]*2; points[++top] = p; res += p; &#125;else if("+".equals(op))&#123; int p = points[top] + points[top - 1]; points[++top] = p; res += p; &#125;else&#123; int p = Integer.parseInt(op); points[++top] = p ; res += p; &#125; &#125; return res; &#125;&#125; python实现：12345678910111213141516class Solution(object): def calPoints(self, ops): res = 0 points = [] top = -1 for op in ops: if op == "C": points.pop() elif op == "D": points.append(points[-1] * 2) elif op == "+": points.append(points[-1] + points[-2]) else: points.append(int(op)) return sum(points)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Reverse String]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FreverseString%2F</url>
    <content type="text"><![CDATA[Reverse String原题：Write a function that takes a string as input and returns the string reversed. Example Given s = “hello”, return “olleh”. 翻译相对简单，就是翻转一个字符串。 代码实现（java）：12345class Solution &#123; public String reverseString(String s) &#123; return new StringBuilder(s).reverse().toString(); &#125;&#125; 用StringBuilder的reverse()运行时间用了4ms。尝试用了异或位运算，用时减少了一倍，变为2ms，代码实现：12345678910111213141516class Solution &#123; public String reverseString(String s) &#123; char[] str = s.toCharArray(); int begin = 0; int end = s.length() - 1; while (begin &lt; end) &#123; str[begin] = (char) (str[begin] ^ str[end]); str[end] = (char) (str[begin] ^ str[end]); str[begin] = (char) (str[end] ^ str[begin]); begin++; end--; &#125; return new String(str); &#125;&#125; python实现：123class Solution(object): def reverseString(self, s): return s[::-1]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Reverse Words in a String III]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FreverseWords3%2F</url>
    <content type="text"><![CDATA[Reverse Words in a String III原题：Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example Input: “Let’s take LeetCode contest”Output: “s’teL ekat edoCteeL tsetnoc” NoteIn the string, each word is separated by single space and there will not be any extra space in the string. 翻译大意就是给定一个list输出每个单词的顺序原来不变，单词的顺序反转。 解题思路根据空格拆分，然后依次反转每个单词。代码实现（java）：1234567891011121314151617class Solution &#123; public String reverseWords(String s) &#123; String[] strs = s.split(" "); StringBuilder sb = new StringBuilder(); boolean t = true; for(String str : strs)&#123; String resWord = new StringBuilder(str).reverse().toString(); if(t)&#123; sb.append(resWord); t = false; &#125;else&#123; sb.append(" ").append(resWord); &#125; &#125; return sb.toString(); &#125;&#125; python实现：1234567class Solution(object): def reverseWords(self, s): list = s.split() k = [] for n in list: k.append(n[::-1]) return ' '.join(k)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Keyboard Row]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FkeyboardRow%2F</url>
    <content type="text"><![CDATA[Keyboard Row原题：Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. Example Input: [“Hello”, “Alaska”, “Dad”, “Peace”]Output: [“Alaska”, “Dad”] Note1.You may use one character in the keyboard more than once.2.You may assume the input string will only contain letters of alphabet. 翻译大意就是给定一个list输出单词都在同一行的单词。 解题思路设定每行代表一个数字初始值为0，遍历每个单词如果出现在某一行，则该代表该行的值赋为1.代码实现（java）：12345678910111213141516171819202122232425class Solution &#123; public String[] findWords(String[] words) &#123; String line1 = "QWERTYUIOP"; String line2 = "ASDFGHJKL"; String line3 = "ZXCVBNM"; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); for(String word : words)&#123; char[] ch = word.toUpperCase().toCharArray(); int n1 = 0, n2 = 0, n3 = 0; for(char c : ch)&#123; if(line1.indexOf(c) &gt;= 0) n1 = 1; if(line2.indexOf(c) &gt;= 0) n2 = 1; if(line3.indexOf(c) &gt;= 0) n3 = 1; if(n1 + n2 + n3 &gt; 1) break; &#125; if(n1 + n2 + n3 == 1) res.add(word); &#125; return res.toArray(new String[0]); &#125;&#125; python实现（遍历list中的每个单词放到set中判断set中的单词是否都包含在键盘行中）：12345678910class Solution(object): def findWords(self, words): keyBoards = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"] res = [] for word in words: wordUP = word.upper() for keyBoard in keyBoards: if set(wordUP).issubset(set(keyBoard)): res.append(word) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python内置函数--set]]></title>
    <url>%2F2017%2F10%2F16%2Fpython%2FpythonSet%2F</url>
    <content type="text"><![CDATA[描述set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。set 支持 x in set, len(set),和 for x in set。作为一个无序的集合，set不记录元素位置或者插入点。因此，set不支持 indexing, slicing（切片）, 或其它类序列（sequence-like）的操作。 语法set([iterable]) iterable– 可迭代对象 返回值返回新的集合对象。 实例使用12345x = set("facebook")y = set("google")print x, youtput: set(['a', 'c', 'b', 'e', 'f', 'k', 'o']) set(['e', 'o', 'g', 'l']) 交集(x &amp; y)12345x = set("facebook")y = set("google")print x &amp; youtput: set(['e', 'o']) 并集(x | y)12345x = set("facebook")y = set("google")print x | youtput: set(['a', 'c', 'b', 'e', 'g', 'f', 'k', 'l', 'o']) 差集(x - y)12345x = set("facebook")y = set("google")print x - youtput: set(['a', 'c', 'b', 'k', 'f']) 操作add把传入的元素做为一个整个添加到集合中12345x = set("facebook")x.add('vmlp')print xoutput: set(['a', 'c', 'b', 'e', 'f', 'k', 'o', 'vmlp']) update把传入的元素拆分，做为个体传入到集合中 （x |= y ,y只能是set ）12345x = set("facebook")x.update('vmlp')print xoutput: set(['a', 'c', 'b', 'e', 'f', 'k', 'm', 'l', 'o', 'p', 'v']) remove把传入的元素删除,如果不存在则引发 KeyError12345x = set("facebook")x.remove('o')print xoutput: set(['a', 'c', 'b', 'e', 'f', 'k']) 方法issubsetx.issubset(y)相当于 x &lt;= y测试是否x中的每一个元素都在y中12345x = set("book")y = set("booklalagood")print x.issubset(y)output: True issupersetx.issuperset(y)相当于 x &gt;= y测试是否t中的每一个元素都在x中(与issubset相反)12345x = set("book")y = set("booklalagood")print y.issubset(x)output: True unionx.union(y)相当于 x | y返回一个新的set包含x和y中的每一个元素12345x = set("book")y = set("booklalagood")print x.union(y)output: set(['a', 'b', 'd', 'g', 'k', 'l', 'o']) intersectionx.intersection(y)相当于 x &amp; y返回一个新的set包含x和y中的公共元素 differencex.difference(y)相当于 x - y返回一个新的set包含x中有但是y中没有的元素 differencex.symmetric_difference(y)相当于 x ^ y返回一个新的set包含x和y中不重复的元素 copyx.copy()返回set“x”的一个浅复制 intersection_updatex.intersection_update(y)相当于 x &amp;= y返回只保留含有set“y”中元素的set“x” difference_updatex.difference_update(y)相当于 x -= y返回删除了set“y”中含有的元素后的set“x” difference_updatex.symmetric_difference_update(y)相当于x ^= y返回含有 set“y”或者set“x”中有而不是两者都有的元素的set“x” discardx.discard(b)如果在set“x”中存在元素b,则删除 popx.pop()删除并且返回set“x”中的一个不确定的元素,如果为空则引发KeyError clearx.clear()删除set“x”中的所有元素]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python--切片]]></title>
    <url>%2F2017%2F10%2F16%2Fpython%2FpythonSlice%2F</url>
    <content type="text"><![CDATA[什么是切片？可以用方括号加一个下标的方式访问序列的每一个元素，或者通过在方括号中用冒号把开始下标和结束下标分开的方式访问一组连续的元素。序列类型是其元素被顺序放置的一种数据类型结构，这种方式允许通过指定下标的方式来获取某一个数据元素，或者通过指定下标范围来获得一组序列的元素。这种访问序列的方式叫做切片，我们通过切片操作符就可以实现这个操作。 切片操作符[]sequence[index]sequence是序列的名字，index是想要访问元素对应的偏移量。可以使用0到最大值，也可以使用负值。正索引以序列的开始为起点，负索引以序列的结束为起点。如图(引用): [:]sequence[start_index: end_index]通过这种方式可以得到起始索引到结束索引之间的数据。如果没有提供切片会从序列的最开始处开始，直到最末尾处结束。 [::]sequence[start_index: end_index: delta]delta变化量（步长），可以把这个参数当做for循环里的步长一样的东西。 注意: 列表切片产生的是列表的副本，与原列表不是同一份空间。 例子1定义一个列表 str = [1, 2, 3, 4, 5, 6, 7, 8] 12print str[3:] #截取第4个字符到结尾 output: [4, 5, 6, 7, 8] 12print str[:-3] #截取从头开始到倒数第三个字符之前output: [1, 2, 3, 4, 5] 12print str[2] #截取第三个字符 output: 3 12print str[-1] #截取倒数第一个字符 output: 8 12print str[::-1] #创造一个与原字符串顺序相反的字符串 output: [8, 7, 6, 5, 4, 3, 2, 1] 12print str[-3:-1] #截取倒数第三位与倒数第一位之前的字符 output: [6, 7] 12print str[-3:] #截取倒数第三位到结尾output: [6, 7, 8] 12print str[:-5:-3] #逆序截取output: [8, 5] 参考：《Python核心编程中文版（第二版）》]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <url>%2F2017%2F10%2F15%2Fjava%2FhashMap%2F</url>
    <content type="text"><![CDATA[HashMap基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。HashMap有两个参数影响其性能：初始容量和加载因子。默认初始容量是16，加载因子是0.75。容量是哈希表中桶(Entry数组)的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，通过调用resize方法将容量翻倍。本文是基于JDK1.8分析的，JDK 1.8中HashMap的实现有了一些改进，数据存储结构引进了红黑树，使得查询更加的快捷.JDK1.8 HashMap的结构： HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。1Map map = Collections.synchronizedMap(new HashMap()); 也可以使用ConcurrentHashMap。 定义12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 我们可以看出，HashMap继承了AbstractMap抽象类，实现了Map的方法。 属性1234567891011121314151617181920212223242526272829303132333435 //默认初始容量为16，必须为2的幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //最大容量为2的30次方 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; //链表转成红黑树的阈值 static final int TREEIFY_THRESHOLD = 8; //红黑树转为链表的阈值 static final int UNTREEIFY_THRESHOLD = 6; //存储方式由链表转成红黑树的容量的最小阈值 static final int MIN_TREEIFY_CAPACITY = 64; //存储元素的数组，总是2的幂次倍 transient Node&lt;k,v&gt;[] table; //存放具体元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; //存放元素的个数，注意这个不等于数组的长度。 transient int size; //每次扩容和更改map结构的计数器 transient int modCount; //临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; //加载因子 final float loadFactor; 构造方法HashMap有4个构造方法，有参的构造方法验证参数，无参的构造方法用默认的属性。下面我们主要介绍其中的两个构造方法（一）123456789101112public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; 返回目标容量对应的2的幂次方。123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; (二)将m中的所有元素添加至HashMap中1234public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 实现了putAll的操作，将m的所有元素存入本HashMap实例中。12345678910111213141516171819final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125; &#125; 主要方法hashkey的哈希值为数组下标12345static final int hash(Object key) &#123; int h; //右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; get返回指定key所映射的value；如果该键不包含任何映射关系，则返回null1234567891011121314151617181920212223242526272829public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //table不为null，长度大于0，根据hash寻找table中的项也不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //检查第一个节点 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; //为红黑树结点 if (first instanceof TreeNode) //在红黑树中查找 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //否则，在链表中查找 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; put在学习put方法之前先看一下内部类Node123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; Node类是HashMap中内部定义的一个单向链表。Node中存储了key的hash值，键值对，同时还有下一个链表元素。我们重点关注一下equals这个方法，当我们算出的key的hash值相同时，put方法并不会报错，而是继续向这个hash值的链表中添加元素。我们会调用equals方法来比对key和value是否相同，如果equals方法返回false，会继续向链表的尾部添加一个键值对。JDK1.8中引入了红黑树内部类为TreeNode，（由于本人对红黑树不是很了解，后期会补上这部分）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //table未初始化或者长度为0，进行扩容（详见resize方法） if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //根据长度-1和hash值进行按位与运算，算出hash值对应于数组中的位置，从tab中将这个位置上面的内容取出，判断为null时，在这个位置新增一个Node。 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //key存在，覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //如果冲突节点达到8个，调用treeifyBin(tab, hash)，这个treeifyBin首先会去判断当前hash表的长度，如果不足64的话，实际上就只进行resize，扩容table，如果已经达到64，那么才会将冲突项存储结构改为红黑树。 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //如果有相同的hash和key，则退出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //将p调整为下一个节点 p = e; &#125; &#125; //若e不为null，表示已经存在与待插入节点hash、key相同的节点，hashmap后插入的key值对应的value会覆盖以前相同key值对应的value值，就是下面这块代码实现的 if (e != null) &#123; // existing mapping for key V oldValue = e.value; //判断是否修改已插入节点的value if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //超过阀值，扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; resize(扩容)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //如果老的数组容量大于0，首先判断是否大于等于HashMap的最大容量， //如果true，将阈值设置为Integer的最大值，同时数组容量不变 if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //如果扩容后的数组容量小于我们规定的最大数组容量，而且老的数组容量大于等于16， //对数组进行扩容，扩容后的数组容量为原来的两倍；同时阈值也扩容为原来的两倍（左移一位实现） else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; //之前table大小不大于0,而且老的阈值大于0，则新的容量=老的阈值 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; //老的阈值=0，容量和阈值都初始化为默认值，即16和12 else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //如果新的阈值为0，为新的阈值赋值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) //定义一个新的容量的数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //如果老的数组不为空，遍历老的数组 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; //如果链表中只有一个数据，直接重新计算hash值，放入新的数组中 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; //如果e是红黑树，需要将红黑树拆分后放入新的数组中 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 链表优化重hash的代码块 else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; //原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; JDK1.8做了优化： 我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 总结其他方法和上面介绍的方法原理基本一致，有兴趣的同学可以自行查看源码。(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。(3) JDK1.8引入红黑树大程度优化了HashMap的性能。 参考：http://www.importnew.com/20386.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Two Sum II - Input array is sorted]]></title>
    <url>%2F2017%2F10%2F14%2FleetCode%2FtwoSum2%2F</url>
    <content type="text"><![CDATA[Two Sum II - Input array is sorted原题：Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. 翻译大意是给出一个数组（升序）和一个目标数，求数组中的两个数相加正好等于目标数的两个元素的下标 解题思路left代表左下标，right代表右下标，numbers[left] + numbers[right]如果等于target返回两个下标志分别加一，如果大于target，right左移，否则left右移。代码实现（java）：12345678910111213141516class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int left = 0; int right = numbers.length - 1; while(right &gt; left)&#123; int res = numbers[left] + numbers[right]; if(res == target) return new int[]&#123;left + 1, right + 1&#125;; else if(res &lt; target) left++; else right--; &#125; return null; &#125;&#125; 代码实现（python）：12345678910111213class Solution(object): def twoSum(self, numbers, target): left = 0 right = len(numbers) - 1 while(right &gt; left): res = numbers[left] + numbers[right] if res == target: return left + 1, right + 1 elif res &lt; target: left += 1 else: right -= 1 return null]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Add Digits]]></title>
    <url>%2F2017%2F10%2F11%2FleetCode%2FaddDigits%2F</url>
    <content type="text"><![CDATA[Add Digits原题Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. 翻译大概意思就是给你一个数，把这个数的各个位上的数相加，得到一个新的数，重复下去直到最后相加出来的数为个位数为止。 解题思路：我最开始想的是把每位上的数取出来相加，然后利用递归去做，直到得到符合的答案，原题要求不用循环和递归用O(1)的时间复杂度求出结果，很显然这不符合的。然后想到找规律，发现num%9符合规律，测试发现9%9的时候出现问题，于是改成（num－1）％9+1，代码实现（java）：123public int addDigits(int num) &#123; return (num - 1) % 9 + 1; &#125; 代码实现（python）：1234def addDigits(self, num): if(num == 0): return 0 return (num - 1) % 9 + 1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Array Partition I]]></title>
    <url>%2F2017%2F10%2F11%2FleetCode%2FarrayPartition1%2F</url>
    <content type="text"><![CDATA[Array Partition I原题Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example Input: [1,4,3,2] Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = &gt;min(1, 2) + min(3, 4). 翻译大概意思就是给定一个长度为2n的数组，分成n个小组，返回每组中较小值的和sum，使sum尽量大 解题思路：要取sum为最大值，分组的话就要把两个大的数分在一起，然后以此类推，所以先把数组排序，依次把下标为偶数位的值相加即为所求值。代码实现（java）：1234567public int arrayPairSum(int[] nums) &#123; Arrays.sort(nums); int res = 0; for(int i = 0; i &lt; nums.length; i += 2) res += nums[i]; return res; &#125; 发现有很多大神的代码执行时间更少，发现他们用的排序算法是计数排序。每隔一个数进行相加：代码实现（python）：12345678def arrayPairSum(self, nums): if isinstance(nums, list) and len(nums) == 0: return 0 nums.sort() res = 0 for i in range(0, len(nums), 2): res += nums[i] return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Judge Route Circle]]></title>
    <url>%2F2017%2F10%2F10%2FleetCode%2FjudgeRouteCircle%2F</url>
    <content type="text"><![CDATA[Judge Route Circle原题Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle. Example Input: “UD”Output: true Input: “LL”Output: false 翻译大概意思就是起点为（0，0），R(右),L(左),U(上)和D(下).给定一串移动的串，判断最后是否回到原点。 解题思路：这是一个横纵坐标移动的问题，向左移动x–，向右x++，向上y++，向下y–，最后判断 x == 0 &amp;&amp; y == 0即可。代码实现（java）：1234567891011121314151617181920212223242526public boolean judgeCircle(String moves) &#123; if(moves == null || "".equals(moves)) return true; int x = 0; int y = 0; for(int i = 0; i&lt;moves.length(); i++)&#123; char c = moves.charAt(i); switch(c)&#123; case 'U': y++; break; case 'D': y--; break; case 'L': x--; break; case 'R': x++; break; &#125; &#125; if(x == 0 &amp;&amp; y == 0) return true; return false; &#125; 也可以判断给定的字符串中UD和LR是否成对的出现。代码实现（python）：12def judgeCircle(self, moves): return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D')]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread源码分析]]></title>
    <url>%2F2017%2F10%2F10%2Fjava%2Fthread%2F</url>
    <content type="text"><![CDATA[什么是线程？线程可以理解为在进程中独立运行的子任务。线程是CPU调度的最基本单元。线程的资源开销相对于进程的开销是相对较少的，所以我们一般创建线程执行，而不是进程执行。java中要创建一个线程可以继承Thread类和实现Runnable接口。 注意：多线程是异步的。 下面我们来看一下Thread类的源码。12publicclass Thread implements Runnable 从上面的代码中可以看到，Thread实现了Runnable接口，它们之间具有多态关系。创建一个线程可以继承thread类或者实现Runnable接口，这两种创建方式在工作时性质是一样的，没有本质区别。 线程是一个子任务，cpu以不确定的时间来调用线程中的run方法。 native关键字简介1234private static native void registerNatives(); static &#123; registerNatives(); &#125; native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（Java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。不过，对Java外部的调用通常不能移植到其他平台，在applet中还可能引发安全异常。实现本地代码将使您的Java应用程序无法通过100%纯Java测试。但是，如果必须执行本地调用，则要考虑几个准则： 将您的所有本地方法都封装到一个类中，这个类调用单个的DLL。对每一种目标操作系统平台，都可以用特定于适当平台的版本的DLL。这样可以将本地代码的影响减少到最小，并有助于将以后所需要的移植问题考虑在内。 本地方法尽量简单。尽量使您的本地方法对第三方（包括Microsoft）运行时DLL的依赖减少到最小。使您的本地方法尽量独立，以将加载您的DLL和应用程序所需的开销减少到最小。如果需要运行时DLL，必须随应用程序一起提供。 变量name12//线程名，volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。使得该变量是线程间可见的。private volatile String name; priority12//线程执行优先级private int priority; single_step12//是否单独执行此线程private boolean single_step; daemon12//线程是否是守护线程private boolean daemon = false; stillborn12//虚拟机状态 private boolean stillborn = false; target12//实际的线程任务 private Runnable target; group12//这个线程的组 private ThreadGroup group; contextClassLoader12//这个线程的上下文类加载器 private ClassLoader contextClassLoader; inheritedAccessControlContext12//这个线程的继承 private AccessControlContext inheritedAccessControlContext; threadInitNumber12//所有初始化线程的数目 private static int threadInitNumber; threadLocals &amp; inheritableThreadLocals123//这是为ThreadLocal类维护的一些变量ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; stackSize12//此线程请求的堆栈大小，如果创建者未指定堆栈大小，则为0。虚拟机可以用这个数字来做任何喜欢的事情一些虚拟机将忽略它。 private long stackSize; nativeParkEventPointer12//本地线程终止后仍然存在的JVM私有状态。 private long nativeParkEventPointer; tid &amp; threadSeqNumber123//线程id相关private long tid;private static long threadSeqNumber; threadStatus12//线程状态，初始化为指示线程尚未启动private volatile int threadStatus = 0; blocker12//在可中断的I / O操作（如果有）中阻塞此线程的对象。在设置此线程的中断状态后，应调用阻塞程序的中断方法。private volatile Interruptible blocker; 线程优先级12345678//线程为最低优先级。 public final static int MIN_PRIORITY = 1; //分配给线程的默认优先级。 public final static int NORM_PRIORITY = 5; //线程拥有最高优先级 public final static int MAX_PRIORITY = 10; native方法123456789101112131415161718192021222324252627282930313233//返回对当前正在执行的线程对象的引用。 public static native Thread currentThread(); //使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了 public static native void yield();//当前正在执行的线程（this.currentThread()）休眠（暂停执行）指定的毫秒数，这取决于系统定时器和调度程序的精度和准确性。线程不会丢失monitors。public static native void sleep(long millis) throws InterruptedException;//通过C代码初始化线程需要的系统资源。 private native void start0();//强制停止一个线程（不建议使用） @Deprecated public final synchronized void stop(Throwable obj) //只是设置中断标志 private native void interrupt0(); //检查一个线程是否处于活动状态。（活动状态指已经启动且尚未终止） public final native boolean isAlive(); //暂停线程 private native void suspend0(); //重新激活一个线程 private native void resume0(); //设置线程优先级 private native void setPriority0(int newPriority);//放弃当前cpu资源，让给其他任务（但是放弃的时间不确定） public static native void yield(); 构造方法Thread有好8个构造方法，最终都是调用这个辅助构造函数。接下来我们就来详细的看看init方法到底是怎么来初始化线程的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 初始化线程 * * @param g 线程组 * @param target run（）方法被调用的对象 * @param name 新线程的name * @param stackSize 新线程所需的堆栈大小，零表示此参数将被忽略。 * @param acc AccessControlContext继承，或AccessController.getContext（）为null * @param inheritThreadLocals 如果&#123;@code true&#125;，继承初始值来自构造线程的可继承线程 */private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; if (name == null) &#123; throw new NullPointerException("name cannot be null"); &#125; this.name = name; //当前线程就是该线程的父线程 Thread parent = currentThread(); //获取系统的安全管理器 SecurityManager security = System.getSecurityManager(); if (g == null) &#123; //security不为null时，线程所在group为security的group if (security != null) &#123; g = security.getThreadGroup(); &#125; //security为null时，使用父线程的group if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; //确定当前运行的线程是否有权限修改此线程组。 g.checkAccess(); //检查权限 if (security != null) &#123; if (isCCLOverridden(getClass())) &#123; security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); &#125; &#125; g.addUnstarted(); //将线程组、守护线程、优先级等设置为父线程的对应属性 this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); //从父线程继承可继承的ThreadLocal if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); //设置该线程堆栈大小 this.stackSize = stackSize; //设置线程id tid = nextThreadID(); &#125; 主要方法启动start12345678910111213141516171819202122232425//线程启动方法public synchronized void start() &#123; //当前线程初始化还未做好，不能start，0-&gt;NEW状态 if (threadStatus != 0) throw new IllegalThreadStateException(); //通知group该线程即将启动，group的nUnstartedThreads减1,nthreads加1 group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; //启动不成功，group设置当前线程启动失败 if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125; &#125; 启动线程其实做了这么几件事： 检查线程是否初始化； 通知group，线程启动； 调用native方法start0()启动线程，启动后执行run()方法； 启动失败容错处理。 run123456@Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 真正的run其实是目标类的run方法,target实际上要保存的是一个Runnable接口的实现的引用。 停止停止一个线程可以用Thread.stop()方法，但最好不要使用它。因为这个方法是不安全的。（可能使一些清理性的工作得不到完成，对锁定的对象进行“解锁”，出现数据不一致。） stop12345678910111213141516171819//强制线程停止执行。（不建议使用） @Deprecatedpublic final void stop() &#123; SecurityManager security = System.getSecurityManager(); if (security != null) &#123; checkAccess(); if (this != Thread.currentThread()) &#123; security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION); &#125; &#125; // A zero status value corresponds to "NEW", it can't change to // not-NEW because we hold the lock. if (threadStatus != 0) &#123; resume(); // Wake up thread if it was suspended; no-op otherwise &#125; // The VM can handle all thread states stop0(new ThreadDeath()); &#125; interrupt1234567891011121314public void interrupt() &#123; if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125; &#125; interrupt0(); &#125; interrupt()方法只是在当前线程中打了一个停止标记，并不是真的停止了线程。 interrupted &amp; isInterrupted123456789//测试当前线程是否已经中断(线程的中断状态由该方法清除)public static boolean interrupted() &#123; return currentThread().isInterrupted(true); &#125;//测试线程是否中断（不清除线程的中断状态） public boolean isInterrupted() &#123; return isInterrupted(false); &#125; 几种停止线程的方法 可以通过判断当前线程是否中断，如果是中断抛出异常去停止一个线程。 可以在sleep（）状态下停止线程。 interrupt()方法和return结合使用。 比较建议使用“抛异常”的方法实现停止线程，因为在catch中可以对异常进行相关的处理，而且使用异常处理能更好、更方便的控制程序的运行流程。 暂停线程暂停线程意味着此线程还可以恢复运行。在java中可以使用suspend()方法暂停线程，使用resume()方法恢复线程。 suspend123456//暂停一个线程（不推荐使用）依靠本地方法suspend0，可能会造成死锁和不同步@Deprecated public final void suspend() &#123; checkAccess(); suspend0(); &#125; resume123456//重新激活一个线程（不推荐使用）依靠本地方法resume0，可能会造成死锁和不同步@Deprecated public final void resume() &#123; checkAccess(); resume0(); &#125; join123456789101112131415161718192021222324public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125; &#125; join会锁住当前线程，等待子线程结束之后继续执行。如图: 其他方法exit1234567891011121314//由系统调用，可以使Thread在销毁前释放资源private void exit() &#123; if (group != null) &#123; group.threadTerminated(this); group = null; &#125; target = null; /* Speed the release of some of these resources */ threadLocals = null; inheritableThreadLocals = null; inheritedAccessControlContext = null; blocker = null; uncaughtExceptionHandler = null; &#125; checkAccess1234567//确定当前运行的线程是否有权限修改此线程。public final void checkAccess() &#123; SecurityManager security = System.getSecurityManager(); if (security != null) &#123; security.checkAccess(this); &#125; &#125; dumpStack1234//将当前线程的堆栈跟踪打印到标准错误流。此方法仅用于调试。public static void dumpStack() &#123; new Exception("Stack trace").printStackTrace(); &#125; 还有一些方法没有看到，就不一一概述了。 线程的状态Thread中有个状态枚举： NEW：初始状态，线程被构建，还未调用start()方法； RUNNABLE：运行状态，在java多线程模型中，就绪和运行都是运行状态； BLOCKED：阻塞状态； WAITING：等待状态，比如中断，需要其他的线程来唤醒； TIME_WAITING：超时等待，可以在指定的时间内自行返回； TERMINATED：终止状态，线程执行完毕。 java层次的状态转换图 操作系统层次的状态转换图 总结wait()和notify/notifyAll()线程中常用wait()和notify/notifyAll()方法，这是Object类中的方法。 wait()线程进入WAITING状态，并且释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁，等待其他线程调用“锁标志“对象的notify或notifyAll方法恢复wait方法是一个本地方法，其底层是通过一个叫做监视器锁的对象来完成的，所以调用wait方式时必须获取到monitor对象的所有权即通过Synchronized关键字，否则抛出IllegalMonitorStateException异常 notify &amp; notifyAll()在同一对象上去调用notify/notifyAll方法，就可以唤醒对应对象monitor上等待的线程了。notify和notifyAll的区别在于前者只能唤醒monitor上的一个线程，对其他线程没有影响，而notifyAll则唤醒所有的线程 线程复用像线程池类高效的原因在于，线程池中的线程在完成任务后，不会销毁，而且缓存起来，每当用户请求一个线程处理任务时，线程池可以利用缓存的空闲线程来处理用户任务，这样避免了线程创建销毁带来的开销。在Thread类中有一个Runnable target的域，只需将target替换成新的Runnable即可。后续会写一些线程池相关的文章。 更深入学习Thread类中有许多native方法，更深入的学习后续还需研究研究jvm的源码。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Valid Palindrome]]></title>
    <url>%2F2017%2F10%2F09%2FleetCode%2FvalidPalindrome%2F</url>
    <content type="text"><![CDATA[原题Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example, “A man, a plan, a canal: Panama” is a palindrome.“race a car” is not a palindrome. 翻译：给定一个字符串，判断其是否为一个回文串。只包含字母和数字，忽略大小写。 解题思路利用首尾指针，找到符合条件的索引，进行比较，符合条件进行下一组比较，不相等返回false，直到所有的字母都处理完。 代码实现java实现，时间复杂度O(n).12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public Boolean solution(String str)&#123; if(str == null || "".equals(str)) return true; str = str.toLowerCase(); int left = 0; int right = str.length() - 1; while (left &lt; right) &#123; char leftChar = str.charAt(left); char rightChar = str.charAt(right); while (!isValid(leftChar))&#123; left++; leftChar = str.charAt(left); if (left &gt;= right) return true; &#125; while (!isValid(rightChar))&#123; right--; rightChar = str.charAt(right); if (right &lt;= left) return true; &#125; if (leftChar != rightChar) return false; left++; right--; &#125; return true; &#125; private Boolean isValid(Character character)&#123; if (Character.isLetterOrDigit(character)) return true; return false; &#125;&#125; python实现1234567891011121314151617181920212223242526272829303132333435class Solution: def palindrome(self, str): if str.strip() == "": return True str = str.lower() left = 0 right = len(str) - 1 while(left &lt; right): leftStr = str[left] rightStr = str[right] while(not self.__isvalid(leftStr)): left += 1 leftStr = str[left] if(left &gt;= right): return True while(not self.__isvalid(rightStr)): right -= 1 rightStr = str[right] if(right &lt;= left): return True if(leftStr != rightStr): return False left += 1 right -= 1 def __isvalid(self, str): if(str.isalnum()): return True return Falseif __name__=="__main__": str = "A man, a plan, a canal: Panama" solution = Solution() print solution.palindrome(str)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2017%2F10%2F08%2Fjava%2FinnerClass%2F</url>
    <content type="text"><![CDATA[内部类可以将一个类的定义放在另一个类的定义内部，这就是内部类。内部类是一种非常有用的特性，因为它允许把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。然而，内部类和组合式完全不同的概念。 创建内部类1234567891011121314151617public class Outer &#123; class Inner &#123; private String str; Inner(String str) &#123; this.str = str; &#125; &#125; public Inner to(String str)&#123; return new Inner(str); &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Inner inner = outer.to("hello"); &#125;&#125; 编译后的class文件如下：123456789101112131415161718192021public class Outer &#123; public Outer() &#123; &#125; public Outer.Inner to(String str) &#123; return new Outer.Inner(str); &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Outer.Inner inner = outer.to("hello"); &#125; class Inner &#123; private String str; Inner(String str) &#123; this.str = str; &#125; &#125;&#125; 如果想从外部类的非静态方法之外的的任意位置创建某个内部类的对象，那么必须具体的指明这个对象的类型：OuterClassName.InnerClassName。（由虚拟机完成） 使用.this和.new如果需要生成对外部类对象的引用可以使用.this。这样产生的引用自动的具有正确的类型，这一点在编译期就被检查并完成，因此在运行期时并没有任何开销。1234567891011121314151617181920public class DotThis &#123; void f()&#123; System.out.println("f()"); &#125; public class Inner&#123; public DotThis outer()&#123; return DotThis.this; &#125; &#125; public Inner inner()&#123; return new Inner(); &#125; public static void main(String[] args) &#123; DotThis dotThis = new DotThis(); Inner inner = dotThis.inner(); inner.outer().f(); &#125;&#125; 如果要告知某些其他对象，去创建某个内部类对象。需要使用.new关键字。12345678public class DotNew &#123; public class Inner&#123; &#125; public static void main(String[] args) &#123; DotNew dotNew = new DotNew(); Inner inner = dotNew.new Inner(); &#125;&#125; 再拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会连接到创建它的外部类对象上。但是如果创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。 匿名内部类12345678910111213public class Parcel &#123; public interface Contents&#123; int value(); &#125; public Contents contents()&#123; return new Contents()&#123; private int i = 11; public int value()&#123; return i; &#125; &#125;; &#125;&#125; 简化形式：123456789101112131415public class Parcelb &#123; public interface Contents&#123; int value(); &#125; class MyContents implements Contents&#123; @Override public int value() &#123; return 0; &#125; &#125; public Contents contents()&#123; return new MyContents(); &#125;&#125; 注意：在jdk1.7及以前，如果一个匿名内部类使用其外部定义的对象，该对象需要使用final修饰，不然会得到一个编译期错误，但是jdk1.8这个final关键字由虚拟机默认加上了。 嵌套类如果不需要内部类对象与其外部类对象之间有联系，可以将内部类声明为static，通常称为嵌套类。想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式的保存了一个引用，指向创建它的外部类对象。当内部类是static时：1、创建嵌套类的对象，并不需要其外围类的对象。2、不能从嵌套类的对象中访问非静态的外围类对象。嵌套类和普通内部类还有一个区别。普通内部类不能包含static数据和字段，也不能包含嵌套类。但是嵌套类可以包含所有这些。1234567891011121314public interface ClassInInterface &#123; void h(); class Test implements ClassInInterface&#123; @Override public void h() &#123; System.out.println("h"); &#125; public static void main(String[] args) &#123; new Test().h(); &#125; &#125;&#125; 以上代码虚拟机在编译之后会把类修饰成static。内部类被嵌套多少层都可以访问所有它所嵌入的外部类的所有成员。 为什么使用内部类每个内部类都能独立的继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。这样的话就可以利用内部类实现类似于c++的多重继承。 使用内部类，还可以获得其他的一些特性：1、内部类可以有多个实例，没个实例都有自己的状态信息，并且与外部类的状态信息相互独立。2、在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。3、创建内部类对象的时刻并不依赖于外部类对象的创建。4、内部类就是一个独立的实体。闭包、回调，和控制框架中都有内部类的身影。 内部类的继承因为内部类的构造器必须连接到指向外部类对象的引用，所以在继承内部类的时候，指向外部类对象的引用必须被初始化。1234567891011public class InnerExtends &#123; class WithInnter&#123; class Inner&#123;&#125; &#125; public class InheritInner extends WithInnter.Inner&#123; public InheritInner(WithInnter withInnter) &#123; withInnter.super(); &#125; &#125;&#125; 内部类的重载这块还没看到，以后找时间补上。参考：《java编程思想》]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode题解]]></title>
    <url>%2F2017%2F10%2F01%2FleetCodeList%2F</url>
    <content type="text"><![CDATA[leetCode是一个非常值得学习的网站，以下是本人近期刷leetCode的总结，里面的代码都是AC通过的，该博文会持续更新。PS：最近突然发现leetcode有中文版的了，以后的更新会都基于中文版，并且刚开始打算学习golang，代码的实现部分会有go的实现版本。 804. 唯一摩尔斯密码词(Unique Morse Code Words)771. Jewels and Stones766. Toeplitz Matrix728. Self Dividing Numbers717. 1-bit and 2-bit Characters696. Count Binary Substrings695. Max Area of Island693. Binary Number with Alternating Bits682. Baseball Game669. Trim a Binary Search Tree657. Judge Route Circle653. Two Sum IV - Input is a BST637. Average of Levels in Binary Tree617. Merge Two Binary Trees606. Construct String from Binary Tree598. Range Addition II575. Distribute Candies566. Reshape the Matrix561. Array Partition I557. Reverse Words in a String III538. Convert BST to Greater Tree521. Longest Uncommon Subsequence I520. Detect Capital500. Keyboard Row496. Next Greater Element I492. Construct the Rectangle485. Max Consecutive Ones476. Number Complement463. Island Perimter461. Hamming Distance453. Minimum Moves to Equal Array Elements448. Find All Numbers Disappeared in an Array412. Fizz Buzz404. Sum of Left Leaves389. Find the Difference387. First Unique Character in a String383. Ransom Note371. Sum of Two Integers349. Intersection of Two Arrays344. Reverse String292. Nim Game283. Move Zeroes258. Add Digits237. Delete Node in a Linked List226. Invert Binary Tree206. Reverse Linked List171. Excel Sheet Column Number169. Majority Element167. Two Sum II - Input array is sorted136. Single Number125. Valid Palindrome122. Best Time to Buy and Sell Stock II104. Maximum Depth of Binary Tree88. Merge Sorted Array4. Median of Two Sorted Arrays1. Two Sum]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Two Sum]]></title>
    <url>%2F2017%2F09%2F30%2FleetCode%2FtwoSum%2F</url>
    <content type="text"><![CDATA[Two Sum原题：Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 翻译：给定一个整数数组，返回两个数字的索引，使它们相加到一个特定的目标。你可以假设每个输入都只有一个解决方案，而你可能不会使用相同的元素两次。 解决思路：第一种可以用两层循环（时间复杂度O(n^2)），实现代码：123456789public int[] twoSum1(int[] tmp, int target) &#123; for (int i = 0; i &lt; tmp.length; i++)&#123; for (int j = i + 1; j &lt; tmp.length; j++)&#123; if (tmp[i] + tmp[j] == target) return new int[]&#123;i, j&#125;; &#125; &#125; throw new IllegalArgumentException("don't have two sum equals target"); &#125; 第二种可以定义一个map然后把数组的值作为key，索引作为value存到map中，循环数组，每次循环用目标值减去该值，用结果作为key去map中查找，找到了返回索引数组，没找到把该次和循环的值和索引作为key和value存入map中，直到找到结果。（时间复杂度O(n)）实现：1234567891011public int[] twoSum(int[] tmp, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i&lt;tmp.length; i++)&#123; int m = target - tmp[i]; if (map.containsKey(m)) &#123; return new int[] &#123; map.get(m), i &#125;; &#125; map.put(tmp[i], i); &#125; throw new IllegalArgumentException("No two sum solution"); &#125; python实现最近也在学习python，附上python的实现（第二种方案）:1234567891011121314151617class Solution: def twoSum(self, nums, target): map = &#123;&#125; i = 0 for x in nums: if target - x in map: return i,map[target - x] print str(x) + " " + str(i) map[x] = i print map i += 1 returnif __name__=="__main__": a = [5, 4, 9, 3, 7] solution = Solution() print solution.twoSum(a, 10)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2017%2F09%2F29%2Fjava%2FarrayList%2F</url>
    <content type="text"><![CDATA[ArrayListList接口的可调整大小的数组实现。实现所有可选列表操作，并允许所有元素，包括null。除了实现List接口之外，该类还提供了一些方法来操作在内部使用来存储列表的数组的大小。 （这个类大致相当于Vector，除了它是不同步的。）size，isEmpty，get，set，iterator和listIterator操作在常量运行。添加操作以摊销的常数运行，即添加n个元素需要O（n）个时间。所有其他操作都以线性时间运行（粗略地说）。与LinkedList实现相比，常数因子较低。每个ArrayList实例都有一个容量。容量是用于存储列表中的元素的数组的大小。它总是至少与列表大小一样大。当元素被添加到ArrayList时，其容量会自动增长。增长政策的细节不包括增加元素具有不变的摊销时间成本的事实。在使用ensureCapacity操作添加大量元素之前，应用程序可以增加ArrayList实例的容量。这可能会减少增量重新分配的数量。arrayList是线程非安全的。如果要实现线程安全，可以： List list = Collections.synchronizedList(new ArrayList(…)); 使用Iterator去遍历arrayList，如果列表在迭代器创建之后的任何时间被结构化地修改，除了通过迭代器自己的remove或add方法之外，都会抛出一个ConcurrentModificationException，下面这段代码中，因为在iterator创建之后调用了ArrayList的remove方法，所以会抛出异常。12345Iterator iterator = list.iterator(); while (iterator.hasNext())&#123; list.remove(0); iterator.remove(); &#125; ArrayList的实现：12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList几个比较重要的常量：1234/** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; 默认初始容量为10。为什么定义为10？官网上没有给出解释，带着这个疑问我Google了一下，这个默认初始容量可以为任意正整数，为1太少，肯定会做一些大小的调整，100会浪费掉空间，前辈们肯定是做了性能分析和空间分析取出了中间值。1234/** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 用于空实例的共享空数组实例。123456/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 一个空数组实例，当用户没有指定 ArrayList 的容量时(即调用无参构造函数)，返回的是该数组==&gt;刚创建一个 ArrayList 时，其内数据量为 0。当用户第一次添加元素时，该数组将会扩容，变成默认容量为10(DEFAULT_CAPACITY)的一个数组===&gt;通过ensureCapacityInternal()实现，它与 EMPTY_ELEMENTDATA 的区别就是：该数组是默认返回的，而后者是在用户指定容量为0时返回。12345678/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. * */transient Object[] elementData; // non-private to simplify nested class access 存储ArrayList元素的数组缓冲区。ArrayList的容量是此数组缓冲区的长度。任何空的ArrayList elementData的值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA（就是一个空数组）当第一个元素被添加的时候，elementData会扩大到DEFAULT_CAPACITY（也就是10）注意：一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。transient关键字用来用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。ArrayList在序列化的时候会调用writeObject，直接将size和element写入ObjectOutputStream；反序列化时调用readObject，从ObjectInputStream获取size和element，再恢复到elementData。为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。12345/** * The size of the ArrayList (the number of elements it contains). * @serial */ private int size; ArrayList的大小（包含的元素数）。12345678910111213141516171819202122232425262728293031323334353637383940private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; 构造方法ArrayList一共有三个构造方法：123456789101112131415161718/** * Constructs an empty list with the specified initial capacity. * 构造一个指定长度的空列表 * @param initialCapacity the initial capacity of the list * 列表的初始容量 * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; 第一个构造方法主要用于构造一个指定长度的空列表，参数为需要构造列表的初始容量，在这里我们看到当initialCapacity == 0 的时候 elementData = EMPTY_ELEMENTDATA 123456/** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 第二个构造方法构造一个初始容量为10的空list。1234567891011121314151617181920/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) //如果返回值不是Object[]转为Object[] elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 第三个构造方法则将传入的集合转成数组赋值给elementData,如果为空则赋值为上面的共享空数组实例（EMPTY_ELEMENTDATA）。 主要方法接下来看一看ArrayList的主要方法（方法太多就不一一介绍了，有兴趣的同学可以自己看看一源码）：123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 返回指定元素在list中第一次出现的位置。需要注意的是当传入的值为null时并不会报错，因为null也可以作为元素插入ArrayList,查询方式为循环依次查找。如果没有匹配到返回-1。123456789101112public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 与indexOf同理，不过lastIndexOf方法的查找方式为从后向前查找。1234567891011public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; 对原有arrayList实例的浅拷贝。123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; 返回一个新的Object数组，对该数组操作不会影响原有list12345678910@SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; 该方法是传入一个泛型数组a,当a.length&lt;size时，按照list的size创建一个新的数组返回，数组中包含所有list的元素。如果a.length&gt;=size时，则将 list 中的元素按顺序存入 a 中，然后a[list.size] = null, a[list.size + 1] 及其后的元素依旧是 a 的元素,附上测试代码：12345678910public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("a"); list.add("b"); list.add("c"); String[] s = new String[5]; s[0] = "0";s[1] = "1";s[2] = "2";s[3] = "3";s[4] = "4"; String[] c = list.toArray(s); System.out.println(c.length +" " + c[0] + " " + c[1] + " " + c[2] + " " + c[3] + " " + c[4]); &#125; 输出：5 a b c null 4请注意这句话 Make a new array of a’s runtime type, but my contents创建一个新的数组的运行时类型，就是说返回的并不一定是Object[],而是运行时的类型，为什么会出现这种情况呢？原因很简单，因为由于继承的原因，我们父类实例的具体类型，实际上是取决于在 new 时，我们所使用的子类类型。12345public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; 返回指定位置的元素。rangeCheck method: 该方法判断了如果index &gt;= size 则throw一个 IndexOutOfBoundsExceptionelementData method：返回在索引为 index 的元素，主要是避免每次取值都需要强转（看到这里不得不佩服前辈们，要是我自己来写目前肯定封装的不会这么好）1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; 该方法是在指定索引处插入指定元素，并把被替换的元素返回。12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code //防止溢出 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //这里的oldCapacity &gt;&gt; 1相当于 oldCapacity/2 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; add方法就是向list末尾添加数据，但是这时候要考虑容量问题。ensureCapacityInternal方法：若 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 即{}，则取 minCapacity 为 默认容量和参数 minCapacity 之间的最大值。 这里需要介绍一下modCount变量，他是父类AbstractList中的变量主要用于记录arrayList结构变化&gt;的次数，每变化一次增加1.拥有这个参数的方法都是线程不安全的，在一个迭代器初始的时候会赋予它调&gt;用这个迭代器的对象的mCount，如何在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存&gt;储的mcount不一样那就抛异常 grow方法:增加容量以确保它至少能够容纳最小容量参数指定的元素数。如果扩容后大于最大存储容量,则调用hugeCapacity方法，MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8（为什么是Integer.MAX_VALUE - 8呢？只是为了避免一些机器内存溢出，最大长度依然是Integer.MAX_VALUE，并不是Integer.MAX_VALUE-8） 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 在该列表中的指定位置插入指定的元素。将当前位于该位置的元素（如果有）和任何后续元素（向其索引添加一个）移动。1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 移除指定索引位置的元素：index 之后的所有元素依次左移一位 12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; 移除指定的一个元素，索引位置最低的。123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 删除此列表的所有元素。 12345678public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; 将一个集合的所有元素顺序添加到list末尾。12345678910111213141516public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 从指定的位置开始将指定集合中的所有元素插入到此列表中。将当前处于该位置的元素（如果有的话）和随后的任何元素移动到右边（增加其索引）。新元素将按照指定集合的迭代器返回的顺序显示在列表中。123456789101112131415161718192021222324252627282930313233public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; 移除list中和c中共有的元素。1234public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; 保留list中和c中共有的元素。 总结1、ArrayList基于数组实现，其内存储元素的数组为elementData2、ArrayList中EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY._ELEMENTDATA虽然都是空数组，但是使用场景不同。前者是通过ArrayList(int initialCapacity)该构造方法直接指定初试容量为0时，后者是用户直接使用无参构造创建ArrayList时。3、ArrayList的扩容计算为newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 且扩容并非是无限制的，有内存限制、虚拟机限制。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO + github 创建自己的个人博客]]></title>
    <url>%2F2017%2F09%2F24%2FhexoBlog%2F</url>
    <content type="text"><![CDATA[hexo + github 创建自己的个人博客最近想搞一个自己的博客，写一些自己平时工作中的积累，终于搭好了，写一下搭建博客的过程。hexo是一款基于Node.js的静态博客框架,所以安装node.js是必须的（这个就不写了，node官网下载，安装）。申请GitHub（必须）作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 安装hexonode和git安装好后创建一个文件夹blog，安装hexo： sudo npm install -g hexo 执行init命令初始化hexo: hexo init 生成静态页面: hexo generate（hexo g也可以） 配置github建立Repository 建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联，我的blog在本地/user/local/bin/blog，blog是我之前建的东西也全在这里面，有： _config.yml node_modules public source db.json package.json scaffolds themes 现在我们需要_config.yml文件，来建立关联，命令： vi _config.yml 翻到最下面，改成我这样子的 deploy: type: git repo: https://github.com/yougithub/youname.github.io.git branch: master repo也可以写成yougithubname:youpassword@https://github.com/yougithub/youname.github.io.git注意所有的：后面都有一个空格。 生成添加秘钥在终端（Terminal）输入： ssh-keygen -t rsa -C “Github的注册邮箱地址” 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入https://github.com/settings/ssh： 将复制的内容粘贴到Key的输入框，随便写好Title里面的内容，点击Add SSH key按钮即可。可以本地启动服务进行预览，命令： hexo server (hexo s 也可以) 浏览器输入localhost:4000 每次部署的步骤，可按以下三步来进行。 hexo clean hexo generate(hexo g) hexo deploy(hexo d) 参考：http://www.jianshu.com/p/465830080ea9http://www.jianshu.com/p/e99ed60390a8 标签页／分类页 参考：http://theme-next.iissnan.com/theme-settings.html#syntax-highlight-scheme 头像／logo 参考：http://cherryblog.site/Hexo-high-level-tutorialcloudmusic,bg-customthemes-statistical.html 站内搜索 参考：https://zetaoyang.github.io/post/2016/07/08/hexo-localsearch.html]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>

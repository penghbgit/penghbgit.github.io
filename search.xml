<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ransom Note]]></title>
    <url>%2F2017%2F11%2F17%2FleetCode%2FransomNote%2F</url>
    <content type="text"><![CDATA[Ransom Note原题：Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note You may assume that both strings contain only lowercase letters. canConstruct(“a”, “b”) -&gt; falsecanConstruct(“aa”, “ab”) -&gt; falsecanConstruct(“aa”, “aab”) -&gt; true 题目大意给两个字符串，第二个字符串要包含第一个字符串的所有字母，每个字母只能用一次（忽略大小写）。 解题思路利用数组统计每次字母出现的次数，然后进行比较。代码实现（java）：1234567891011121314class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; int[] words = new int[26]; for(int i = 0; i &lt; magazine.length(); i++)&#123; words[magazine.charAt(i) - 'a']++; &#125; for(int i = 0; i &lt; ransomNote.length(); i++)&#123; if(--words[ransomNote.charAt(i) - 'a'] &lt; 0) return false; &#125; return true; &#125;&#125; python实现：python用collections.Counter类统计字符个数，然后比较即可。12345678910111213141516171819from collections import Counterclass Solution(object): def canConstruct(self, ransomNote, magazine): """ :type ransomNote: str :type magazine: str :rtype: bool """ if ransomNote == '': return True if magazine == '': return False ransomNoteCount = Counter(ransomNote) magazineCount = Counter(magazine) for i in ransomNoteCount.keys(): if None == magazineCount.get(i) or ransomNoteCount[i] &gt; magazineCount.get(i): return False else: return True]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intersection of Two Arrays]]></title>
    <url>%2F2017%2F11%2F17%2FleetCode%2FintersectionOfTwoArrays%2F</url>
    <content type="text"><![CDATA[Intersection of Two Arrays原题：Given two arrays, write a function to compute their intersection. Example1 Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note Each element in the result must be unique. The result can be in any order. 题目大意给两个数组，求两个数组的交集，顺序可以随便，但是结果中的元素唯一。 解题思路解题思路有很多，这里自己看代码吧，不做解释了。代码实现（java）：1234567891011121314151617181920212223class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i = 0; i &lt; nums1.length; i++)&#123; set.add(nums1[i]); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; nums2.length; i++)&#123; if(set.contains(nums2[i]))&#123; list.add(nums2[i]); set.remove(nums2[i]); &#125; &#125; int[] res = new int[list.size()]; for(int i = 0; i &lt; list.size(); i++)&#123; res[i] = list.get(i); &#125; return res; &#125;&#125; python实现：12345678class Solution(object): def intersection(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] """ return list(set(nums1) &amp; set(nums2))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock II]]></title>
    <url>%2F2017%2F11%2F16%2FleetCode%2FbestTimetoBuyAndSellStockII%2F</url>
    <content type="text"><![CDATA[Best Time to Buy and Sell Stock II原题：Say you have an array for which the i^th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题目大意假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。设计一个算法来找到最大的利润。你可以完成尽可能多的交易(多次买卖股票)。然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。 解题思路运用贪心算法，每次把比前一个大的差值都加入结果中。代码实现（java）：123456789101112class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices == null || prices.length == 0) return 0; int res = 0; for(int i = 1; i &lt; prices.length; i++)&#123; if(prices[i] &gt; prices[i - 1]) res += prices[i] - prices[i - 1]; &#125; return res; &#125;&#125; python实现：123456789101112class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ res = 0 for i in range(1, len(prices)): c = prices[i] - prices[i - 1] if c &gt; 0: res += c return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum Moves to Equal Array Elements]]></title>
    <url>%2F2017%2F11%2F16%2FleetCode%2FminimumMovestoEqualArrayElements%2F</url>
    <content type="text"><![CDATA[Minimum Moves to Equal Array Elements原题：Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Example1 Input:[1,2,3] Output:3 Explanation:Only three moves are needed (remember each move increments two elements): [1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] Note The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won’t exceed 10,000. 题目大意给定一个数组，每次把n-1个数字＋1，问最少多少次所有的元素能相等。 解题思路n－1个元素＋1相当于微加一的数字减1，答案就是所有元素与最小值的差值的和。代码实现（java）：123456789101112131415class Solution &#123; public int minMoves(int[] nums) &#123; int min = Integer.MAX_VALUE; for(int i : nums)&#123; min = Math.min(min, i); &#125; int res = 0; for(int i : nums)&#123; res += i - min; &#125; return res; &#125;&#125; python实现：1234567class Solution(object): def minMoves(self, nums): """ :type nums: List[int] :rtype: int """ return sum(nums) - len(nums)*min(nums)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Range Addition II]]></title>
    <url>%2F2017%2F11%2F16%2FleetCode%2FrangeAdditionII%2F</url>
    <content type="text"><![CDATA[Range Addition II原题：Given an m * n matrix M initialized with all 0’s and several update operations. Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 &lt;= i &lt; a and 0 &lt;= j &lt; b. You need to count and return the number of maximum integers in the matrix after performing all the operations. Example1 Input:m = 3, n = 3operations = [[2,2],[3,3]]Output: 4Explanation:Initially, M =[[0, 0, 0], [0, 0, 0], [0, 0, 0]] After performing [2,2], M =[[1, 1, 0], [1, 1, 0], [0, 0, 0]] After performing [3,3], M =[[2, 2, 1], [2, 2, 1], [1, 1, 1]] So the maximum integer in M is 2, and there are four of it in M. So return 4. Note The range of m and n is [1,40000]. The range of a is [1,m], and the range of b is [1,n]. The range of operations size won’t exceed 10,000. 题目大意输入m＊n的数组，operations数组里面的是这个范围内的数字增加1，求最大值的数量。 解题思路如果ops为空结果为m*n，不为空即为ops中最小值的乘积。代码实现（java）：1234567891011121314class Solution &#123; public int maxCount(int m, int n, int[][] ops) &#123; if(ops == null || ops.length == 0) return m*n; int a = Integer.MAX_VALUE, b = Integer.MAX_VALUE; for (int i = 0; i &lt; ops.length; i++)&#123; a = Math.min(ops[i][0], a); b = Math.min(ops[i][1], b); &#125; return a*b; &#125;&#125; python实现：1234567891011121314151617class Solution(object): def maxCount(self, m, n, ops): """ :type m: int :type n: int :type ops: List[List[int]] :rtype: int """ if not ops: return m*n a = 40000 b = 40000 for i in range(len(ops)): a = min(a, ops[i][0]) b = min(b, ops[i][1]) return a*b]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Construct the Rectangle]]></title>
    <url>%2F2017%2F11%2F16%2FleetCode%2FconstructTheRectangle%2F</url>
    <content type="text"><![CDATA[Construct the Rectangle原题：For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements: The area of the rectangular web page you designed must equal to the given target area. The width W should not be larger than the length L, which means L &gt;= W. The difference between length L and width W should be as small as possible. You need to output the length L and the width W of the web page you designed in sequence. Example1 Input: 4Output: [2, 2]Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2. Note The given area won’t exceed 10,000,000 and is a positive integer The web page’s width and length you designed must be positive integers. 题目大意给定一个数字area，求L*M=area，并且L和M的差值最小。 解题思路得到area的开根数，然后循环，如果遇到能整除的，除数和商就是解。代码实现（java）：123456789101112class Solution &#123; public int[] constructRectangle(int area) &#123; int l = 0, w = 0; for(int i = 1; i &lt;= (int)Math.sqrt(area); i++)&#123; if(area % i == 0)&#123; l = area/i; w = i; &#125; &#125; return new int[]&#123;l, w&#125;; &#125;&#125; python实现：123456789class Solution(object): def constructRectangle(self, area): sqrt = int(math.sqrt(area)) l, w = area, 1 for x in range(sqrt, 0, -1): if area % x == 0: l, w = area / x, x break return [l, w]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Move Zeroes]]></title>
    <url>%2F2017%2F11%2F15%2FleetCode%2FmoveZeroes%2F</url>
    <content type="text"><![CDATA[Move Zeroes原题：Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note You must do this in-place without making a copy of the array. Minimize the total number of operations. 题目大意给定一个数组 里面有0和非0的数，把所有非0的数都移动到前面，0移到后面。 解题思路定义一个标记count，依次移动非0的数，最后剩余长度补0.代码实现（java）：1234567891011121314class Solution &#123; public void moveZeroes(int[] nums) &#123; int length = nums.length; int count = 0; for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] != 0) nums[count++] = nums[i]; &#125; while(count &lt; length) nums[count++] = 0; &#125;&#125; python实现：12345678910class Solution(object): def moveZeroes(self, nums): count = 0 for i in range(len(nums)): if(nums[i] is not 0): nums[count] = nums[i] count += 1 for i in range(count, len(nums)): nums[i] = 0]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel Sheet Column Number]]></title>
    <url>%2F2017%2F11%2F15%2FleetCode%2FexcelSheetColumnNumber%2F</url>
    <content type="text"><![CDATA[Excel Sheet Column Number原题：Given a column title as appear in an Excel sheet, return its corresponding column number. Example1 A -&gt; 1 B -&gt; 2 C -&gt; 3 … Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 题目大意相当于要把字符串转int，26进制转10进制，不过A是从1开始的。 解题思路按进制转换的思路做，A－&gt;1,AA-&gt; 26*1+1。代码实现（java）：123456789101112class Solution &#123; public int titleToNumber(String s) &#123; if(s.length() == 0 || s == null) return -1; int sum = 0; for (int i = 0; i &lt; s.length(); i++)&#123; sum = 26*sum + s.charAt(i)-'A' + 1; &#125; return sum; &#125;&#125; python实现：12345678910class Solution(object): def titleToNumber(self, s): """ :type s: str :rtype: int """ sum = 0 for c in s: sum = sum*26 + ord(c) - ord('A') + 1 return sum]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Employee Importance]]></title>
    <url>%2F2017%2F11%2F05%2FleetCode%2FemployeeImportance%2F</url>
    <content type="text"><![CDATA[Employee Importance原题：You are given a data structure of employee information, which includes the employee’s unique id, his importance value and his direct subordinates’ id. For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct. Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates. Example1 Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1Output: 11Explanation:Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11. Note One employee has at most one direct leader and may have several subordinates. The maximum number of employees won’t exceed 2000. 题目大意题目意思就是题目自定了一个数据结构，第一个值为id，第二个值为权重，第三个值为下属。一个公司每个人对应一个数据结构，给你一个人的id，让你返回他以及他的所有下属的权重和。 解题思路第一种思路：把id作为key把员工对象作为value，放在map对象中，利用递归求和。第二种思路：还是利用map，借助一个链表结构活着也可以是一个队列或者栈进行进栈和出栈操作。代码实现（java）：1234567891011121314151617181920212223242526272829303132/*// Employee infoclass Employee &#123; // It's the unique id of each node; // unique id of this employee public int id; // the importance value of this employee public int importance; // the id of direct subordinates public List&lt;Integer&gt; subordinates;&#125;;*/class Solution &#123; public int getImportance(List&lt;Employee&gt; employees, int id) &#123; Map&lt;Integer, Employee&gt; map = new HashMap&lt;&gt;(); for(Employee employee : employees)&#123; map.put(employee.id, employee); &#125; return dfs(map, id); &#125; private int dfs(Map&lt;Integer, Employee&gt; map, int id)&#123; int res = 0; Employee cur = map.get(id); res += cur.importance; for(int subId : cur.subordinates)&#123; res += dfs(map, subId); &#125; return res; &#125;&#125; 123456789101112131415161718192021222324252627282930313233/*// Employee infoclass Employee &#123; // It's the unique id of each node; // unique id of this employee public int id; // the importance value of this employee public int importance; // the id of direct subordinates public List&lt;Integer&gt; subordinates;&#125;;*/class Solution &#123; public int getImportance(List&lt;Employee&gt; employees, int id) &#123; Map&lt;Integer, Employee&gt; map = new HashMap&lt;&gt;(); for(Employee employee : employees)&#123; map.put(employee.id, employee); &#125; int res = 0; LinkedList&lt;Employee&gt; list = new LinkedList&lt;&gt;(); list.add(map.get(id)); while (!list.isEmpty())&#123; Employee employee = list.poll(); res += employee.importance; for (int i : employee.subordinates)&#123; list.add(map.get(i)); &#125; &#125; return res; &#125;&#125; python实现：123456789101112131415161718192021222324"""# Employee infoclass Employee(object): def __init__(self, id, importance, subordinates): # It's the unique id of each node. # unique id of this employee self.id = id # the importance value of this employee self.importance = importance # the id of direct subordinates self.subordinates = subordinates"""class Solution(object): def getImportance(self, employees, id): """ :type employees: Employee :type id: int :rtype: int """ map = &#123;employee.id: employee for employee in employees&#125; def dfs(id): importance = sum([dfs(id) for id in map[id].subordinates]) return importance + map[id].importance return dfs(id)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Trim a Binary Search Tree]]></title>
    <url>%2F2017%2F11%2F04%2FleetCode%2FtrimABinarySearchTree%2F</url>
    <content type="text"><![CDATA[Trim a Binary Search Tree原题：Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree. Example1 Example2 题目大意给定一个数求这个数的补数，补数就是这个数的二进制数，从最高的第一个1起开始翻转。之前的0不翻转。 解题思路利用位运算求出来共有多少位需要翻转，y-1就是所有需要翻转的位数都为1的一个值，然后进行异或运算。代码实现（java）：1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode trimBST(TreeNode root, int L, int R) &#123; TreeNode res = null; if(root == null) return null; if(root.val &lt;= R &amp;&amp; root.val &gt;= L)&#123; root.left = trimBST(root.left, L, R); root.right = trimBST(root.right, L, R); res = root; &#125; if(root.val &lt; L) res = trimBST(root.right, L, R); if(root.val &gt; R) res = trimBST(root.left, L, R); return res; &#125;&#125; python实现：123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def trimBST(self, root, L, R): """ :type root: TreeNode :type L: int :type R: int :rtype: TreeNode """ if not root: return root if root.val &lt; L: return self.trimBST(root.right, L, R) if root.val &gt; R: return self.trimBST(root.left, L, R) root.left = self.trimBST(root.left, L, R) root.right = self.trimBST(root.right, L, R) return root]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Number Complement]]></title>
    <url>%2F2017%2F11%2F04%2FleetCode%2FnumberComplement%2F</url>
    <content type="text"><![CDATA[Number Complement原题：Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Example1 Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example2 Input: 1Output: 0Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. Note The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation. 题目大意给定一个数求这个数的补数，补数就是这个数的二进制数，从最高的第一个1起开始翻转。之前的0不翻转。 解题思路利用位运算求出来共有多少位需要翻转，y-1就是所有需要翻转的位数都为1的一个值，然后进行异或运算。代码实现（java）：1234567891011class Solution &#123; public int findComplement(int num) &#123; int x = num, y = 1; while(x != 0)&#123; x = x &gt;&gt; 1; y = y &lt;&lt; 1; &#125; return num^(y-1); &#125;&#125; python实现：123456789101112class Solution(object): def findComplement(self, num): """ :type num: int :rtype: int """ x = num y = 1 while x is not 0: x = x &gt;&gt; 1 y = y &lt;&lt; 1 return num^(y - 1)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Merge Two Binary Trees]]></title>
    <url>%2F2017%2F11%2F04%2FleetCode%2FmergeTwoBinaryTrees%2F</url>
    <content type="text"><![CDATA[Merge Two Binary Trees原题：Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example Note The merging process must start from the root nodes of both trees. 题目大意合并两棵二叉树，把相同结点上的数字相加组成新的结点值。 解题思路利用递归，把相同位置的结点相加。代码实现（java）：123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if(t1 == null) return t2; if(t2 == null) return t1; t1.left = mergeTrees(t1.left, t2.left); t1.right = mergeTrees(t1.right, t2.right); t1.val += t2.val; return t1; &#125;&#125; python实现：12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def mergeTrees(self, t1, t2): """ :type t1: TreeNode :type t2: TreeNode :rtype: TreeNode """ if t1 is None: return t2 if t2 is None: return t1 t1.left = self.mergeTrees(t1.left, t2.left) t1.right = self.mergeTrees(t1.right, t2.right) t1.val += t2.val return t1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Hamming Distance]]></title>
    <url>%2F2017%2F11%2F04%2FleetCode%2FhammingDistance%2F</url>
    <content type="text"><![CDATA[Hamming Distance原题：The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Example Input: x = 1, y = 4Output: 2Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑The above arrows point to positions where the corresponding bits are different. Note 0 ≤ x, y &lt; 2^31. 题目大意求两个数字的汉明距离（汉明距离就是两个数字的二进制相异的位的总数）。 解题思路两种解题思路，一种就是都转成二进制树，然后循环遍历，这里就不贴代码了，第二种就是利用位运算，异或然后&amp;1就能算出来汉明距离。代码实现（java）：123456789class Solution &#123; public int hammingDistance(int x, int y) &#123; int res = 0, e = x ^ y; for(int i = 0; i &lt; 32; i++)&#123; res += (e&gt;&gt;i) &amp; 1; &#125; return res; &#125;&#125; python实现：12345678910111213class Solution(object): def hammingDistance(self, x, y): """ :type x: int :type y: int :rtype: int """ e = x ^ y res = 0 for i in range(0, 31): res += (e &gt;&gt; i) &amp; 1 return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树--java实现]]></title>
    <url>%2F2017%2F11%2F03%2Falgorithm%2FbinaryTree%2F</url>
    <content type="text"><![CDATA[前一段时间看jdk1.8中的hashmap源码的时候发现应用到了红黑树，想补一下红黑树的知识，这里先介绍一下二叉搜索树的结构。如果有不正确的地方欢迎指正～～ 什么是二叉搜索树二叉搜索树又名二叉查找树和二叉排序树。二叉搜索树是以一棵二叉树来组织的，如下图所示，这样的一棵树可以使用链表的数据结构来表示，每一个结点就是一个对象。每个结点包含key（值），left（左孩子），right（右孩子）和p（双亲）。如果某个孩子结点和父结点不存在，则相应属性值为NIL。根结点是树中唯一父结点指针为NIL的结点。 设x是二叉搜索树中的一个结点。如果y是x的左子树结点那么y.key&lt;=x.key。如果y是x的右子树结点，那么y.key&gt;=x.key。 定义介绍完了，下面就来看看二叉搜索树的基本操作。 java实现123456789101112131415161718192021222324252627public class BinaryTree&lt;K extends Comparable&lt;K&gt;&gt;&#123; static final class TreeNode&lt;K&gt;&#123; //结点中的值 K key; //左孩子 TreeNode&lt;K&gt; left; //右孩子 TreeNode&lt;K&gt; right; //父结点 TreeNode&lt;K&gt; p; TreeNode(K key) &#123; this(key, null, null, null); &#125; TreeNode(K key, TreeNode&lt;K&gt; left, TreeNode&lt;K&gt; right, TreeNode&lt;K&gt; p) &#123; this.key = key; this.left = left; this.right = right; this.p = p; &#125; &#125; //根结点 private TreeNode&lt;K&gt; root;&#125; 插入非递归操作。1234567891011121314151617181920212223242526272829303132public void insert(K k)&#123; //创建结点 TreeNode&lt;K&gt; treeNode = new TreeNode&lt;&gt;(k); if (root == null) root = treeNode; else &#123; //当前结点 TreeNode&lt;K&gt; currentNode = root; TreeNode&lt;K&gt; parent = null; int b; //查找结点插入位置 while (currentNode != null)&#123; //记录父结点 parent = currentNode; //比较结点值 b = k.compareTo(currentNode.key); if(b &lt; 0) currentNode = currentNode.left; else currentNode = currentNode.right; &#125; //找到位置后和父结点比较，插入 b = k.compareTo(parent.key); treeNode.p = parent; if (b &lt; 0) parent.left = treeNode; else parent.right = treeNode; &#125; &#125; 递归操作。12345678910111213141516public void insertRecursion(K k)&#123; insertRec(k, root); &#125; private TreeNode&lt;K&gt; insertRec(K k, TreeNode&lt;K&gt; x)&#123; if(x==null) return new TreeNode&lt;K&gt;(k); int b = k.compareTo(x.key); if(b &lt; 0) x.left = insertRec(k, x.left); else if(b &gt; 0) x.right = insertRec(k, x.right); return x; &#125; 查寻非递归操作。1234567891011121314151617public TreeNode&lt;K&gt; search(K k)&#123; //从根结点开始查找 TreeNode&lt;K&gt; currentNode = root; int b; //循环判断结点值是否相等 while (currentNode != null &amp;&amp; currentNode.key != k)&#123; b = k.compareTo(currentNode.key); //当前结点值赋为左结点 if (b &lt; 0) currentNode = currentNode.left; //当前结点值赋为右结点 else currentNode = currentNode.right; &#125; return currentNode; &#125; 递归操作。12345678910111213141516private TreeNode&lt;K&gt; s(TreeNode&lt;K&gt; x, K k)&#123; if (x==null) return x; int cmp = k.compareTo(x.key); if (cmp &lt; 0) return s(x.left, k); else if (cmp &gt; 0) return s(x.right, k); else return x; &#125; public TreeNode&lt;K&gt; searchRecursion(K k) &#123; return s(root, k); &#125; 最大值和最小值最大值一定在结点的右子树中。最小值一定在结点的左子树中。12345678910111213public TreeNode&lt;K&gt; min(TreeNode&lt;K&gt; x)&#123; while (x != null)&#123; x = x.left; &#125; return x; &#125; public TreeNode&lt;K&gt; max(TreeNode&lt;K&gt; x)&#123; while (x != null)&#123; x = x.right; &#125; return x; &#125; 前驱和后继结点的前驱：是该结点的左子树中的最大结点。结点的后继：是该结点的右子树中的最小结点。12345678910111213141516171819202122232425262728293031public TreeNode&lt;K&gt; predecessor(TreeNode&lt;K&gt; x)&#123; //如果x结点的左子树不为空，则左子树中的最大值即为前驱结点 if (x.left != null) return max(x.left); //如果x没有左孩子。则有两种可能： //1.x是一个右孩子，则x的前驱结点为它的父结点。 //2.x是一个左孩子，则查找x的最低的父结点，并且该父结点要具有右孩子，找到的这个最低的父结点就是x的前驱结点。 TreeNode&lt;K&gt; parent = x.p; while (parent != null &amp;&amp; parent.left == x)&#123; x = parent; parent = parent.p; &#125; return parent; &#125; public TreeNode&lt;K&gt; successor(TreeNode&lt;K&gt; x)&#123; //如果x结点的右子树不为空，则右子树中的最小值即为后继结点 if (x.right != null) return min(x.right); //如果x没有右孩子。则有两种可能： //1.x是一个左孩子，则x的后继结点为它的父结点。 //2.x是一个右孩子，则查找x的最低的父结点，并且该父结点要具有左孩子，找到的这个最低的父结点就是x的后继结点。 TreeNode&lt;K&gt; parent = x.p; while (parent != null &amp;&amp; parent.right == x)&#123; x = parent; parent = parent.p; &#125; return parent; &#125; 遍历二叉搜索树允许通过一个简单的递归算法按顺序输出二叉搜索树的所有元素。 先序遍历若二叉树非空，则执行以下操作：1.访问根结点；2.先序遍历左子树；3.先序遍历右子树。1234567891011public void preinorder()&#123; preinorder(root); &#125; private void preinorder(TreeNode&lt;K&gt; x)&#123; if (x != null)&#123; System.out.print(x.key + " "); preinorder(x.left); preinorder(x.right); &#125; &#125; 中序遍历若二叉树非空，则执行以下操作：1.中序遍历左子树；2.访问根结点；3.中序遍历右子树。1234567891011public void inorder()&#123; inorder(root); &#125; private void inorder(TreeNode&lt;K&gt; x)&#123; if (x != null)&#123; inorder(x.left); System.out.print(x.key + " "); inorder(x.right); &#125; &#125; 后序遍历若二叉树非空，则执行以下操作：1.后序遍历左子树；2.后序遍历右子树；3.访问根结点。1234567891011public void postinorder()&#123; postinorder(root); &#125; private void postinorder(TreeNode&lt;K&gt; x)&#123; if (x != null)&#123; postinorder(x.left); postinorder(x.right); System.out.print(x.key + " "); &#125; &#125; 删除从一棵二叉搜索树中删除一个结点x的整个策略分为三种情况：1.如果z没有孩子结点，那么只是简单的将它删除，并修改它的父结点用null来作为孩子来替换x。2.如果z只有一个孩子，那么将这个孩子提升到树中z的位置并修改z的父结点用x的孩子来替换x。3.如果z有两个孩子，那么z的后继y（一定在z的右子树中），并让y占据树中z的位置。z的原来右子树部分部分成为y的新的右子树，并且z的左子树成为y的新的左子树。如图所示： 为了再二叉搜索树中移动子树，定义一个子过程transplant，它是用另一棵子树替换一棵子树并成为其双亲结点的孩子结点。当transplant用一棵以v为根的子树来替换一棵以u为根的子树时，结点u的双亲变为结点v的双亲，并且最后v成为u的双亲的相应孩子。transplant没有处理v.left和v.right的更新；这些更新由transplant的调用者处理。123456789101112131415161718192021222324252627282930313233343536373839404142434445private void transplant(TreeNode&lt;K&gt; u, TreeNode&lt;K&gt; v)&#123; //u是根的情况 if(u.p == null) root = v; //如果u是一个左孩子，对u.p.left进行更新 else if (u == u.p.left) u.p.left = v; //如果u是一个右孩子，对u.p.right进行更新 else u.p.right = v; //如果v非null更新v.p if (v != null) v.p = u.p; &#125; private void delete(TreeNode&lt;K&gt; z)&#123; //没有左孩子 if (z.left == null) transplant(z, z.right); //有左孩子但是没有右孩子 else if (z.right == null) transplant(z, z.left); //有两个孩子的情况 else &#123; //查找后继结点 TreeNode&lt;K&gt; y = min(z.right); //如果y不是z的左孩子，将y移除原来的位置，并替换树中的z if (y.p != z)&#123; //用y的右孩子替换y并成为y的双亲的一个孩子 transplant(y, y.right); //将z的右孩子转为y的右孩子 y.right = z.right; y.right.p = y; &#125; //如果y是z的右孩子，用y替换z并成为z的双亲的孩子，用z的左孩子替换y的左孩子 transplant(z, y); y.left = z.left; y.left.p = y; &#125; &#125; public void remove(K k)&#123; delete(search(k)); &#125; 总结1.如果x是一棵有n个结点子树的根，那么遍历的这棵树需要O(n)时间。2.在一棵高度为h的二叉搜索树上，动态集合上的操作search，min，max，successor，predecessor可以在O(h)时间内完成。3.在一棵高度为h的二叉搜索树上，实现动态的集合操作insert和remove的运行时间均为O(h)。 参考《算法导论》第三版 本文为原创文章，如需转载请注明出处。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadPoolExecutor源码分析（JDK1.8）]]></title>
    <url>%2F2017%2F11%2F02%2Fjava%2FthreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[为什么使用线程池合理利用线程池能够带来三个好处。1.降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。2.提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。3.提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 java中如何创建线程池简要类图关系 Executor: 是Java线程池的超级接口；提供一个execute(Runnable command)方法;我们一般用它的继承接口ExecutorService。ExecutorService: 是一个比Executor使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回Future的方法AbstractExecutorService: ExecutorService执行方法的默认实现ScheduledExecutorService: 一个可定时调度任务的接口ThreadPoolExecutor: 线程池，可以通过调用Executors以下静态工厂方法来创建线程池并返回一个ExecutorService对象Executors: 是java.util.concurrent包下的一个类，提供了若干个静态方法，用于生成不同类型的线程池。Executors一共可以创建下面这四类线程池： 1.newFixedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。2.newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。3.newScheduledThreadPool 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。4.newSingleThreadExecutor 创建一个使用单个worker线程的Executor，以无界队列方式来运行该线程。它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 ThreadPoolExecutor在java线程池中，最核心的类是ThreadPoolExecutor，它是线程池的实现类，创建ThreadPoolExecutor一般使用Executors工厂模式创建，Executors类提供了一系列工厂方法用于创建线程池。下面我们一起来深入看一下ThreadPoolExecutor。 属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 整个线程池的控制状态，包含了两个属性：有效线程的数量、线程池的状态（runState）。 * workerCount,有效线程的数量 * runState, 线程池的状态 * * ctl 包含32位数据，低29位存线程数，高3位存runState,这样runState有5个值： * * RUNNING: 接受新任务，处理任务队列中的任务 * SHUTDOWN: 不接受新任务，处理任务队列中的任务 * STOP: 不接受新任务，不处理任务队列中的任务 * TIDYING: 所有任务完成，线程数为0，然后执行terminated() * TERMINATED: terminated() 已经完成 * 具体值： * RUNNING:-536870912 * SHUTDOWN:0 * STOP:536870912 * TIDYING:1073741824 * TERMINATED:1610612736 */private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); // 29位的偏移量 private static final int COUNT_BITS = Integer.SIZE - 3; // 最大容量（2^29 - 1） private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // 阻塞队列 private final BlockingQueue&lt;Runnable&gt; workQueue; // 可重入锁 private final ReentrantLock mainLock = new ReentrantLock(); // 存放工作线程集合 private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); // 终止条件 private final Condition termination = mainLock.newCondition(); // 最大线程池容量 private int largestPoolSize; // 已完成任务数量 private long completedTaskCount; // 线程工厂 private volatile ThreadFactory threadFactory; // 拒绝执行处理器 private volatile RejectedExecutionHandler handler; // 线程等待运行时间 private volatile long keepAliveTime; // 是否运行核心线程超时 private volatile boolean allowCoreThreadTimeOut; // 核心池的大小 private volatile int corePoolSize; // 最大线程池大小 private volatile int maximumPoolSize; 围绕ctl的几个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 这个方法用于取出runState的值 因为CAPACITY值为：00011111111111111111111111111111 * ~为按位取反操作，则~CAPACITY值为：11100000000000000000000000000000 * 再同参数做&amp;操作，就将低29位置0了，而高3位还是保持原先的值，也就是runState的值 * * @param c * 该参数为存储runState和workerCount的int值 * @return runState的值 */private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY;&#125;/** * 这个方法用于取出workerCount的值 * 因为CAPACITY值为：00011111111111111111111111111111，所以&amp;操作将参数的高3位置0了 * 保留参数的低29位，也就是workerCount的值 * * @param c * ctl, 存储runState和workerCount的int值 * @return workerCount的值 */private static int workerCountOf(int c) &#123; return c &amp; CAPACITY;&#125;/** * 将runState和workerCount存到同一个int中 * “|”运算的意思是，假设rs的值是101000，wc的值是000111，则他们位或运算的值为101111 * * @param rs * runState移位过后的值，负责填充返回值的高3位 * @param wc * workerCount移位过后的值，负责填充返回值的低29位 * @return 两者或运算过后的值 */private static int ctlOf(int rs, int wc) &#123; return rs | wc;&#125;// 只有RUNNING状态会小于0private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN;&#125; 构造方法ThreadPoolExecutor类一共有四个构造方法，前三个构造方法最终都是调用的最后一个构造方法，这里我们主要分析一下最后一个构造方法。123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。keepAliveTime（线程活动保持时间）：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0。unit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。workQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列:1.ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。2.LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。3.SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。4.PriorityBlockingQueue：一个具有优先级得无限阻塞队列。threadFactory: 用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。handler: 表示当拒绝处理任务时的策略，有以下四种取值:ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 增加任务以及执行execute我们只能向线程池提交任务, 而被提交的任务最终能否执行以及能否立即执行, 则都由线程池自己来控制。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ // 1. 如果运行的线程小于corePoolSize,则尝试使用用户定义的Runnalbe对象创建一个新的线程，调用addWorker函数会原子性的检查runState和workCount，通过返回false来防止在不应该添加线程时添加了线程 // 2. 如果一个任务能够成功入队列，在添加一个线城时仍需要进行双重检查（因为在前一次检查后该线程死亡了），或者当进入到此方法时，线程池已经shutdown了，所以需要再次检查状态，若有必要，当停止时还需要回滚入队列操作，或者当线程池没有线程时需要创建一个新线程 // 3. 如果无法入队列，那么需要增加一个新线程，如果此操作失败，那么就意味着线程池已经shutdown或者已经饱和了，所以拒绝任务 //获取线程池控制状态 int c = ctl.get(); //用workerCountOf方法根据ctl的值获取当前有效线程数，如果小于核心线程数，尝试添加任务 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; //如果线程池处于RUNNING状态则尝试把请求加入等待队列 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; //再次检查，获取线程池控制状态 int recheck = ctl.get(); //线程池不处于RUNNING状态，将命令从等待队列中移除 if (! isRunning(recheck) &amp;&amp; remove(command)) //拒绝执行命令 reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //如果请求加入等待队列失败，则尝试创建新线程 else if (!addWorker(command, false)) reject(command); &#125; 说明：当在客户端调用submit时（submit也是提交任务的方法和execute的区别是submit会有一个Future对象的返回值），之后会间接调用到execute函数，其在将来某个时间执行给定任务，此方法中并不会直接运行给定的任务。此方法中主要会调用到addWorker函数来开辟新的线程，其中，addWorker函数源码如下 addWorker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//firstTask 等待执行的任务 //core 是否把任务添加到核心线程中执行，true用核心线程数判断执行，false用最大线程数判断执行private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); //获取线程池控制状态 int rs = runStateOf(c); // Check if queue empty only if necessary. //状态大于等于SHUTDOWN，初始的ctl为RUNNING，小于SHUTDOWN //状态为SHUTDOWN //第一个任务为null //worker队列不为空 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) //直接返回 return false; for (;;) &#123; //worker数量 int wc = workerCountOf(c); //worker数量大于等于最大容量 if (wc &gt;= CAPACITY || // worker数量大于等于核心线程池大小或者最大线程池大小 wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //比较并增加worker的数量跳出外层循环 if (compareAndIncrementWorkerCount(c)) break retry; //获取线程池控制状态 c = ctl.get(); // Re-read ctl // 此次的状态与上次获取的状态不相同 if (runStateOf(c) != rs) // 跳过剩余部分，继续循环 continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; // worker开始标识 boolean workerStarted = false; // worker被添加标识 boolean workerAdded = false; Worker w = null; try &#123; //把任务封装在Worker中，最后都会在Worker中执行，并创建一个新线程。 w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; //锁，保证线程同步 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. //获取线程池状态 int rs = runStateOf(ctl.get()); // 如果线程池处于RUNNING状态执行添加任务操作,或线程池处于SHUTDOWN 状态，firstTask 为空。 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // 将worker添加到worker集合 workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; //设置worker已被添加标识 workerAdded = true; &#125; &#125; finally &#123; //释放锁 mainLock.unlock(); &#125; if (workerAdded) &#123; //线程执行 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; addWorker完成如下几件任务1.原子性的增加workerCount。2.将用户给定的任务封装成为一个worker，并将此worker添加进workers集合中。3.启动worker对应的线程，并启动该线程，运行worker的run方法。4.如果失败了回滚worker的创建动作，即将worker从workers集合中删除，并原子性的减少workerCount。 该方法中创建了一个Worker实例，下面我们一起看看该内部类的源码。 WorkerWorker是真正的任务，是由任务执行线程完成，它是ThreadPoolExecutor的核心。每个线程池中，有为数不等的Worker对象，每个Worker对象中，包含一个需要立即执行的新任务和已经执行完成的任务数量，Worker本身，是一个Runnable对象，不是Thread对象它内部封装一个Thread对象，用此对象执行本身的run方法，而这个Thread对象则由ThreadPoolExecutor提供的ThreadFactory对象创建新的线程。（将Worker和Thread分离的好处是，如果我们的业务代码，需要对于线程池中的线程，赋予优先级、线程名称、线程执行策略等其他控制时，可以实现自己的ThreadFactory进行扩展，无需继承或改写ThreadPoolExecutor。）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** Thread this worker is running in. Null if factory fails. */ //worker持有的线程 final Thread thread; /** Initial task to run. Possibly null. */ //worker正在执行的任务 ，可能为null. Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; /** * 创建Worker时会同时创建一个新线程. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; /把Worker传递给新建的线程，当线程执行是会调用Worker的run方法。 this.thread = getThreadFactory().newThread(this); &#125; /** Delegates main run loop to outer runWorker */ //线程执行时会调用该方法 public void run() &#123; runWorker(this); &#125; // Lock methods // // The value 0 represents the unlocked state. // The value 1 represents the locked state. protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; public void lock() &#123; acquire(1); &#125; public boolean tryLock() &#123; return tryAcquire(1); &#125; public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125; &#125; 既然Worker是一个Runnable对象那么看一下它的run方法。 runWorker1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253final void runWorker(Worker w) &#123; //获取当前线程 Thread wt = Thread.currentThread(); //获取w的任务 Runnable task = w.firstTask; w.firstTask = null; //释放锁（设置state为0，允许中断） w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; //任务不为null或者阻塞队列还存在任务 while (task != null || (task = getTask()) != null) &#123; //获取锁 w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt //线程池的运行状态至少应该高于STOP || 线程被中断 &amp;&amp; 再次检查，线程池的运行状态至少应该高于STOP &amp;&amp; // wt线程（当前线程）没有被中断 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) //中断wt线程（当前线程） wt.interrupt(); try &#123; //beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等 beforeExecute(wt, task); Throwable thrown = null; try &#123; //执行任务 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; //增加worker完成的任务数量 w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125; &#125; 此函数中会实际执行给定任务（即调用用户重写的run方法），并且当给定任务完成后，会继续从阻塞队列中取任务，直到阻塞队列为空（即任务全部完成）。 getTask从阻塞队列中获取任务。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? //无限循环，确保操作成功 for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. //当线程池处于STOP及以上状态时，线程数减一，该线程不使用。 //当线程处于SHUTDOWN 状态时，并且workQueue请求队列为空，释放该线程。 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; //获取当前线程数 int wc = workerCountOf(c); // Are workers subject to culling? //如果调用allowCoreThreadTimeOut方法设置为true，则所有线程都有超时时间。 //如果当前线程数大于核心线程数则该线程有超时时间。 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; //worker数量大于maximumPoolSize if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) //workerCount大于1或者worker阻塞队列为空（在阻塞队列不为空时，需要保证至少有一个wc） &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; // 比较并减少workerCount if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; //poll方法从阻塞队列中取出对象，如果队列为空，则当前线程阻塞keepAliveTime时间再尝试取出，还是没有就返回null，记录超时状态，在重新进入for循环时才试图终结Worker。 //take()方法没有超时时间，会一直获取。也就是说在这里不断获取任务， //也就是如果线程池处于RUNNING、SHUTDOWN状态时，只要等待队列不为空，那么线程就会一直执行。这也就是线程重用的原理。 try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125; &#125; 说明：此函数用于从workerQueue阻塞队列中获取Runnable对象，由于是阻塞队列，所以支持有限时间等待（poll）和无限时间等待（take）。在该函数中还会响应shutDown和、shutDownNow函数的操作，若检测到线程池处于SHUTDOWN或STOP状态，则会返回null，而不再返回阻塞队列中的Runnalbe对象。 processWorkerExitrunWorker方法的finally语句块中有一个processWorkerExit方法，processWorkerExit方法是在worker退出时调用到的方法，而引起worker退出的主要因素如下： 1.阻塞队列已经为空，即没有任务可以运行了。 2.调用了shutDown或shutDownNow函数下面来看一下这个方法。123456789101112131415161718192021222324252627282930313233343536private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; //如果线程被中断，则需要减少workCount if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted decrementWorkerCount(); final ReentrantLock mainLock = this.mainLock; //获取锁 mainLock.lock(); try &#123; //将worker完成的任务数添加到总的完成任务中 completedTaskCount += w.completedTasks; //从workers中移除worker workers.remove(w); &#125; finally &#123; //释放锁 mainLock.unlock(); &#125; //这个方法是尝试终止的方法下面会介绍 tryTerminate(); //获取线程池控制状态 int c = ctl.get(); //小于STOP的运行状态 if (runStateLessThan(c, STOP)) &#123; if (!completedAbruptly) &#123; int min = allowCoreThreadTimeOut ? 0 : corePoolSize; if (min == 0 &amp;&amp; ! workQueue.isEmpty()) min = 1; if (workerCountOf(c) &gt;= min) return; // replacement not needed &#125; //添加worker addWorker(null, false); &#125; &#125; 说明：此函数会根据是否中断了空闲线程来确定是否减少workerCount的值，并且将worker从workers集合中移除并且会尝试终止线程池。 结束线程池shutdown1234567891011121314151617public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //检查shutdown权限 checkShutdownAccess(); //把线程池的状态置为SHUTDOWN advanceRunState(SHUTDOWN); //中断所有空闲线程 interruptIdleWorkers(); //调用shutdown方法 onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); &#125; 说明：shutdown是把线程池状态转为SHUTDOWN，这时等待队列中的任务可以继续执行，但是不会接受新任务了，通过中断方式停止空闲的（根据没有获取锁来确定）线程。 shutdownNowshutdownNow与shutdown相似，shutdownNow会尝试停止所有的活动执行任务、暂停等待任务的处理，并返回等待执行的任务列表，但是其会终止所有的worker，而并非空闲的worker。12345678910111213141516public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(STOP); interruptWorkers(); //清空队列 tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); return tasks; &#125; tryTerminate该方法是一个终止线程池的方法。12345678910111213141516171819202122232425262728293031323334353637383940final void tryTerminate() &#123; //无限循环，确保操作成功 for (;;) &#123; //获取线程池控制状态 int c = ctl.get(); //线程池的运行状态为RUNNING || 线程池的运行状态最小要大于TIDYING || 线程池的运行状态为SHUTDOWN &amp;&amp; workQueue队列不为null if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) //不能终止，直接返回 return; //线程池正在运行的worker数量不为0 if (workerCountOf(c) != 0) &#123; // Eligible to terminate //仅仅中断一个空闲的worker interruptIdleWorkers(ONLY_ONE); return; &#125; final ReentrantLock mainLock = this.mainLock; //获取锁 mainLock.lock(); try &#123; //比较并设置线程池控制状态为TIDYING if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; terminated(); &#125; finally &#123; //设置线程池控制状态为TERMINATED ctl.set(ctlOf(TERMINATED, 0)); //释放在termination条件上等待的所有线程 termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#125; // else retry on failed CAS &#125; &#125; 1.tryTerminate()方法尝试终止线程池活动，满足终止条件的因素有两个：首先，ctl状态为STOP,或者为SHUTDOWN且任务队列为空（STOP状态之所以一直都不用判断workQueue是因为上面讲到的，shutdownNow()方法调用了drainQueue()方法清空了workQueue所以其必然为空，这里解释一下）；其次，ctl计数为0。第二个条件的满足是由一连串连锁反应保证的，shutdownNow()方法置ctl状态为STOP,使得所有worker调用getTask()方法满足rs&gt;=SHUTDOWN条件从而调用decrementWorkerCount()方法，这将最终导致ctl计数为0，同时所有work都将从getTask()方法获得null，最终导致runWorker()方法调用processWorkerExit（）方法，将workers数组真正清空。shutdown（）方法稍微复杂，它置ctl状态为SHUTDOWN，但是线程池仍将继续运行，直至所有workers将工作队列中的任务全部完成，之后的逻辑和stop状态下的完全一样，不再多说。 2.在保证了上述两个条件之后，tryTerminate()方法获取住所mainLock，置ctl状态为TIDYING,之后执行terminated方法，最后置ctl状态为TERMINATED。 interruptIdleWorkers1234567891011121314151617181920212223242526private void interruptIdleWorkers(boolean onlyOne) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //遍历workers队列 for (Worker w : workers) &#123; Thread t = w.thread; //线程未被中断并且成功获得锁 if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; try &#123; //中断线程 t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; finally &#123; //释放锁 w.unlock(); &#125; &#125; //若只中断一个，则跳出循环 if (onlyOne) break; &#125; &#125; finally &#123; mainLock.unlock(); &#125; &#125; 说明：此函数将会中断正在等待任务的空闲worker。 总结ThreadPoolExecutor是线程池框架的一个核心类，通过对ThreadPoolExecutor的分析，可以知道其对资源进行了复用，并非无限制的创建线程，可以有效的减少线程创建和切换的开销，关于ThreadPoolExecutor的源码就分析到这里。 参考http://blog.csdn.net/qq_22929803/article/details/52347381http://www.jianshu.com/p/6e65757a7b33http://blog.csdn.net/clevergump/article/details/50688008]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码分析(JDK1.8)]]></title>
    <url>%2F2017%2F10%2F27%2Fjava%2FconcurrentHashMap%2F</url>
    <content type="text"><![CDATA[在日常开发中，常常要使用HashMap，但是在多线程环境下HashMap是线程不安全的，可以使用Hashtable，或者Collections.synchronizedMap(new HashMap&lt;&gt;())。但是ConcurrentHashMap通常是一个更好的选择。在实现上Hashtable和Collections.synchronizedMap(new HashMap&lt;&gt;())都是对整个map加锁，ConcurrentHashMap是对map中的所有桶加了锁。 1.6中的实现：ConcurrentHashMap采用分段锁的机制，实现并发的更新操作，底层由Segment数组和HashEntry数组组成。Segment继承ReentrantLock用来充当锁的角色，每个Segment对象守护每个散列映射表的若干个桶。HashEntry用来封装映射表的键/值对；每个桶是由若干个HashEntry对象链接起来的链表。一个 ConcurrentHashMap实例中包含由若干个Segment对象组成的数组，下面我们通过一个图来演示一下 ConcurrentHashMap的结构： JDK1.8中改进：1.取消segments字段，（Segment虽保留，但已经简化属性，仅仅是为了兼容旧版本。）直接采用transient volatile HashEntry table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。2.将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。（这点和HashMap是一样的）对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中。如果hash之后散列的很均匀，那么table数组中的每个队列长度主要为0或者1。但实际情况并非总是如此理想，虽然ConcurrentHashMap类默认的加载因子为0.75，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。 ConcurrentHashMap的定义12public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable 属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 //最大的表容量。 private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认的初始表容量。必须是2的幂 private static final int DEFAULT_CAPACITY = 16; //最大(两个)数组大小。 static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //此表的默认并发级别。(1.8中已经不使用了，为了兼容以前的版本) private static final int DEFAULT_CONCURRENCY_LEVEL = 16; //这个表的装载因子。 private static final float LOAD_FACTOR = 0.75f; //链表转红黑树的阀值，如果table[i]下面的链表长度大于8时就转化为树 static final int TREEIFY_THRESHOLD = 8; //红黑树转链表的阀值，小于等于6时转为链表，仅在扩容时才可能树转链表 static final int UNTREEIFY_THRESHOLD = 6; //数组可以转化为树的表的最小容量，（否则，如果一个bin中的节点太多，表将被调整大小。）该值应至少为4 * TREEIFY_THRESHOLD以避免调整大小和树化阈值之间的冲突。 static final int MIN_TREEIFY_CAPACITY = 64; //每个转移步骤的最小重新排列数。范围是细分为允许多个resizer线程。这个值作为一个下限，以避免resizers遇到内存争夺过多，该值至少应该是DEFAULT_CAPACITY。 private static final int MIN_TRANSFER_STRIDE = 16; //用来控制扩容的时候 单线程进入的变量 private static int RESIZE_STAMP_BITS = 16; //用来控制扩容的时候 单线程进入的变量 private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS; //可以帮助调整大小的最大线程数 private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1; //节点的标识 static final int MOVED = -1; // hash for forwarding nodes static final int TREEBIN = -2; // hash for roots of trees static final int RESERVED = -3; // hash for transient reservations static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash //装数据的数组，第一次插入数据的时候初始化,大小为2^n. transient volatile Node&lt;K,V&gt;[] table; //扩容时使用 private transient volatile Node&lt;K,V&gt;[] nextTable; //记录容器的容量大小(但返回的不一定是当前Map的真实元素个数)，通过CAS无锁更新 private transient volatile long baseCount; //hash表初始化或扩容时的一个控制位标识量。 //负数代表正在进行初始化或扩容操作 //-1代表正在初始化 //-N 表示有N-1个线程正在进行扩容操作 //正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小 //默认是table大小的0.75 倍，用公式0.75（n - (n &gt;&gt;&gt; 2)）计算。 private transient volatile int sizeCtl; //自旋锁（锁定通过 CAS）在调整大小和/或创建CounterCells时使用。在CounterCell类更新value中会使用，功能类似显示锁和内置锁，性能更好(在Striped64类也有应用) private transient volatile int cellsBusy; 构造方法ConcurrentHashMap有5个构造方法这里着重介绍第5个构造方法。123456789101112131415161718192021222324//看一下最后一个参数concurrencyLevel,表示能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数。public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; //检查参数的有效性 if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (initialCapacity &lt; concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads long size = (long)(1.0 + (long)initialCapacity / loadFactor); int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); this.sizeCtl = cap; &#125; //返回给定所需容量，table的大小总是2的幂次方 private static final int tableSizeFor(int c) &#123; int n = c - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; 上面的代码先用一系列的移位和 | 操作把n变成二进制表示的形式，然后加1，就会变成2^k了。12//计算节点的位置 h 是 key的hash n 是table的大小int index = (n - 1) &amp; h; table的大小n是2^k，那么n-1就会是0..1….1的形式，并且小于n，通过与h按位与就可以得到对应的index了。而在扩容时，ConcurrentHashMap会将table的大小变为原来的2倍，这样，计算index时就变成了(2n-1)&amp;h，那么n-1为0011的话，2n-1就是0111，这样扩容后的index要么等于扩容前的index，否则就等于index+n，减小了扩容时的计算量。(这和HashMap的方式相同)。 注意，ConcurrentHashMap在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。 重要的内部类NodeNode是最核心的内部类，它包装了key-value键值对，所有插入ConcurrentHashMap的数据都包装在这里面。它与HashMap中的定义很相似，但是但是有一些差别它对value和next属性设置了volatile同步锁(与JDK7的Segment相同)，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。 TreeNode树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap继承自Node类，而并非HashMap中的继承自LinkedHashMap.Entry类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。 TreeBin这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。 ForwardingNode在transfer操作中使用，一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找。生命周期：仅存活于扩容操作。 主要方法initTable当put方法调用table==null时会执行此方法初始化table。123456789101112131415161718192021222324252627//初始化表，使用sizeCtl中记录的大小。private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; //进入循环 while ((tab = table) == null || tab.length == 0) &#123; //如果sizeCtl&lt;0说明已经有其它线程正在进行扩容，即正在初始化或初始化完成,其它线程通过Thread.yield()让出CPU时间片，等待table非空即可。 if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin //利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; //这里注意table的大小为sizeCtl table = tab = nt; sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; break; &#125; &#125; return tab; &#125; helpTransfer这是扩容过程中的一个辅助方法。在多线程情况下，如果发现其它线程正在扩容，则帮助转移元素。（只有这种情况会被调用）从某种程度上说，其“优先级”很高，只要检测到扩容，就会放下其他工作，先扩容。12345678910111213141516171819202122//调用这个方法之前，nextTable对象一定已经存在的。final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123; //返回用于调整大小为n的表的大小的标记位。 int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; //开始扩容 transfer(tab, nextTab); break; &#125; &#125; return nextTab; &#125; return table; &#125; addCount12345678910111213141516171819202122232425262728293031323334353637383940414243private final void addCount(long x, int check) &#123; CounterCell[] as; long b, s; //利用CAS方法把当前ConcurrentHashMap的元素个数+1 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123; CounterCell a; long v; int m; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123; //多线程CAS发生失败的时候执行 fullAddCount(x, uncontended); return; &#125; if (check &lt;= 1) return; s = sumCount(); &#125; //如果check值大于等于0 则需要检验是否需要进行扩容操作 if (check &gt;= 0) &#123; Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; int rs = resizeStamp(n); //正在进行初始化或扩容操作 if (sc &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; //如果已经有其他线程在执行扩容操作 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; //当前线程是唯一的或是第一个发起扩容的线程 此时nextTable=null else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); &#125; &#125; &#125; transfer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range if (nextTab == null) &#123; // initiating try &#123; @SuppressWarnings("unchecked") //构造一个nextTable对象 它的容量是原来的两倍 Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; transferIndex = n; &#125; int nextn = nextTab.length; //构造一个连节点指针 用于标志位 ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); //并发扩容的关键属性 如果等于true 说明这个节点已经处理过 boolean advance = true; //循环的关键变量，判断是否已经扩容完成，完成就return，退出循环 boolean finishing = false; // to ensure sweep before committing nextTab //死循环 for (int i = 0, bound = 0;;) &#123; Node&lt;K,V&gt; f; int fh; //循环的关键控制i，i--操作保证了倒序遍历数组 while (advance) &#123; int nextIndex, nextBound; if (--i &gt;= bound || finishing) advance = false; //nextIndex=transferIndex=n=tab.length(默认16) else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; advance = false; &#125; //用CAS计算得到的transferIndex else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound; i = nextIndex - 1; advance = false; &#125; &#125; //i&lt;0，i&gt;=n说明已经遍历完旧的数组tab，i+n&gt;=nextn说明已经扩容完成 if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; //所有节点复制完毕 if (finishing) &#123; nextTable = null; table = nextTab; //扩容阈值设置为原来容量的1.5倍，相当于现在容量的0.75倍 sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; &#125; //利用CAS更新扩容阈值,sc-1表明新加入一个线程参与扩容 if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; //如果有两个线程，值肯定不相等，所以直接返回（保持只有一个线程执行） if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; //finishing和advance保证线程已经扩容完成了可以退出循环 finishing = advance = true; i = n; // recheck before commit &#125; &#125; //如果tab[i]为null，那么就把fwd插入到tab[i]，表明这个节点已经处理过了 else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); //f.hash=-1,说明该节点为ForwardingNode，说明该节点已经处理过了 else if ((fh = f.hash) == MOVED) advance = true; // already processed else &#123; //把当前节点加锁 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; //ln原位置节点，hn新位置节点 Node&lt;K,V&gt; ln, hn; //这是一个链表Node节点 if (fh &gt;= 0) &#123; int runBit = fh &amp; n; //构造两个链表，一个是原链表；另一个是原链表的反序排列 Node&lt;K,V&gt; lastRun = f; for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; else &#123; hn = lastRun; ln = null; &#125; for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; //在nextTable的i位置上插入一个链表 setTabAt(nextTab, i, ln); //在nextTable的i+n的位置上插入另一个链表 setTabAt(nextTab, i + n, hn); //在table的i位置上插入forwardNode节点 表示已经处理过该节点 setTabAt(tab, i, fwd); //设置advance为true 返回到上面的while循环中 就可以执行i--操作 advance = true; &#125; //对TreeBin对象进行处理，与上面的过程类似 else if (f instanceof TreeBin) &#123; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; //构造正序和反序两个链表 for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; //如果扩容后已经不再需要tree的结构，反向转换为链表结构 ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; //在nextTable的i位置上插入一个链表 setTabAt(nextTab, i, ln); //在nextTable的i+n的位置上插入另一个链表 setTabAt(nextTab, i + n, hn); //在table的i位置上插入fwd节点，表示已经处理过该节点 setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125; &#125; put既然上面说的ConcurrentHashMap的构造函数不会初始化table，会延迟到第一次put，那么我们就来看看put方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public V put(K key, V value) &#123; return putVal(key, value, false); &#125;//计算hash值 static final int spread(int h) &#123; return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS; &#125;//putVal操作采用CAS+synchronized实现并发插入或更新操作 final V putVal(K key, V value, boolean onlyIfAbsent) &#123; //ConcurrentHashMap 不允许插入null键，HashMap允许插入一个null键 if (key == null || value == null) throw new NullPointerException(); //算出hash值（即数组下标） int hash = spread(key.hashCode()); int binCount = 0; //死循环，直到插入成功 for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) //初始化table tab = initTable(); //去除tab中的节点赋值给f //如果table[i]==null(即该位置的节点为空，没有发生碰撞)，则利用CAS操作直接存储在该位置，如果CAS操作成功则退出死循环。 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; //table[i]!=null(即该位置已经有其它节点，发生碰撞) //检查table[i]的节点的hash是否等于MOVED，如果等于，则检测到正在扩容，则帮助其扩容 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; //结点上锁 这里的结点可以理解为hash值相同组成的链表的头结点 synchronized (f) &#123; //避免多线程，需要重新检查 if (tabAt(tab, i) == f) &#123; //fh〉0 说明这个节点是一个链表的节点 不是树的节点 if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; //hash和key都相同 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; //如果没有找到值为key的节点，新建Node加入链表。 if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; //首节点为TreeBin，为红黑树结构，按照红黑树的方式插入数据。 else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; //如果链表长度达到阀值需要调整结构变为红黑树。 if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; //将当前ConcurrentHashMap的元素数量+1，有可能触发扩容操作。 addCount(1L, binCount); return null; &#125; tryPresize这个方法也是扩容操作。在putAll和链表转红黑树的时候使用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private final void tryPresize(int size) &#123; //给定的容量若&gt;=MAXIMUM_CAPACITY的一半，直接扩容到允许的最大值，否则调用函数扩容 int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1); int sc; //没有正在初始化或扩容，或者说表还没有被初始化 while ((sc = sizeCtl) &gt;= 0) &#123; Node&lt;K,V&gt;[] tab = table; int n; //没有被初始化 if (tab == null || (n = tab.length) == 0) &#123; n = (sc &gt; c) ? sc : c; //期间没有其他线程对表操作，则CAS将SIZECTL状态置为-1，表示正在进行初始化 if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; //重复检查 if (table == tab) &#123; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = nt; //无符号右移2位(即0.75*n) sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; //更新扩容阀值 sizeCtl = sc; &#125; &#125; &#125; //若想要扩容的值不大于原阀值，或现有容量&gt;=最值，什么都不用做了 else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) break; else if (tab == table) &#123; //返回一个标志位 int rs = resizeStamp(n); //执行扩容操作 if (sc &lt; 0) &#123; Node&lt;K,V&gt;[] nt; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); &#125; &#125; &#125; treeifyBin链表转红黑树方法。123456789101112131415161718192021222324252627private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123; Node&lt;K,V&gt; b; int n, sc; if (tab != null) &#123; //容量小于64，扩容 if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) tryPresize(n &lt;&lt; 1); else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123; synchronized (b) &#123; if (tabAt(tab, index) == b) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) hd = p; else tl.next = p; tl = p; &#125; //在原来index的位置，用TreeBin替换掉原来的Node对象 setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd)); &#125; &#125; &#125; &#125; &#125; get上面介绍完put相关的方法了，下面来看看get方法。1234567891011121314151617181920212223public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; //计算hash值 int h = spread(key.hashCode()); //根据hash值确定节点位置 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; //eh&lt;0，说明这个节点在树上，直接查找树 else if (eh &lt; 0) return (p = e.find(h, key)) != null ? p.val : null; //链表，找到对应的值并返回 while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null; &#125; containsValue查询当前ConcurrentHashMap是否包含该value值。有可能需要遍历一遍ConcurrentHashMap。12345678910111213141516public boolean containsValue(Object value) &#123; //判断value是否为null，这里和HashMap不同 if (value == null) throw new NullPointerException(); Node&lt;K,V&gt;[] t; //如果table不为空遍历table。 if ((t = table) != null) &#123; Traverser&lt;K,V&gt; it = new Traverser&lt;K,V&gt;(t, t.length, 0, t.length); for (Node&lt;K,V&gt; p; (p = it.advance()) != null; ) &#123; V v; if ((v = p.val) == value || (v != null &amp;&amp; value.equals(v))) return true; &#125; &#125; return false; &#125; replaceNoderemove的核心方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//注意：cv才是key-value中的value！final V replaceNode(Object key, V value, Object cv) &#123; int hash = spread(key.hashCode()); for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; //该table第一个元素为空，直接跳过 if (tab == null || (n = tab.length) == 0 || (f = tabAt(tab, i = (n - 1) &amp; hash)) == null) break; else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; boolean validated = false; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; validated = true; for (Node&lt;K,V&gt; e = f, pred = null;;) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; V ev = e.val; //value为null或value和查到的值相等 if (cv == null || cv == ev || (ev != null &amp;&amp; cv.equals(ev))) &#123; oldVal = ev; if (value != null) e.val = value; else if (pred != null) pred.next = e.next; else setTabAt(tab, i, e.next); &#125; break; &#125; pred = e; if ((e = e.next) == null) break; &#125; &#125; //以树的方式find、remove else if (f instanceof TreeBin) &#123; validated = true; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; r, p; if ((r = t.root) != null &amp;&amp; (p = r.findTreeNode(hash, key, null)) != null) &#123; V pv = p.val; if (cv == null || cv == pv || (pv != null &amp;&amp; cv.equals(pv))) &#123; oldVal = pv; if (value != null) p.val = value; else if (t.removeTreeNode(p)) setTabAt(tab, i, untreeify(t.first)); &#125; &#125; &#125; &#125; &#125; if (validated) &#123; if (oldVal != null) &#123; if (value == null) addCount(-1L, -1); return oldVal; &#125; break; &#125; &#125; &#125; return null; &#125; clear移除ConcurrentHashMap中所有的元素。12345678910111213141516171819202122232425262728293031323334public void clear() &#123; long delta = 0L; // negative number of deletions int i = 0; Node&lt;K,V&gt;[] tab = table; while (tab != null &amp;&amp; i &lt; tab.length) &#123; int fh; Node&lt;K,V&gt; f = tabAt(tab, i); //为空，直接跳过 if (f == null) ++i; else if ((fh = f.hash) == MOVED) &#123; tab = helpTransfer(tab, f); i = 0; // restart &#125; else &#123; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; Node&lt;K,V&gt; p = (fh &gt;= 0 ? f : (f instanceof TreeBin) ? ((TreeBin&lt;K,V&gt;)f).first : null); //首先删除链、树的末尾元素，避免产生大量垃圾 while (p != null) &#123; --delta; p = p.next; &#125; //利用CAS无锁置null setTabAt(tab, i++, null); &#125; &#125; &#125; &#125; if (delta != 0L) addCount(delta, -1); &#125; 总结ConcurrentHashMap是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于HashTable和同步包装器包装的HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。1.6中采用ReentrantLock 分段锁的方式，使多个线程在不同的segment上进行写操作不会发现阻塞行为;1.8中直接采用了内置锁synchronized，因为1.8的虚拟机对内置锁已经优化的足够快了。 思考ConcurrentHashMap能完全代替HashTable吗？ 参考http://blog.csdn.net/fjse51/article/details/55260493http://blog.csdn.net/u010723709/article/details/48007881http://www.itdadao.com/articles/c15a1157176p0.htmlhttp://www.importnew.com/22007.htmlhttps://www.waitig.com/concurrenthashmap-java8.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bit Operation(位运算)]]></title>
    <url>%2F2017%2F10%2F26%2FoperatingSystem%2FbitOperation%2F</url>
    <content type="text"><![CDATA[位运算最近在看一些源码的时候，发现里面大量的运用了位运算，所以在这里总结一下位运算。 什么是位运算？按位操作符用来操作整数基本数据类型中的单个”比特“（bit），即二进制。按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。 位运算符的使用&amp;(按位“与”操作符)如果两个输入位都是1，则输出位为1；否则输出位为0. |（按位“或”操作符）如果两个输入位只要有一个为1，则输出位为1；否则输出位为0. ^(按位“异或”操作符)如果输入位的某一个为1，但不全是1，则输出位为1；否则输出位为0. ~(按位“非”操作符)生成与输入位相反的值。－－若输入1，输出0；输入0，输出1. &lt;&lt;(左移操作符)按照操作符右侧指定的位数，将操作符左侧的操作数向左移动（在低位补0）。a&lt;&lt;b相当于a乘以2的b次方。 &gt;&gt;(右移操作符)按照操作符右侧指定的位数，将操作符左侧的操作数向右移动。“有符号”右移操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1.相当于a除以2的b次方（取整）。 &gt;&gt;&gt;(无符号右移操作符)无论正负都在高位插入0，这个操作符在c和c++中是没有的，是java中增加的。 下面列举了一些常见的二进制位的变换操作。 功能 示例 位运算 去掉最后一位 (101101-&gt;10110) x &gt;&gt; 1 在最后加一个0 (101101-&gt;1011010) x &lt;&lt; 1 在最后加一个1 (101101-&gt;1011011) x &lt;&lt; 1+1 把最后一位变成1 (101100-&gt;101101) x &#x7C; 1 把最后一位变成0 (101101-&gt;101100) x &#x7C; 1-1 最后一位取反 (101101-&gt;101100) x ^ 1 把右数第k位变成1 (101001-&gt;101101,k=3) x &#x7C; (1 &lt;&lt; (k-1)) 把右数第k位变成0 (101101-&gt;101001,k=3) x &amp; ~ (1 &lt;&lt; (k-1)) 右数第k位取反 (101001-&gt;101101,k=3) x ^ (1 &lt;&lt; (k-1)) 取末三位 (1101101-&gt;101) x &amp; 7 取末k位 (1101101-&gt;1101,k=5) x &amp; (1 &lt;&lt; k-1) 取右数第k位 (1101101-&gt;1,k=4) x &gt;&gt; (k-1) &amp; 1 把末k位变成1 (101001-&gt;101111,k=4) x &#x7C; (1 &lt;&lt; k-1) 末k位取反 (101001-&gt;100110,k=4) x ^ (1 &lt;&lt; k-1) 把右边连续的1变成0 (100101111-&gt;100100000) x &amp; (x+1) 把右起第一个0变成1 (100101111-&gt;100111111) x &#x7C; (x+1) 把右边连续的0变成1 (11011000-&gt;11011111) x &#x7C; (x-1) 取右边连续的1 (100101111-&gt;1111) (x ^ (x+1)) &gt;&gt; 1 去掉右起第一个1的左边 (100101000-&gt;1000) x &amp; (x ^ (x-1)) （未完待续。。。）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Find the Difference]]></title>
    <url>%2F2017%2F10%2F25%2FleetCode%2FfindTheDifference%2F</url>
    <content type="text"><![CDATA[Find the Difference原题：Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example1 Input:s = “abcd”t = “abcde”Output:eExplanation:‘e’ is the letter that was added. 题目大意给定两个字符串s，t。 t是由s增加了一个字符而得到的，找出增加的字符。 解题思路有很多解法，可以用异或，可以转成Unicode码，可以利用map key的形式，这里用异或的形式。代码实现（java）：1234567891011121314class Solution &#123; public char findTheDifference(String s, String t) &#123; char c = 0; for(int i = 0; i &lt; s.length(); i++)&#123; c ^= s.charAt(i); &#125; for(int i = 0; i &lt; t.length(); i++)&#123; c ^= t.charAt(i); &#125; return c; &#125;&#125; python实现（python是不是比java代码简单许多呢）：123class Solution(object): def findTheDifference(self, s, t): return chr(reduce(operator.xor, map(ord, s + t)))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Find All Numbers Disappeared in an Array]]></title>
    <url>%2F2017%2F10%2F25%2FleetCode%2FfindAllNumbersDisappearedInAnArray%2F</url>
    <content type="text"><![CDATA[Find All Numbers Disappeared in an Array原题：Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example1 Input:[4,3,2,7,8,2,3,1]Output:[5,6] 题目大意给定一个数组，1 ≤ a[i] ≤ n，n是数组的长度。其中有的数字出现一次，有的数字出现两次，有的不出现，找出不出现的数字。 解题思路要求不能使用额外的空间。循环数组，取到每个元素的值i－1获得该元素对应的下标，把该值置为负数，再遍历一遍数组，元素为正数的位置n＋1 即为没有出现的值。代码实现（java）：123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(nums == null || nums.length == 0) return res; for(int i = 0; i &lt; nums.length; i++)&#123; int val = Math.abs(nums[i]) - 1; if(nums[val] &gt; 0) nums[val] = -nums[val]; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) &#123; res.add(i + 1); &#125; &#125; return res; &#125;&#125; python实现：123456789101112class Solution(object): def findDisappearedNumbers(self, nums): res = [] for i in range(len(nums)): val = abs(nums[i]) - 1 if nums[val] &gt; 0: nums[val] = -nums[val] for i in range(len(nums)): if nums[i] &gt; 0: res.append(i + 1) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Sum of Two Integers]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FsumOfTwoIntegers%2F</url>
    <content type="text"><![CDATA[Sum of Two Integers原题：Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example1 Given a = 1 and b = 2, return 3. 题目大意给两个数字a, b 求ab的和，不能使用＋/-. 解题思路第一个想法就是使用位运算，但是没有什么好的思路。网上查了一下：这里用到了一个半加法的思想, 即两位单独的位相加其结果可以用异或得到, 进位可以用与得到. 然后对于两个数字来说同样可以延伸这个思想.举个例子: 11+5, 其二进制形式为11: 1011, 5: 0101 那么两个位置都为1的地方就需要进位, 所以进位值就为0001. 原位置两个数相加的结果为那个位置值的异或即1110, 即两个位置值如果不一样就为1, 一样的话要么两个位置原来值都为0结果也为0, 要么进位, 那么结果依然是0. 接下来就要把进位位和下一位相加, 所以进位值左移一位,即0001变为0010, 重复上面操作可得新的进位值为0010, 原位置异或(即相加)结果为1100. 继续重复上面操作直到进位为0, 可得到最终结果10000, 即16代码实现（java）：123456789class Solution &#123; public int getSum(int a, int b) &#123; if(b == 0) return a; int r = a ^ b; int curry = (a &amp; b) &lt;&lt; 1; return getSum(r, curry); &#125;&#125; python实现就显得太不要脸了，哈哈：1234class Solution(object): def getSum(self, a, b): res = [a, b] return sum(res)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Detect Capital]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FdetectCapital%2F</url>
    <content type="text"><![CDATA[Detect Capital原题：Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: 1.All letters in this word are capitals, like “USA”.2.All letters in this word are not capitals, like “leetcode”.3.Only the first letter in this word is capital if it has more than one letter, like “Google”.Otherwise, we define that this word doesn’t use capitals in a right way. Example1 Input: “USA”Output: True Example2 Input: “FlaG”Output: False Note The input will be a non-empty word consisting of uppercase and lowercase latin letters. 题目大意给定一个字符串，如果全是大写或者小写或者首字母为大写其余全是小写 返回true 否则返回false 解题思路没什么好说的了就是判断了。代码实现（java）：1234567891011121314class Solution &#123; public boolean detectCapitalUse(String word) &#123; if (word == null) return false; if (word.equals(word.toLowerCase()) || word.equals(word.toUpperCase())) return true; if (Character.isUpperCase(word.charAt(0)))&#123; String str = word.substring(1, word.length()); if (str.equals(str.toLowerCase())) return true; &#125; return false; &#125;&#125; python实现：12345class Solution(object): def detectCapitalUse(self, word): if(word == word.upper() or word == word.lower() or word == word.capitalize()): return True return False]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Max Consecutive Ones]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FmaxConsecutiveOnes%2F</url>
    <content type="text"><![CDATA[Max Consecutive Ones原题：Given a binary array, find the maximum number of consecutive 1s in this array. Example1 Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 题目大意给定一个数组，求出里面连续1的最大个数。 解题思路第一种思路是把数组变为字符串根据0分割，求出最长的字符串。代码实现（java）：123456789101112131415class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int res = 0; StringBuilder in = new StringBuilder(); for(int num : nums)&#123; in.append(num); &#125; String[] strs = in.toString().split("0"); for(String str : strs)&#123; if(res &lt; str.length()) res = str.length(); &#125; return res; &#125;&#125; 第二种思路是把每次到0之前的长度算出来和最后结果比较把大的赋值给返回值，在去比较下一轮。代码实现（java）：1234567891011class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int res = 0; int count = 0; for(int num : nums)&#123; count = (num == 1) ? ++count : 0; res = Math.max(res, count); &#125; return res; &#125;&#125; python第二种思路实现：12345678class Solution(object): def findMaxConsecutiveOnes(self, nums): res = 0 count = 0 for i in range(len(nums)): count = count + 1 if nums[i] == 1 else 0; res = max(res, count) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Binary Number with Aliternating Bits]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FbinaryNumberWithAliternatingBits%2F</url>
    <content type="text"><![CDATA[Binary Number with Alternating Bits原题：Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example1 Input: 5Output: TrueExplanation:The binary representation of 5 is: 101 Example2 Input: 7Output: FalseExplanation:The binary representation of 7 is: 111. Example3 Input: 11Output: FalseExplanation:The binary representation of 11 is: 1011. Example4 Input: 10Output: TrueExplanation:The binary representation of 10 is: 1010. 题目大意给定一个数，判断这个数的二进制相邻的两个数都不相同。 解题思路求出二进制数，依次判断。代码实现（java）：1234567891011class Solution &#123; public boolean hasAlternatingBits(int n) &#123; String str = Integer.toBinaryString(n); for (int i = 0; i &lt; str.length() - 1; i++)&#123; if (str.charAt(i) == str.charAt(i + 1)) &#123; return false; &#125; &#125; return true; &#125;&#125; python实现：1234567class Solution(object): def hasAlternatingBits(self, n): str = bin(n).replace("0b", "") for i in range(len(str) - 1): if str[i] == str[i + 1]: return False return True]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Single Number]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FsingleNumber%2F</url>
    <content type="text"><![CDATA[Single Number原题：Given an array of integers, every element appears twice except for one. Find that single one. Note Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 题目大意给定一个数组，里面的元素有的出现两次，只有一个出现一次，找出出现一次的。 解题思路利用位运算：a^a=0 a^0=a。代码实现（java）：123456789class Solution &#123; public int singleNumber(int[] nums) &#123; int res = 0; for(int num : nums)&#123; res ^= num; &#125; return res; &#125;&#125; python实现：123456class Solution(object): def singleNumber(self, nums): res = 0 for i in range(len(nums)): res ^= nums[i] return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Nim Game]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FnimGame%2F</url>
    <content type="text"><![CDATA[Nim Game原题：You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. 题目大意题目说给我们一堆石子，每次可以拿一个两个或三个，两个人轮流拿，拿到最后一个石子的人获胜，现在给我们一堆石子的个数，问我们能不能赢。 解题思路因为每个人都取不到4个，假设自己后走，要保证每轮自己和对方取得数量的和是4，这样就能确保每轮完后都有4的倍数个石头被取走。这样，如果我们先走的话，先把n除4的余数个石头拿走，这样不管怎样，到最后都会留4个下来，对方取1个你就取3个，对方取2个你就取2个，就必赢了。代码实现（java）：12345class Solution &#123; public boolean canWinNim(int n) &#123; return (n &amp; 3) != 0; &#125;&#125; python实现：123class Solution(object): def canWinNim(self, n): return (n &amp; 3) != 0]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Longest Uncommon Subsequence I]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FlongestUncommonSubsequence1%2F</url>
    <content type="text"><![CDATA[Longest Uncommon Subsequence I原题：Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1. Example1 Input: “aba”, “cdc”Output: 3Explanation: The longest uncommon subsequence is “aba” (or “cdc”),because “aba” is a subsequence of “aba”,but not a subsequence of any other strings in the group of two strings. Note Both strings’ lengths will not exceed 100. Only letters from a ~ z will appear in input strings. 题目大意给定一组两个的字符串，您需要找到这组两个字符串中最长的不常见的子序列。 最长的不常见的子序列被定义为这些字符串之一的最长子序列，并且该子序列不应该是其他字符串的任何子序列。子序列是可以通过删除一些字符而不改变剩余元素的顺序从一个序列导出的序列。 简而言之，任何字符串本身都是一个子序列，空字符串是任何字符串的子序列。输入将是两个字符串，输出需要是最长的不常见子序列的长度。 如果最长不常见的子序列不存在，则返回-1。 解题思路因为最长子字符串就是本身，所以答案也就出来了。代码实现（java）：12345678class Solution &#123; public int findLUSlength(String a, String b) &#123; if(a.equals(b)) return -1; else return Math.max(a.length(), b.length()); &#125;&#125; python实现：123class Solution(object): def findLUSlength(self, a, b): return -1 if a == b else max(len(a), len(b))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Next Greater Element1]]></title>
    <url>%2F2017%2F10%2F24%2FleetCode%2FnextGreaterElement1%2F</url>
    <content type="text"><![CDATA[Next Greater Element I原题：You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number. Example1 Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1]Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. Note All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000. 题目大意给出两个数组，数组1和数组2 找出数组1中每个元素在数组2中右边最大的一位数字，如果没有返回－1. 解题思路把数组2的元素作为key，下标作为value放入map中，外层循环数组1，内层循环数组2，从map中取出当前数组1中的值的value＋1，作为起始点。判断大小。代码实现（java）：12345678910111213141516171819class Solution &#123; public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int[] res = new int[nums1.length]; for (int i = 0; i &lt; nums2.length; i++) map.put(nums2[i], i); for (int i = 0; i &lt; nums1.length; i++) &#123; int ind = -1; for (int j = map.get(nums1[i]) + 1; j &lt; nums2.length; j++) &#123; if (nums2[j] &gt; nums1[i]) &#123; ind = j; break; &#125; &#125; res[i] = ind == -1 ? -1 : nums2[ind]; &#125; return res; &#125;&#125; python实现：1234567891011121314class Solution(object): def nextGreaterElement(self, findNums, nums): map = &#123;&#125; res = [] for i in range(len(nums)): map.setdefault(nums[i], i) for i in range(len(findNums)): count = -1 for j in range(map.get(findNums[i]) + 1, len(nums)): if(nums[j] &gt; findNums[i]): count = j break res.append(-1 if count == -1 else nums[count]) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Island Perimeter]]></title>
    <url>%2F2017%2F10%2F19%2FleetCode%2FislandPerimeter%2F</url>
    <content type="text"><![CDATA[Island Perimeter原题：You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example [[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] Answer: 16Explanation: The perimeter is the 16 yellow stripes in the image below: 题目大意给出一个多维数组，为1的元素是岛屿，求岛屿的周长。 解题思路依次判断。代码实现（java）：12345678910111213141516171819202122class Solution &#123; public int islandPerimeter(int[][] grid) &#123; int w = grid.length; int h = grid[0].length; int res = 0; for (int i = 0; i &lt; w; i++)&#123; for (int j = 0; j &lt; h; j++)&#123; if(grid[i][j] == 1)&#123; if(i == 0 || grid[i - 1][j] == 0) res++; if(i == w - 1 || grid[i + 1][j] == 0) res++; if(j == 0 || grid[i][j - 1] == 0) res++; if(j == h - 1 || grid[i][j + 1] == 0) res++; &#125; &#125; &#125; return res; &#125;&#125; python实现：1234567891011121314151617class Solution(object): def islandPerimeter(self, grid): w = len(grid) h = len(grid[0]) res = 0 for i in range(w): for j in range(h): if grid[i][j] == 1: if j-1 &lt; 0 or grid[i][j-1] == 0: res += 1 if j+1 &gt;= h or grid[i][j+1] == 0: res += 1 if i-1 &lt; 0 or grid[i-1][j] == 0: res += 1 if i+1 &gt;= w or grid[i+1][j] == 0: res += 1 return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Reshape the Matrix]]></title>
    <url>%2F2017%2F10%2F19%2FleetCode%2FreshapeTheMatrix%2F</url>
    <content type="text"><![CDATA[Reshape the Matrix原题：In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data. You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were. If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example1 Input:nums =[[1,2], [3,4]]r = 1, c = 4Output:[[1,2,3,4]]Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. Example2 Input:nums =[[1,2], [3,4]]r = 2, c = 4Output:[[1,2], [3,4]]Explanation:There is no way to reshape a 2 2 matrix to a 2 4 matrix. So output the original matrix. Note The height and width of the given matrix is in range [1, 100]. The given r and c are all positive. 题目大意给出多维数组然后转换，不符合要求输出原数组。 解题思路两层循环。代码实现（java）：12345678910111213141516171819class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int w = nums.length, h = nums[0].length; if (w * h != r * c) return nums; int[][] res = new int[r][c]; int row = 0, col = 0; for (int i = 0; i &lt; w; i++) &#123; for (int j = 0; j &lt; h; j++) &#123; res[row][col] = nums[i][j]; col++; if (col == c) &#123; col = 0; row++; &#125; &#125; &#125; return res; &#125;&#125; 找规律，代码实现：123456789101112131415class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int w = nums.length; int h = nums[0].length; if (w * h == r * c) &#123; int[][] res = new int[r][c]; for (int i = 0; i &lt; r * c; i++) &#123; res[i / c][i % c] = nums[i / h][i % h]; &#125; return res; &#125; else &#123; return nums; &#125; &#125;&#125; python实现：12345678910111213141516class Solution(object): def matrixReshape(self, nums, r, c): w, h = len(nums), len(nums[0]) if w * h != r * c: return nums res = [] row = col = 0 for x in range(r): result = [] for y in range(c): result.append(nums[row][col]) col += 1 if col == h: row += 1 col = 0 res.append(result) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Fizz Buzz]]></title>
    <url>%2F2017%2F10%2F19%2FleetCode%2FfizzBuzz%2F</url>
    <content type="text"><![CDATA[Fizz Buzz原题：Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example n = 15,Return:[ “1”, “2”, “Fizz”, “4”, “Buzz”, “Fizz”, “7”, “8”, “Fizz”, “Buzz”, “11”, “Fizz”, “13”, “14”, “FizzBuzz”] 题目大意输入一个数，遍历的输出从1到这个数，遇到三的倍数输出“Fizz”，遇到5的倍数输出“Buzz”，遇到3和5共同的倍数输出“FizzBuzz”。 解题思路循环判断。代码实现（java）：123456789101112class Solution &#123; public List&lt;String&gt; fizzBuzz(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int i = 1; i &lt; n + 1; i++)&#123; if (i % 15 == 0) list.add("FizzBuzz"); else if (i % 3 == 0) list.add("Fizz"); else if (i % 5 == 0) list.add("Buzz"); else list.add(String.valueOf(i)); &#125; return list; &#125;&#125; AC后看到一位大神的代码，他是重写了AbstractList中的get方法，代码实现：123456789101112131415161718192021222324class Solution &#123; private int size = 0; private final List&lt;String&gt; fizzbuzzList = new AbstractList&lt;String&gt;() &#123; @Override public String get(int index) &#123; final int i = index + 1; return i % 15 == 0 ? "FizzBuzz" : i % 5 == 0 ? "Buzz" : i % 3 == 0 ? "Fizz" : String.valueOf(i); &#125; @Override public int size() &#123; return Solution.this.size; &#125; &#125;; public List&lt;String&gt; fizzBuzz(int n)&#123; this.size = n; return fizzbuzzList; &#125;&#125; python实现：123456789101112131415class Solution(object): def fizzBuzz(self, n): res = []; x = 1 while x &lt;= n: if x % 3 == 0 and x % 5 == 0: res.append("FizzBuzz") elif x % 3 == 0: res.append("Fizz") elif x % 5 == 0: res.append("Buzz") else: res.append(str(x)) x += 1 return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threadlocal--源码分析]]></title>
    <url>%2F2017%2F10%2F18%2Fjava%2FthreadLocal%2F</url>
    <content type="text"><![CDATA[Threadlocal详解这个类其实并不是一个线程，只是Thread的一个局部变量。看看官网的解释： 该类提供线程本地变量。这些变量与一般的变量不同，每个线程访问一个线程（通过get或set方法）有自己独立的变量初始化副本。 参数threadLocalHashCode每个对象都有一个HashCode来标示自己的唯一性1234567891011/** * ThreadLocals rely on per-thread linear-probe hash maps attached * to each thread (Thread.threadLocals and * inheritableThreadLocals). The ThreadLocal objects act as keys, * searched via threadLocalHashCode. This is a custom hash code * (useful only within ThreadLocalMaps) that eliminates collisions * in the common case where consecutively constructed ThreadLocals * are used by the same threads, while remaining well-behaved in * less common cases. */ private final int threadLocalHashCode = nextHashCode(); nextHashCode原子类保证线程安全，保证每个对象的hashcode唯一，并且是静态的123456/** * The next hash code to be given out. Updated atomically. Starts at * zero. */ private static AtomicInteger nextHashCode = new AtomicInteger(); HASH_INCREMENT是为了减少碰撞选定的这个值123456/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */ private static final int HASH_INCREMENT = 0x61c88647; nextHashCode()返回原始值，加上HASH_INCREMENT.为了让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table123456/** * Returns the next hash code. */ private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT); &#125; 方法initialValue123protected T initialValue() &#123; return null; &#125; 返回此线程局部变量的当前线程的初始值。返回值为null需要子类覆盖这个方法。 withInitial123public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) &#123; return new SuppliedThreadLocal&lt;&gt;(supplier); &#125; 创建线程局部变量。SuppliedThreadLocal类 get()123456789101112131415161718192021public T get() &#123; //获取当前线程t Thread t = Thread.currentThread(); //返回当前线程t的成员变量ThreadLocalMap ThreadLocalMap map = getMap(t); //map不为null，则获取以当前线程为key的ThreadLocalMap的Entry，如果e不为null，则直接返回该Entry的value； if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; //如果map为null或者e为null，返回setInitialValue()的值。setInitialValue()调用重写的initialValue()返回新值（如果没有重写initialValue将返回默认值null），并将新值存入当前线程的ThreadLocalMap（如果当前线程没有ThreadLocalMap，会先创建一个）。 return setInitialValue(); &#125; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; 返回该线程局部变量的当前线程的值复制。如果变量当前线程没有值，setInitialValue需要从初始化的地方取值。 setInitialValue初始化值的方法1234567891011121314151617private T setInitialValue() &#123; //调用重写的initialValue，返回新值 T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //当前线程的ThreadLocalMap不为空，则直接赋值 if (map != null) map.set(this, value); // 为当前线程创造一个ThreadLocalMap(this, firstValue)并赋初值，this为当前线程 else createMap(t, value); return value; &#125; void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; set12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; ThreadLocalMap下面看看ThreadLocal重要的内部类–ThreadLocalMapThreadLocalMap 是定义在 ThreadLocal 中的静态内部类，它是一种 Hash 的 Map，以 ThreadLocal 为 Key。但是 并不是用的继承自 Object 对象的 hashcode() 方法产生 hash 值 常量123456789101112131415161718192021222324/** * The initial capacity -- MUST be a power of two. */ //Map的初始容量 private static final int INITIAL_CAPACITY = 16; /** * The table, resized as necessary. * table.length MUST always be a power of two. */ //Entry类型的数组，用于存储数据 private Entry[] table; /** * The number of entries in the table. */ //表中的存储数目 private int size = 0; /** * The next size value at which to resize. */ //需要扩容时对应size的阈值。 private int threshold; // Default to 0 构造方法构造函数的第一个参数就是本ThreadLocal实例(this)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。注意一个细节，计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是2的指数，因为这可以使得hash发生冲突的次数减小。1234567ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; set123456789101112131415161718192021222324252627282930313233343536private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; 这里面解决冲突的方式和hashMap不同。如果key == null的话 替换当前的key和value。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; // Back up to check for prior stale entry in current run. // We clean out whole runs at a time to avoid continual // incremental rehashing due to garbage collector freeing // up refs in bunches (i.e., whenever the collector runs). int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // Find either the key or trailing null slot of run, whichever // occurs first for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // If we find key, then we need to swap it // with the stale entry to maintain hash table order. // The newly stale slot, or any other stale slot // encountered above it, can then be sent to expungeStaleEntry // to remove or rehash all of the other entries in run. if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // Start expunge at preceding stale entry if it exists if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // If we didn't find stale entry on backward scan, the // first stale entry seen while scanning for key is the // first still present in the run. if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // If key not found, put new entry in stale slot tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // If there are any other stale entries in run, expunge them if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); &#125; 该方法中会清理没用的entry,调用cleanSomeSlots方法实现的。123456789101112131415private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed; &#125; 总结1.线程间数据隔离（每个线程在自己线程里使用自己的局部变量，各线程间的ThreadLocal对象互不影响）；2.ThreadLocal的应用场景非常多，（获取数据库连接，各大框架都有应用，比如Spring）3.每个Thread里都含有一个ThreadLocalMap的成员变量；4.当应用线程池的时候，由于线程池的线程一般会复用，Thread不结束，这时候用完更需要remove了。5.对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Distribute Candies]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FdistributeCandies%2F</url>
    <content type="text"><![CDATA[Distribute Candies原题：Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. You need to return the sum of the points you could get in all the rounds. Example1 Input: candies = [1,1,2,2,3,3]Output: 3Explanation:There are three different kinds of candies (1, 2 and 3), and two candies for each kind.Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.The sister has three different kinds of candies. Example2 Input: candies = [1,1,2,3]Output: 2Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].The sister has two different kinds of candies, the brother has only one kind of candies. Note The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000]. 题目大意把不同种类的糖平均分两份，一份哥哥一份妹妹，求妹妹获得糖的最多种类数 解题思路求出糖的种类，如果种类大于糖数量的一半，则妹妹最多分的数量为糖数量的一半，否则为糖的种类两种实现（java）：代码实现（java）：1234567891011class Solution &#123; public int distributeCandies(int[] candies) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int candy : candies)&#123; set.add(candy); &#125; if (set.size() &gt; candies.length/2) return candies.length/2; return set.size(); &#125;&#125; 123456789class Solution &#123; public int distributeCandies(int[] candies) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int candy : candies)&#123; set.add(candy); &#125; return Math.min(set.size(), candies.length &gt;&gt; 1); &#125;&#125; python实现：123class Solution(object): def distributeCandies(self, candies): return min(len(set(candies)), len(candies) &gt;&gt; 1)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Baseball Game]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FbaseballGame%2F</url>
    <content type="text"><![CDATA[Baseball Game原题：You’re now a baseball game point recorder. Given a list of strings, each string can be one of the 4 following types: 1.Integer (one round’s score): Directly represents the number of points you get in this round.2.”+” (one round’s score): Represents that the points you get in this round are the sum of the last two valid round’s points.3.”D” (one round’s score): Represents that the points you get in this round are the doubled data of the last valid round’s points.4.”C” (an operation, which isn’t a round’s score): Represents the last valid round’s points you get were invalid and should be removed.Each round’s operation is permanent and could have an impact on the round before and the round after. You need to return the sum of the points you could get in all the rounds. Example1 Input: [“5”,”2”,”C”,”D”,”+”]Output: 30Explanation:Round 1: You could get 5 points. The sum is: 5.Round 2: You could get 2 points. The sum is: 7.Operation 1: The round 2’s data was invalid. The sum is: 5.Round 3: You could get 10 points (the round 2’s data has been removed). The sum is: 15.Round 4: You could get 5 + 10 = 15 points. The sum is: 30. Example2 Input: [“5”,”-2”,”4”,”C”,”D”,”9”,”+”,”+”]Output: 27Explanation:Round 1: You could get 5 points. The sum is: 5.Round 2: You could get -2 points. The sum is: 3.Round 3: You could get 4 points. The sum is: 7.Operation 1: The round 3’s data is invalid. The sum is: 3.Round 4: You could get -4 points (the round 3’s data has been removed). The sum is: -1.Round 5: You could get 9 points. The sum is: 8.Round 6: You could get -4 + 9 = 5 points. The sum is 13.Round 7: You could get 9 + 5 = 14 points. The sum is 27. Note The size of the input list will be between 1 and 1000. Every integer represented in the list will be between -30000 and 30000. 题目大意输入一组字符串：1.数字表示分数2.’+’表示当前轮次的分数等于上两轮分数之和3.’D’表示当前轮次的分数等于上一轮分数加倍4.’C’表示清除上一次的分数 解题思路根据不同的情况做判断，先想到了栈，然后又想到了数组。两种实现（java）：代码实现（java）：1234567891011121314151617181920212223class Solution &#123; public int calPoints(String[] ops) &#123; if (ops == null || ops.length == 0) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int res = 0; for (String op : ops)&#123; if ("C".equals(op))&#123; res -= stack.pop(); &#125;else if ("D".equals(op))&#123; stack.push(stack.peek() * 2); res += stack.peek(); &#125;else if ("+".equals(op))&#123; stack.push(stack.peek() + stack.get(stack.size()-2)); res += stack.peek(); &#125;else &#123; stack.push(Integer.valueOf(op)); res += stack.peek(); &#125; &#125; return res; &#125;&#125; 用栈实现运行时间11ms，用数组实现运行时间8ms，见代码：123456789101112131415161718192021222324252627class Solution &#123; public int calPoints(String[] ops) &#123; if (ops == null || ops.length == 0) return 0; int[] points = new int[ops.length]; int top = -1; int res = 0; for(String op : ops)&#123; if("C".equals(op))&#123; res -= points[top--]; &#125;else if("D".equals(op))&#123; int p = points[top]*2; points[++top] = p; res += p; &#125;else if("+".equals(op))&#123; int p = points[top] + points[top - 1]; points[++top] = p; res += p; &#125;else&#123; int p = Integer.parseInt(op); points[++top] = p ; res += p; &#125; &#125; return res; &#125;&#125; python实现：12345678910111213141516class Solution(object): def calPoints(self, ops): res = 0 points = [] top = -1 for op in ops: if op == "C": points.pop() elif op == "D": points.append(points[-1] * 2) elif op == "+": points.append(points[-1] + points[-2]) else: points.append(int(op)) return sum(points)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Reverse String]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FreverseString%2F</url>
    <content type="text"><![CDATA[Reverse String原题：Write a function that takes a string as input and returns the string reversed. Example Given s = “hello”, return “olleh”. 翻译相对简单，就是翻转一个字符串。 代码实现（java）：12345class Solution &#123; public String reverseString(String s) &#123; return new StringBuilder(s).reverse().toString(); &#125;&#125; 用StringBuilder的reverse()运行时间用了4ms。尝试用了异或位运算，用时减少了一倍，变为2ms，代码实现：12345678910111213141516class Solution &#123; public String reverseString(String s) &#123; char[] str = s.toCharArray(); int begin = 0; int end = s.length() - 1; while (begin &lt; end) &#123; str[begin] = (char) (str[begin] ^ str[end]); str[end] = (char) (str[begin] ^ str[end]); str[begin] = (char) (str[end] ^ str[begin]); begin++; end--; &#125; return new String(str); &#125;&#125; python实现：123class Solution(object): def reverseString(self, s): return s[::-1]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Reverse Words in a String III]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FreverseWords3%2F</url>
    <content type="text"><![CDATA[Reverse Words in a String III原题：Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example Input: “Let’s take LeetCode contest”Output: “s’teL ekat edoCteeL tsetnoc” NoteIn the string, each word is separated by single space and there will not be any extra space in the string. 翻译大意就是给定一个list输出每个单词的顺序原来不变，单词的顺序反转。 解题思路根据空格拆分，然后依次反转每个单词。代码实现（java）：1234567891011121314151617class Solution &#123; public String reverseWords(String s) &#123; String[] strs = s.split(" "); StringBuilder sb = new StringBuilder(); boolean t = true; for(String str : strs)&#123; String resWord = new StringBuilder(str).reverse().toString(); if(t)&#123; sb.append(resWord); t = false; &#125;else&#123; sb.append(" ").append(resWord); &#125; &#125; return sb.toString(); &#125;&#125; python实现：1234567class Solution(object): def reverseWords(self, s): list = s.split() k = [] for n in list: k.append(n[::-1]) return ' '.join(k)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Keyboard Row]]></title>
    <url>%2F2017%2F10%2F16%2FleetCode%2FkeyboardRow%2F</url>
    <content type="text"><![CDATA[Keyboard Row原题：Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. Example Input: [“Hello”, “Alaska”, “Dad”, “Peace”]Output: [“Alaska”, “Dad”] Note1.You may use one character in the keyboard more than once.2.You may assume the input string will only contain letters of alphabet. 翻译大意就是给定一个list输出单词都在同一行的单词。 解题思路设定每行代表一个数字初始值为0，遍历每个单词如果出现在某一行，则该代表该行的值赋为1.代码实现（java）：12345678910111213141516171819202122232425class Solution &#123; public String[] findWords(String[] words) &#123; String line1 = "QWERTYUIOP"; String line2 = "ASDFGHJKL"; String line3 = "ZXCVBNM"; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); for(String word : words)&#123; char[] ch = word.toUpperCase().toCharArray(); int n1 = 0, n2 = 0, n3 = 0; for(char c : ch)&#123; if(line1.indexOf(c) &gt;= 0) n1 = 1; if(line2.indexOf(c) &gt;= 0) n2 = 1; if(line3.indexOf(c) &gt;= 0) n3 = 1; if(n1 + n2 + n3 &gt; 1) break; &#125; if(n1 + n2 + n3 == 1) res.add(word); &#125; return res.toArray(new String[0]); &#125;&#125; python实现（遍历list中的每个单词放到set中判断set中的单词是否都包含在键盘行中）：12345678910class Solution(object): def findWords(self, words): keyBoards = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"] res = [] for word in words: wordUP = word.upper() for keyBoard in keyBoards: if set(wordUP).issubset(set(keyBoard)): res.append(word) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python内置函数--set]]></title>
    <url>%2F2017%2F10%2F16%2Fpython%2FpythonSet%2F</url>
    <content type="text"><![CDATA[描述set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。set 支持 x in set, len(set),和 for x in set。作为一个无序的集合，set不记录元素位置或者插入点。因此，set不支持 indexing, slicing（切片）, 或其它类序列（sequence-like）的操作。 语法set([iterable]) iterable– 可迭代对象 返回值返回新的集合对象。 实例使用12345x = set("facebook")y = set("google")print x, youtput: set(['a', 'c', 'b', 'e', 'f', 'k', 'o']) set(['e', 'o', 'g', 'l']) 交集(x &amp; y)12345x = set("facebook")y = set("google")print x &amp; youtput: set(['e', 'o']) 并集(x | y)12345x = set("facebook")y = set("google")print x | youtput: set(['a', 'c', 'b', 'e', 'g', 'f', 'k', 'l', 'o']) 差集(x - y)12345x = set("facebook")y = set("google")print x - youtput: set(['a', 'c', 'b', 'k', 'f']) 操作add把传入的元素做为一个整个添加到集合中12345x = set("facebook")x.add('vmlp')print xoutput: set(['a', 'c', 'b', 'e', 'f', 'k', 'o', 'vmlp']) update把传入的元素拆分，做为个体传入到集合中 （x |= y ,y只能是set ）12345x = set("facebook")x.update('vmlp')print xoutput: set(['a', 'c', 'b', 'e', 'f', 'k', 'm', 'l', 'o', 'p', 'v']) remove把传入的元素删除,如果不存在则引发 KeyError12345x = set("facebook")x.remove('o')print xoutput: set(['a', 'c', 'b', 'e', 'f', 'k']) 方法issubsetx.issubset(y)相当于 x &lt;= y测试是否x中的每一个元素都在y中12345x = set("book")y = set("booklalagood")print x.issubset(y)output: True issupersetx.issuperset(y)相当于 x &gt;= y测试是否t中的每一个元素都在x中(与issubset相反)12345x = set("book")y = set("booklalagood")print y.issubset(x)output: True unionx.union(y)相当于 x | y返回一个新的set包含x和y中的每一个元素12345x = set("book")y = set("booklalagood")print x.union(y)output: set(['a', 'b', 'd', 'g', 'k', 'l', 'o']) intersectionx.intersection(y)相当于 x &amp; y返回一个新的set包含x和y中的公共元素 differencex.difference(y)相当于 x - y返回一个新的set包含x中有但是y中没有的元素 differencex.symmetric_difference(y)相当于 x ^ y返回一个新的set包含x和y中不重复的元素 copyx.copy()返回set“x”的一个浅复制 intersection_updatex.intersection_update(y)相当于 x &amp;= y返回只保留含有set“y”中元素的set“x” difference_updatex.difference_update(y)相当于 x -= y返回删除了set“y”中含有的元素后的set“x” difference_updatex.symmetric_difference_update(y)相当于x ^= y返回含有 set“y”或者set“x”中有而不是两者都有的元素的set“x” discardx.discard(b)如果在set“x”中存在元素b,则删除 popx.pop()删除并且返回set“x”中的一个不确定的元素,如果为空则引发KeyError clearx.clear()删除set“x”中的所有元素]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python--切片]]></title>
    <url>%2F2017%2F10%2F16%2Fpython%2FpythonSlice%2F</url>
    <content type="text"><![CDATA[什么是切片？可以用方括号加一个下标的方式访问序列的每一个元素，或者通过在方括号中用冒号把开始下标和结束下标分开的方式访问一组连续的元素。序列类型是其元素被顺序放置的一种数据类型结构，这种方式允许通过指定下标的方式来获取某一个数据元素，或者通过指定下标范围来获得一组序列的元素。这种访问序列的方式叫做切片，我们通过切片操作符就可以实现这个操作。 切片操作符[]sequence[index]sequence是序列的名字，index是想要访问元素对应的偏移量。可以使用0到最大值，也可以使用负值。正索引以序列的开始为起点，负索引以序列的结束为起点。如图(引用): [:]sequence[start_index: end_index]通过这种方式可以得到起始索引到结束索引之间的数据。如果没有提供切片会从序列的最开始处开始，直到最末尾处结束。 [::]sequence[start_index: end_index: delta]delta变化量（步长），可以把这个参数当做for循环里的步长一样的东西。 注意: 列表切片产生的是列表的副本，与原列表不是同一份空间。 例子1定义一个列表 str = [1, 2, 3, 4, 5, 6, 7, 8] 12print str[3:] #截取第4个字符到结尾 output: [4, 5, 6, 7, 8] 12print str[:-3] #截取从头开始到倒数第三个字符之前output: [1, 2, 3, 4, 5] 12print str[2] #截取第三个字符 output: 3 12print str[-1] #截取倒数第一个字符 output: 8 12print str[::-1] #创造一个与原字符串顺序相反的字符串 output: [8, 7, 6, 5, 4, 3, 2, 1] 12print str[-3:-1] #截取倒数第三位与倒数第一位之前的字符 output: [6, 7] 12print str[-3:] #截取倒数第三位到结尾output: [6, 7, 8] 12print str[:-5:-3] #逆序截取output: [8, 5] 参考：《Python核心编程中文版（第二版）》]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <url>%2F2017%2F10%2F15%2Fjava%2FhashMap%2F</url>
    <content type="text"><![CDATA[HashMap基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。HashMap有两个参数影响其性能：初始容量和加载因子。默认初始容量是16，加载因子是0.75。容量是哈希表中桶(Entry数组)的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，通过调用resize方法将容量翻倍。本文是基于JDK1.8分析的，JDK 1.8中HashMap的实现有了一些改进，数据存储结构引进了红黑树，使得查询更加的快捷.JDK1.8 HashMap的结构： HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。1Map map = Collections.synchronizedMap(new HashMap()); 也可以使用ConcurrentHashMap。 定义12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 我们可以看出，HashMap继承了AbstractMap抽象类，实现了Map的方法。 属性1234567891011121314151617181920212223242526272829303132333435 //默认初始容量为16，必须为2的幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //最大容量为2的30次方 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; //链表转成红黑树的阈值 static final int TREEIFY_THRESHOLD = 8; //红黑树转为链表的阈值 static final int UNTREEIFY_THRESHOLD = 6; //存储方式由链表转成红黑树的容量的最小阈值 static final int MIN_TREEIFY_CAPACITY = 64; //存储元素的数组，总是2的幂次倍 transient Node&lt;k,v&gt;[] table; //存放具体元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; //存放元素的个数，注意这个不等于数组的长度。 transient int size; //每次扩容和更改map结构的计数器 transient int modCount; //临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; //加载因子 final float loadFactor; 构造方法HashMap有4个构造方法，有参的构造方法验证参数，无参的构造方法用默认的属性。下面我们主要介绍其中的两个构造方法（一）123456789101112public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; 返回目标容量对应的2的幂次方。123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; (二)将m中的所有元素添加至HashMap中1234public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 实现了putAll的操作，将m的所有元素存入本HashMap实例中。12345678910111213141516171819final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125; &#125; 主要方法hashkey的哈希值为数组下标12345static final int hash(Object key) &#123; int h; //右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; get返回指定key所映射的value；如果该键不包含任何映射关系，则返回null1234567891011121314151617181920212223242526272829public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //table不为null，长度大于0，根据hash寻找table中的项也不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //检查第一个节点 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; //为红黑树结点 if (first instanceof TreeNode) //在红黑树中查找 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //否则，在链表中查找 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; put在学习put方法之前先看一下内部类Node123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; Node类是HashMap中内部定义的一个单向链表。Node中存储了key的hash值，键值对，同时还有下一个链表元素。我们重点关注一下equals这个方法，当我们算出的key的hash值相同时，put方法并不会报错，而是继续向这个hash值的链表中添加元素。我们会调用equals方法来比对key和value是否相同，如果equals方法返回false，会继续向链表的尾部添加一个键值对。JDK1.8中引入了红黑树内部类为TreeNode，（由于本人对红黑树不是很了解，后期会补上这部分）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //table未初始化或者长度为0，进行扩容（详见resize方法） if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //根据长度-1和hash值进行按位与运算，算出hash值对应于数组中的位置，从tab中将这个位置上面的内容取出，判断为null时，在这个位置新增一个Node。 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //key存在，覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //如果冲突节点达到8个，调用treeifyBin(tab, hash)，这个treeifyBin首先会去判断当前hash表的长度，如果不足64的话，实际上就只进行resize，扩容table，如果已经达到64，那么才会将冲突项存储结构改为红黑树。 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //如果有相同的hash和key，则退出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //将p调整为下一个节点 p = e; &#125; &#125; //若e不为null，表示已经存在与待插入节点hash、key相同的节点，hashmap后插入的key值对应的value会覆盖以前相同key值对应的value值，就是下面这块代码实现的 if (e != null) &#123; // existing mapping for key V oldValue = e.value; //判断是否修改已插入节点的value if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //超过阀值，扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; resize(扩容)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //如果老的数组容量大于0，首先判断是否大于等于HashMap的最大容量， //如果true，将阈值设置为Integer的最大值，同时数组容量不变 if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //如果扩容后的数组容量小于我们规定的最大数组容量，而且老的数组容量大于等于16， //对数组进行扩容，扩容后的数组容量为原来的两倍；同时阈值也扩容为原来的两倍（左移一位实现） else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; //之前table大小不大于0,而且老的阈值大于0，则新的容量=老的阈值 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; //老的阈值=0，容量和阈值都初始化为默认值，即16和12 else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //如果新的阈值为0，为新的阈值赋值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) //定义一个新的容量的数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //如果老的数组不为空，遍历老的数组 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; //如果链表中只有一个数据，直接重新计算hash值，放入新的数组中 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; //如果e是红黑树，需要将红黑树拆分后放入新的数组中 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 链表优化重hash的代码块 else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; //原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; JDK1.8做了优化： 我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 总结其他方法和上面介绍的方法原理基本一致，有兴趣的同学可以自行查看源码。(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。(3) JDK1.8引入红黑树大程度优化了HashMap的性能。 参考：http://www.importnew.com/20386.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Two Sum II - Input array is sorted]]></title>
    <url>%2F2017%2F10%2F14%2FleetCode%2FtwoSum2%2F</url>
    <content type="text"><![CDATA[Two Sum II - Input array is sorted原题：Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. 翻译大意是给出一个数组（升序）和一个目标数，求数组中的两个数相加正好等于目标数的两个元素的下标 解题思路left代表左下标，right代表右下标，numbers[left] + numbers[right]如果等于target返回两个下标志分别加一，如果大于target，right左移，否则left右移。代码实现（java）：12345678910111213141516class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int left = 0; int right = numbers.length - 1; while(right &gt; left)&#123; int res = numbers[left] + numbers[right]; if(res == target) return new int[]&#123;left + 1, right + 1&#125;; else if(res &lt; target) left++; else right--; &#125; return null; &#125;&#125; 代码实现（python）：12345678910111213class Solution(object): def twoSum(self, numbers, target): left = 0 right = len(numbers) - 1 while(right &gt; left): res = numbers[left] + numbers[right] if res == target: return left + 1, right + 1 elif res &lt; target: left += 1 else: right -= 1 return null]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Add Digits]]></title>
    <url>%2F2017%2F10%2F11%2FleetCode%2FaddDigits%2F</url>
    <content type="text"><![CDATA[Add Digits原题Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. 翻译大概意思就是给你一个数，把这个数的各个位上的数相加，得到一个新的数，重复下去直到最后相加出来的数为个位数为止。 解题思路：我最开始想的是把每位上的数取出来相加，然后利用递归去做，直到得到符合的答案，原题要求不用循环和递归用O(1)的时间复杂度求出结果，很显然这不符合的。然后想到找规律，发现num%9符合规律，测试发现9%9的时候出现问题，于是改成（num－1）％9+1，代码实现（java）：123public int addDigits(int num) &#123; return (num - 1) % 9 + 1; &#125; 代码实现（python）：1234def addDigits(self, num): if(num == 0): return 0 return (num - 1) % 9 + 1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Array Partition I]]></title>
    <url>%2F2017%2F10%2F11%2FleetCode%2FarrayPartition1%2F</url>
    <content type="text"><![CDATA[Array Partition I原题Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example Input: [1,4,3,2] Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = &gt;min(1, 2) + min(3, 4). 翻译大概意思就是给定一个长度为2n的数组，分成n个小组，返回每组中较小值的和sum，使sum尽量大 解题思路：要取sum为最大值，分组的话就要把两个大的数分在一起，然后以此类推，所以先把数组排序，依次把下标为偶数位的值相加即为所求值。代码实现（java）：1234567public int arrayPairSum(int[] nums) &#123; Arrays.sort(nums); int res = 0; for(int i = 0; i &lt; nums.length; i += 2) res += nums[i]; return res; &#125; 发现有很多大神的代码执行时间更少，发现他们用的排序算法是计数排序。每隔一个数进行相加：代码实现（python）：12345678def arrayPairSum(self, nums): if isinstance(nums, list) and len(nums) == 0: return 0 nums.sort() res = 0 for i in range(0, len(nums), 2): res += nums[i] return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Judge Route Circle]]></title>
    <url>%2F2017%2F10%2F10%2FleetCode%2FjudgeRouteCircle%2F</url>
    <content type="text"><![CDATA[Judge Route Circle原题Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle. Example Input: “UD”Output: true Input: “LL”Output: false 翻译大概意思就是起点为（0，0），R(右),L(左),U(上)和D(下).给定一串移动的串，判断最后是否回到原点。 解题思路：这是一个横纵坐标移动的问题，向左移动x–，向右x++，向上y++，向下y–，最后判断 x == 0 &amp;&amp; y == 0即可。代码实现（java）：1234567891011121314151617181920212223242526public boolean judgeCircle(String moves) &#123; if(moves == null || "".equals(moves)) return true; int x = 0; int y = 0; for(int i = 0; i&lt;moves.length(); i++)&#123; char c = moves.charAt(i); switch(c)&#123; case 'U': y++; break; case 'D': y--; break; case 'L': x--; break; case 'R': x++; break; &#125; &#125; if(x == 0 &amp;&amp; y == 0) return true; return false; &#125; 也可以判断给定的字符串中UD和LR是否成对的出现。代码实现（python）：12def judgeCircle(self, moves): return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D')]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread源码分析]]></title>
    <url>%2F2017%2F10%2F10%2Fjava%2Fthread%2F</url>
    <content type="text"><![CDATA[什么是线程？线程可以理解为在进程中独立运行的子任务。线程是CPU调度的最基本单元。线程的资源开销相对于进程的开销是相对较少的，所以我们一般创建线程执行，而不是进程执行。java中要创建一个线程可以继承Thread类和实现Runnable接口。 注意：多线程是异步的。 下面我们来看一下Thread类的源码。12publicclass Thread implements Runnable 从上面的代码中可以看到，Thread实现了Runnable接口，它们之间具有多态关系。创建一个线程可以继承thread类或者实现Runnable接口，这两种创建方式在工作时性质是一样的，没有本质区别。 线程是一个子任务，cpu以不确定的时间来调用线程中的run方法。 native关键字简介1234private static native void registerNatives(); static &#123; registerNatives(); &#125; native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（Java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。不过，对Java外部的调用通常不能移植到其他平台，在applet中还可能引发安全异常。实现本地代码将使您的Java应用程序无法通过100%纯Java测试。但是，如果必须执行本地调用，则要考虑几个准则： 将您的所有本地方法都封装到一个类中，这个类调用单个的DLL。对每一种目标操作系统平台，都可以用特定于适当平台的版本的DLL。这样可以将本地代码的影响减少到最小，并有助于将以后所需要的移植问题考虑在内。 本地方法尽量简单。尽量使您的本地方法对第三方（包括Microsoft）运行时DLL的依赖减少到最小。使您的本地方法尽量独立，以将加载您的DLL和应用程序所需的开销减少到最小。如果需要运行时DLL，必须随应用程序一起提供。 变量name12//线程名，volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。使得该变量是线程间可见的。private volatile String name; priority12//线程执行优先级private int priority; single_step12//是否单独执行此线程private boolean single_step; daemon12//线程是否是守护线程private boolean daemon = false; stillborn12//虚拟机状态 private boolean stillborn = false; target12//实际的线程任务 private Runnable target; group12//这个线程的组 private ThreadGroup group; contextClassLoader12//这个线程的上下文类加载器 private ClassLoader contextClassLoader; inheritedAccessControlContext12//这个线程的继承 private AccessControlContext inheritedAccessControlContext; threadInitNumber12//所有初始化线程的数目 private static int threadInitNumber; threadLocals &amp; inheritableThreadLocals123//这是为ThreadLocal类维护的一些变量ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; stackSize12//此线程请求的堆栈大小，如果创建者未指定堆栈大小，则为0。虚拟机可以用这个数字来做任何喜欢的事情一些虚拟机将忽略它。 private long stackSize; nativeParkEventPointer12//本地线程终止后仍然存在的JVM私有状态。 private long nativeParkEventPointer; tid &amp; threadSeqNumber123//线程id相关private long tid;private static long threadSeqNumber; threadStatus12//线程状态，初始化为指示线程尚未启动private volatile int threadStatus = 0; blocker12//在可中断的I / O操作（如果有）中阻塞此线程的对象。在设置此线程的中断状态后，应调用阻塞程序的中断方法。private volatile Interruptible blocker; 线程优先级12345678//线程为最低优先级。 public final static int MIN_PRIORITY = 1; //分配给线程的默认优先级。 public final static int NORM_PRIORITY = 5; //线程拥有最高优先级 public final static int MAX_PRIORITY = 10; native方法123456789101112131415161718192021222324252627282930313233//返回对当前正在执行的线程对象的引用。 public static native Thread currentThread(); //使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了 public static native void yield();//当前正在执行的线程（this.currentThread()）休眠（暂停执行）指定的毫秒数，这取决于系统定时器和调度程序的精度和准确性。线程不会丢失monitors。public static native void sleep(long millis) throws InterruptedException;//通过C代码初始化线程需要的系统资源。 private native void start0();//强制停止一个线程（不建议使用） @Deprecated public final synchronized void stop(Throwable obj) //只是设置中断标志 private native void interrupt0(); //检查一个线程是否处于活动状态。（活动状态指已经启动且尚未终止） public final native boolean isAlive(); //暂停线程 private native void suspend0(); //重新激活一个线程 private native void resume0(); //设置线程优先级 private native void setPriority0(int newPriority);//放弃当前cpu资源，让给其他任务（但是放弃的时间不确定） public static native void yield(); 构造方法Thread有好8个构造方法，最终都是调用这个辅助构造函数。接下来我们就来详细的看看init方法到底是怎么来初始化线程的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 初始化线程 * * @param g 线程组 * @param target run（）方法被调用的对象 * @param name 新线程的name * @param stackSize 新线程所需的堆栈大小，零表示此参数将被忽略。 * @param acc AccessControlContext继承，或AccessController.getContext（）为null * @param inheritThreadLocals 如果&#123;@code true&#125;，继承初始值来自构造线程的可继承线程 */private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; if (name == null) &#123; throw new NullPointerException("name cannot be null"); &#125; this.name = name; //当前线程就是该线程的父线程 Thread parent = currentThread(); //获取系统的安全管理器 SecurityManager security = System.getSecurityManager(); if (g == null) &#123; //security不为null时，线程所在group为security的group if (security != null) &#123; g = security.getThreadGroup(); &#125; //security为null时，使用父线程的group if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; //确定当前运行的线程是否有权限修改此线程组。 g.checkAccess(); //检查权限 if (security != null) &#123; if (isCCLOverridden(getClass())) &#123; security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); &#125; &#125; g.addUnstarted(); //将线程组、守护线程、优先级等设置为父线程的对应属性 this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); //从父线程继承可继承的ThreadLocal if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); //设置该线程堆栈大小 this.stackSize = stackSize; //设置线程id tid = nextThreadID(); &#125; 主要方法启动start12345678910111213141516171819202122232425//线程启动方法public synchronized void start() &#123; //当前线程初始化还未做好，不能start，0-&gt;NEW状态 if (threadStatus != 0) throw new IllegalThreadStateException(); //通知group该线程即将启动，group的nUnstartedThreads减1,nthreads加1 group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; //启动不成功，group设置当前线程启动失败 if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125; &#125; 启动线程其实做了这么几件事： 检查线程是否初始化； 通知group，线程启动； 调用native方法start0()启动线程，启动后执行run()方法； 启动失败容错处理。 run123456@Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 真正的run其实是目标类的run方法,target实际上要保存的是一个Runnable接口的实现的引用。 停止停止一个线程可以用Thread.stop()方法，但最好不要使用它。因为这个方法是不安全的。（可能使一些清理性的工作得不到完成，对锁定的对象进行“解锁”，出现数据不一致。） stop12345678910111213141516171819//强制线程停止执行。（不建议使用） @Deprecatedpublic final void stop() &#123; SecurityManager security = System.getSecurityManager(); if (security != null) &#123; checkAccess(); if (this != Thread.currentThread()) &#123; security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION); &#125; &#125; // A zero status value corresponds to "NEW", it can't change to // not-NEW because we hold the lock. if (threadStatus != 0) &#123; resume(); // Wake up thread if it was suspended; no-op otherwise &#125; // The VM can handle all thread states stop0(new ThreadDeath()); &#125; interrupt1234567891011121314public void interrupt() &#123; if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125; &#125; interrupt0(); &#125; interrupt()方法只是在当前线程中打了一个停止标记，并不是真的停止了线程。 interrupted &amp; isInterrupted123456789//测试当前线程是否已经中断(线程的中断状态由该方法清除)public static boolean interrupted() &#123; return currentThread().isInterrupted(true); &#125;//测试线程是否中断（不清除线程的中断状态） public boolean isInterrupted() &#123; return isInterrupted(false); &#125; 几种停止线程的方法 可以通过判断当前线程是否中断，如果是中断抛出异常去停止一个线程。 可以在sleep（）状态下停止线程。 interrupt()方法和return结合使用。 比较建议使用“抛异常”的方法实现停止线程，因为在catch中可以对异常进行相关的处理，而且使用异常处理能更好、更方便的控制程序的运行流程。 暂停线程暂停线程意味着此线程还可以恢复运行。在java中可以使用suspend()方法暂停线程，使用resume()方法恢复线程。 suspend123456//暂停一个线程（不推荐使用）依靠本地方法suspend0，可能会造成死锁和不同步@Deprecated public final void suspend() &#123; checkAccess(); suspend0(); &#125; resume123456//重新激活一个线程（不推荐使用）依靠本地方法resume0，可能会造成死锁和不同步@Deprecated public final void resume() &#123; checkAccess(); resume0(); &#125; join123456789101112131415161718192021222324public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125; &#125; join会锁住当前线程，等待子线程结束之后继续执行。如图: 其他方法exit1234567891011121314//由系统调用，可以使Thread在销毁前释放资源private void exit() &#123; if (group != null) &#123; group.threadTerminated(this); group = null; &#125; target = null; /* Speed the release of some of these resources */ threadLocals = null; inheritableThreadLocals = null; inheritedAccessControlContext = null; blocker = null; uncaughtExceptionHandler = null; &#125; checkAccess1234567//确定当前运行的线程是否有权限修改此线程。public final void checkAccess() &#123; SecurityManager security = System.getSecurityManager(); if (security != null) &#123; security.checkAccess(this); &#125; &#125; dumpStack1234//将当前线程的堆栈跟踪打印到标准错误流。此方法仅用于调试。public static void dumpStack() &#123; new Exception("Stack trace").printStackTrace(); &#125; 还有一些方法没有看到，就不一一概述了。 线程的状态Thread中有个状态枚举： NEW：初始状态，线程被构建，还未调用start()方法； RUNNABLE：运行状态，在java多线程模型中，就绪和运行都是运行状态； BLOCKED：阻塞状态； WAITING：等待状态，比如中断，需要其他的线程来唤醒； TIME_WAITING：超时等待，可以在指定的时间内自行返回； TERMINATED：终止状态，线程执行完毕。 java层次的状态转换图 操作系统层次的状态转换图 总结wait()和notify/notifyAll()线程中常用wait()和notify/notifyAll()方法，这是Object类中的方法。 wait()线程进入WAITING状态，并且释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁，等待其他线程调用“锁标志“对象的notify或notifyAll方法恢复wait方法是一个本地方法，其底层是通过一个叫做监视器锁的对象来完成的，所以调用wait方式时必须获取到monitor对象的所有权即通过Synchronized关键字，否则抛出IllegalMonitorStateException异常 notify &amp; notifyAll()在同一对象上去调用notify/notifyAll方法，就可以唤醒对应对象monitor上等待的线程了。notify和notifyAll的区别在于前者只能唤醒monitor上的一个线程，对其他线程没有影响，而notifyAll则唤醒所有的线程 线程复用像线程池类高效的原因在于，线程池中的线程在完成任务后，不会销毁，而且缓存起来，每当用户请求一个线程处理任务时，线程池可以利用缓存的空闲线程来处理用户任务，这样避免了线程创建销毁带来的开销。在Thread类中有一个Runnable target的域，只需将target替换成新的Runnable即可。后续会写一些线程池相关的文章。 更深入学习Thread类中有许多native方法，更深入的学习后续还需研究研究jvm的源码。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Valid Palindrome]]></title>
    <url>%2F2017%2F10%2F09%2FleetCode%2FvalidPalindrome%2F</url>
    <content type="text"><![CDATA[原题Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example, “A man, a plan, a canal: Panama” is a palindrome.“race a car” is not a palindrome. 翻译：给定一个字符串，判断其是否为一个回文串。只包含字母和数字，忽略大小写。 解题思路利用首尾指针，找到符合条件的索引，进行比较，符合条件进行下一组比较，不相等返回false，直到所有的字母都处理完。 代码实现java实现，时间复杂度O(n).12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public Boolean solution(String str)&#123; if(str == null || "".equals(str)) return true; str = str.toLowerCase(); int left = 0; int right = str.length() - 1; while (left &lt; right) &#123; char leftChar = str.charAt(left); char rightChar = str.charAt(right); while (!isValid(leftChar))&#123; left++; leftChar = str.charAt(left); if (left &gt;= right) return true; &#125; while (!isValid(rightChar))&#123; right--; rightChar = str.charAt(right); if (right &lt;= left) return true; &#125; if (leftChar != rightChar) return false; left++; right--; &#125; return true; &#125; private Boolean isValid(Character character)&#123; if (Character.isLetterOrDigit(character)) return true; return false; &#125;&#125; python实现1234567891011121314151617181920212223242526272829303132333435class Solution: def palindrome(self, str): if str.strip() == "": return True str = str.lower() left = 0 right = len(str) - 1 while(left &lt; right): leftStr = str[left] rightStr = str[right] while(not self.__isvalid(leftStr)): left += 1 leftStr = str[left] if(left &gt;= right): return True while(not self.__isvalid(rightStr)): right -= 1 rightStr = str[right] if(right &lt;= left): return True if(leftStr != rightStr): return False left += 1 right -= 1 def __isvalid(self, str): if(str.isalnum()): return True return Falseif __name__=="__main__": str = "A man, a plan, a canal: Panama" solution = Solution() print solution.palindrome(str)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2017%2F10%2F08%2Fjava%2FinnerClass%2F</url>
    <content type="text"><![CDATA[内部类可以将一个类的定义放在另一个类的定义内部，这就是内部类。内部类是一种非常有用的特性，因为它允许把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。然而，内部类和组合式完全不同的概念。 创建内部类1234567891011121314151617public class Outer &#123; class Inner &#123; private String str; Inner(String str) &#123; this.str = str; &#125; &#125; public Inner to(String str)&#123; return new Inner(str); &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Inner inner = outer.to("hello"); &#125;&#125; 编译后的class文件如下：123456789101112131415161718192021public class Outer &#123; public Outer() &#123; &#125; public Outer.Inner to(String str) &#123; return new Outer.Inner(str); &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Outer.Inner inner = outer.to("hello"); &#125; class Inner &#123; private String str; Inner(String str) &#123; this.str = str; &#125; &#125;&#125; 如果想从外部类的非静态方法之外的的任意位置创建某个内部类的对象，那么必须具体的指明这个对象的类型：OuterClassName.InnerClassName。（由虚拟机完成） 使用.this和.new如果需要生成对外部类对象的引用可以使用.this。这样产生的引用自动的具有正确的类型，这一点在编译期就被检查并完成，因此在运行期时并没有任何开销。1234567891011121314151617181920public class DotThis &#123; void f()&#123; System.out.println("f()"); &#125; public class Inner&#123; public DotThis outer()&#123; return DotThis.this; &#125; &#125; public Inner inner()&#123; return new Inner(); &#125; public static void main(String[] args) &#123; DotThis dotThis = new DotThis(); Inner inner = dotThis.inner(); inner.outer().f(); &#125;&#125; 如果要告知某些其他对象，去创建某个内部类对象。需要使用.new关键字。12345678public class DotNew &#123; public class Inner&#123; &#125; public static void main(String[] args) &#123; DotNew dotNew = new DotNew(); Inner inner = dotNew.new Inner(); &#125;&#125; 再拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会连接到创建它的外部类对象上。但是如果创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。 匿名内部类12345678910111213public class Parcel &#123; public interface Contents&#123; int value(); &#125; public Contents contents()&#123; return new Contents()&#123; private int i = 11; public int value()&#123; return i; &#125; &#125;; &#125;&#125; 简化形式：123456789101112131415public class Parcelb &#123; public interface Contents&#123; int value(); &#125; class MyContents implements Contents&#123; @Override public int value() &#123; return 0; &#125; &#125; public Contents contents()&#123; return new MyContents(); &#125;&#125; 注意：在jdk1.7及以前，如果一个匿名内部类使用其外部定义的对象，该对象需要使用final修饰，不然会得到一个编译期错误，但是jdk1.8这个final关键字由虚拟机默认加上了。 嵌套类如果不需要内部类对象与其外部类对象之间有联系，可以将内部类声明为static，通常称为嵌套类。想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式的保存了一个引用，指向创建它的外部类对象。当内部类是static时：1、创建嵌套类的对象，并不需要其外围类的对象。2、不能从嵌套类的对象中访问非静态的外围类对象。嵌套类和普通内部类还有一个区别。普通内部类不能包含static数据和字段，也不能包含嵌套类。但是嵌套类可以包含所有这些。1234567891011121314public interface ClassInInterface &#123; void h(); class Test implements ClassInInterface&#123; @Override public void h() &#123; System.out.println("h"); &#125; public static void main(String[] args) &#123; new Test().h(); &#125; &#125;&#125; 以上代码虚拟机在编译之后会把类修饰成static。内部类被嵌套多少层都可以访问所有它所嵌入的外部类的所有成员。 为什么使用内部类每个内部类都能独立的继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。这样的话就可以利用内部类实现类似于c++的多重继承。 使用内部类，还可以获得其他的一些特性：1、内部类可以有多个实例，没个实例都有自己的状态信息，并且与外部类的状态信息相互独立。2、在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。3、创建内部类对象的时刻并不依赖于外部类对象的创建。4、内部类就是一个独立的实体。闭包、回调，和控制框架中都有内部类的身影。 内部类的继承因为内部类的构造器必须连接到指向外部类对象的引用，所以在继承内部类的时候，指向外部类对象的引用必须被初始化。1234567891011public class InnerExtends &#123; class WithInnter&#123; class Inner&#123;&#125; &#125; public class InheritInner extends WithInnter.Inner&#123; public InheritInner(WithInnter withInnter) &#123; withInnter.super(); &#125; &#125;&#125; 内部类的重载这块还没看到，以后找时间补上。参考：《java编程思想》]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode题解]]></title>
    <url>%2F2017%2F10%2F01%2FleetCodeList%2F</url>
    <content type="text"><![CDATA[leetCode是一个非常值得学习的网站，以下是本人近期刷leetCode的总结，里面的代码都是AC通过的，该博文会持续更新。 383. Ransom Note349. Intersection of Two Arrays122. Best Time to Buy and Sell Stock II453. Minimum Moves to Equal Array Elements598. Range Addition II492. Construct the Rectangle283. Move Zeroes171. Excel Sheet Column Number690. Employee Importance669. Trim a Binary Search Tree476. Number Complement617. Merge Two Binary Trees461. Hamming Distance389. Find the Difference448. Find All Numbers Disappeared in an Array371. Sum of Two Integers657. Judge Route Circle561. Array Partition I500. Keyboard Row557. Reverse Words in a String III344. Reverse String682. Baseball Game575. Distribute Candies258. Add Digits1. Two Sum125. Valid Palindrome167. Two Sum II - Input array is sorted412. Fizz Buzz566. Reshape the Matrix463. Island Perimter496. Next Greater Element I521. Longest Uncommon Subsequence I292. Nim Game136. Single Number693. Binary Number with Alternating Bits485. Max Consecutive Ones520. Detect Capital]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode--Two Sum]]></title>
    <url>%2F2017%2F09%2F30%2FleetCode%2FtwoSum%2F</url>
    <content type="text"><![CDATA[Two Sum原题：Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 翻译：给定一个整数数组，返回两个数字的索引，使它们相加到一个特定的目标。你可以假设每个输入都只有一个解决方案，而你可能不会使用相同的元素两次。 解决思路：第一种可以用两层循环（时间复杂度O(n^2)），实现代码：123456789public int[] twoSum1(int[] tmp, int target) &#123; for (int i = 0; i &lt; tmp.length; i++)&#123; for (int j = i + 1; j &lt; tmp.length; j++)&#123; if (tmp[i] + tmp[j] == target) return new int[]&#123;i, j&#125;; &#125; &#125; throw new IllegalArgumentException("don't have two sum equals target"); &#125; 第二种可以定义一个map然后把数组的值作为key，索引作为value存到map中，循环数组，每次循环用目标值减去该值，用结果作为key去map中查找，找到了返回索引数组，没找到把该次和循环的值和索引作为key和value存入map中，直到找到结果。（时间复杂度O(n)）实现：1234567891011public int[] twoSum(int[] tmp, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i&lt;tmp.length; i++)&#123; int m = target - tmp[i]; if (map.containsKey(m)) &#123; return new int[] &#123; map.get(m), i &#125;; &#125; map.put(tmp[i], i); &#125; throw new IllegalArgumentException("No two sum solution"); &#125; python实现最近也在学习python，附上python的实现（第二种方案）:1234567891011121314151617class Solution: def twoSum(self, nums, target): map = &#123;&#125; i = 0 for x in nums: if target - x in map: return i,map[target - x] print str(x) + " " + str(i) map[x] = i print map i += 1 returnif __name__=="__main__": a = [5, 4, 9, 3, 7] solution = Solution() print solution.twoSum(a, 10)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2017%2F09%2F29%2Fjava%2FarrayList%2F</url>
    <content type="text"><![CDATA[ArrayListList接口的可调整大小的数组实现。实现所有可选列表操作，并允许所有元素，包括null。除了实现List接口之外，该类还提供了一些方法来操作在内部使用来存储列表的数组的大小。 （这个类大致相当于Vector，除了它是不同步的。）size，isEmpty，get，set，iterator和listIterator操作在常量运行。添加操作以摊销的常数运行，即添加n个元素需要O（n）个时间。所有其他操作都以线性时间运行（粗略地说）。与LinkedList实现相比，常数因子较低。每个ArrayList实例都有一个容量。容量是用于存储列表中的元素的数组的大小。它总是至少与列表大小一样大。当元素被添加到ArrayList时，其容量会自动增长。增长政策的细节不包括增加元素具有不变的摊销时间成本的事实。在使用ensureCapacity操作添加大量元素之前，应用程序可以增加ArrayList实例的容量。这可能会减少增量重新分配的数量。arrayList是线程非安全的。如果要实现线程安全，可以： List list = Collections.synchronizedList(new ArrayList(…)); 使用Iterator去遍历arrayList，如果列表在迭代器创建之后的任何时间被结构化地修改，除了通过迭代器自己的remove或add方法之外，都会抛出一个ConcurrentModificationException，下面这段代码中，因为在iterator创建之后调用了ArrayList的remove方法，所以会抛出异常。12345Iterator iterator = list.iterator(); while (iterator.hasNext())&#123; list.remove(0); iterator.remove(); &#125; ArrayList的实现：12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList几个比较重要的常量：1234/** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; 默认初始容量为10。为什么定义为10？官网上没有给出解释，带着这个疑问我Google了一下，这个默认初始容量可以为任意正整数，为1太少，肯定会做一些大小的调整，100会浪费掉空间，前辈们肯定是做了性能分析和空间分析取出了中间值。1234/** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 用于空实例的共享空数组实例。123456/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 一个空数组实例，当用户没有指定 ArrayList 的容量时(即调用无参构造函数)，返回的是该数组==&gt;刚创建一个 ArrayList 时，其内数据量为 0。当用户第一次添加元素时，该数组将会扩容，变成默认容量为10(DEFAULT_CAPACITY)的一个数组===&gt;通过ensureCapacityInternal()实现，它与 EMPTY_ELEMENTDATA 的区别就是：该数组是默认返回的，而后者是在用户指定容量为0时返回。12345678/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. * */transient Object[] elementData; // non-private to simplify nested class access 存储ArrayList元素的数组缓冲区。ArrayList的容量是此数组缓冲区的长度。任何空的ArrayList elementData的值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA（就是一个空数组）当第一个元素被添加的时候，elementData会扩大到DEFAULT_CAPACITY（也就是10）注意：一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。transient关键字用来用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。ArrayList在序列化的时候会调用writeObject，直接将size和element写入ObjectOutputStream；反序列化时调用readObject，从ObjectInputStream获取size和element，再恢复到elementData。为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。12345/** * The size of the ArrayList (the number of elements it contains). * @serial */ private int size; ArrayList的大小（包含的元素数）。12345678910111213141516171819202122232425262728293031323334353637383940private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; 构造方法ArrayList一共有三个构造方法：123456789101112131415161718/** * Constructs an empty list with the specified initial capacity. * 构造一个指定长度的空列表 * @param initialCapacity the initial capacity of the list * 列表的初始容量 * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; 第一个构造方法主要用于构造一个指定长度的空列表，参数为需要构造列表的初始容量，在这里我们看到当initialCapacity == 0 的时候 elementData = EMPTY_ELEMENTDATA 123456/** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 第二个构造方法构造一个初始容量为10的空list。1234567891011121314151617181920/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) //如果返回值不是Object[]转为Object[] elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 第三个构造方法则将传入的集合转成数组赋值给elementData,如果为空则赋值为上面的共享空数组实例（EMPTY_ELEMENTDATA）。 主要方法接下来看一看ArrayList的主要方法（方法太多就不一一介绍了，有兴趣的同学可以自己看看一源码）：123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 返回指定元素在list中第一次出现的位置。需要注意的是当传入的值为null时并不会报错，因为null也可以作为元素插入ArrayList,查询方式为循环依次查找。如果没有匹配到返回-1。123456789101112public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 与indexOf同理，不过lastIndexOf方法的查找方式为从后向前查找。1234567891011public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; 对原有arrayList实例的浅拷贝。123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; 返回一个新的Object数组，对该数组操作不会影响原有list12345678910@SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; 该方法是传入一个泛型数组a,当a.length&lt;size时，按照list的size创建一个新的数组返回，数组中包含所有list的元素。如果a.length&gt;=size时，则将 list 中的元素按顺序存入 a 中，然后a[list.size] = null, a[list.size + 1] 及其后的元素依旧是 a 的元素,附上测试代码：12345678910public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("a"); list.add("b"); list.add("c"); String[] s = new String[5]; s[0] = "0";s[1] = "1";s[2] = "2";s[3] = "3";s[4] = "4"; String[] c = list.toArray(s); System.out.println(c.length +" " + c[0] + " " + c[1] + " " + c[2] + " " + c[3] + " " + c[4]); &#125; 输出：5 a b c null 4请注意这句话 Make a new array of a’s runtime type, but my contents创建一个新的数组的运行时类型，就是说返回的并不一定是Object[],而是运行时的类型，为什么会出现这种情况呢？原因很简单，因为由于继承的原因，我们父类实例的具体类型，实际上是取决于在 new 时，我们所使用的子类类型。12345public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; 返回指定位置的元素。rangeCheck method: 该方法判断了如果index &gt;= size 则throw一个 IndexOutOfBoundsExceptionelementData method：返回在索引为 index 的元素，主要是避免每次取值都需要强转（看到这里不得不佩服前辈们，要是我自己来写目前肯定封装的不会这么好）1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; 该方法是在指定索引处插入指定元素，并把被替换的元素返回。12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code //防止溢出 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //这里的oldCapacity &gt;&gt; 1相当于 oldCapacity/2 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; add方法就是向list末尾添加数据，但是这时候要考虑容量问题。ensureCapacityInternal方法：若 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 即{}，则取 minCapacity 为 默认容量和参数 minCapacity 之间的最大值。 这里需要介绍一下modCount变量，他是父类AbstractList中的变量主要用于记录arrayList结构变化&gt;的次数，每变化一次增加1.拥有这个参数的方法都是线程不安全的，在一个迭代器初始的时候会赋予它调&gt;用这个迭代器的对象的mCount，如何在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存&gt;储的mcount不一样那就抛异常 grow方法:增加容量以确保它至少能够容纳最小容量参数指定的元素数。如果扩容后大于最大存储容量,则调用hugeCapacity方法，MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8（为什么是Integer.MAX_VALUE - 8呢？只是为了避免一些机器内存溢出，最大长度依然是Integer.MAX_VALUE，并不是Integer.MAX_VALUE-8） 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 在该列表中的指定位置插入指定的元素。将当前位于该位置的元素（如果有）和任何后续元素（向其索引添加一个）移动。1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 移除指定索引位置的元素：index 之后的所有元素依次左移一位 12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; 移除指定的一个元素，索引位置最低的。123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 删除此列表的所有元素。 12345678public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; 将一个集合的所有元素顺序添加到list末尾。12345678910111213141516public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 从指定的位置开始将指定集合中的所有元素插入到此列表中。将当前处于该位置的元素（如果有的话）和随后的任何元素移动到右边（增加其索引）。新元素将按照指定集合的迭代器返回的顺序显示在列表中。123456789101112131415161718192021222324252627282930313233public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; 移除list中和c中共有的元素。1234public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; 保留list中和c中共有的元素。 总结1、ArrayList基于数组实现，其内存储元素的数组为elementData2、ArrayList中EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY._ELEMENTDATA虽然都是空数组，但是使用场景不同。前者是通过ArrayList(int initialCapacity)该构造方法直接指定初试容量为0时，后者是用户直接使用无参构造创建ArrayList时。3、ArrayList的扩容计算为newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 且扩容并非是无限制的，有内存限制、虚拟机限制。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO + github 创建自己的个人博客]]></title>
    <url>%2F2017%2F09%2F24%2FhexoBlog%2F</url>
    <content type="text"><![CDATA[hexo + github 创建自己的个人博客最近想搞一个自己的博客，写一些自己平时工作中的积累，终于搭好了，写一下搭建博客的过程。hexo是一款基于Node.js的静态博客框架,所以安装node.js是必须的（这个就不写了，node官网下载，安装）。申请GitHub（必须）作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 安装hexonode和git安装好后创建一个文件夹blog，安装hexo： sudo npm install -g hexo 执行init命令初始化hexo: hexo init 生成静态页面: hexo generate（hexo g也可以） 配置github建立Repository 建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联，我的blog在本地/user/local/bin/blog，blog是我之前建的东西也全在这里面，有： _config.yml node_modules public source db.json package.json scaffolds themes 现在我们需要_config.yml文件，来建立关联，命令： vi _config.yml 翻到最下面，改成我这样子的 deploy: type: git repo: https://github.com/yougithub/youname.github.io.git branch: master repo也可以写成yougithubname:youpassword@https://github.com/yougithub/youname.github.io.git注意所有的：后面都有一个空格。 生成添加秘钥在终端（Terminal）输入： ssh-keygen -t rsa -C “Github的注册邮箱地址” 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入https://github.com/settings/ssh： 将复制的内容粘贴到Key的输入框，随便写好Title里面的内容，点击Add SSH key按钮即可。可以本地启动服务进行预览，命令： hexo server (hexo s 也可以) 浏览器输入localhost:4000 每次部署的步骤，可按以下三步来进行。 hexo clean hexo generate(hexo g) hexo deploy(hexo d) 参考：http://www.jianshu.com/p/465830080ea9http://www.jianshu.com/p/e99ed60390a8 标签页／分类页 参考：http://theme-next.iissnan.com/theme-settings.html#syntax-highlight-scheme 头像／logo 参考：http://cherryblog.site/Hexo-high-level-tutorialcloudmusic,bg-customthemes-statistical.html 站内搜索 参考：https://zetaoyang.github.io/post/2016/07/08/hexo-localsearch.html]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>

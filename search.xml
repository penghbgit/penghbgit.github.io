<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Valid Palindrome]]></title>
    <url>%2F2017%2F10%2F09%2FvalidPalindrome%2F</url>
    <content type="text"><![CDATA[算法练习原题Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example, “A man, a plan, a canal: Panama” is a palindrome.“race a car” is not a palindrome. 翻译：给定一个字符串，判断其是否为一个回文串。只包含字母和数字，忽略大小写。 解题思路利用首尾指针，找到符合条件的索引，进行比较，符合条件进行下一组比较，不相等返回false，直到所有的字母都处理完。 代码实现java实现，时间复杂度O(n).123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public Boolean solution(String str)&#123; if(str == null || str.equals("")) throw new NullPointerException(); str = str.toLowerCase(); int left = 0; int right = str.length() - 1; while (left &lt; right) &#123; char leftChar = str.charAt(left); char rightChar = str.charAt(right); while (!isValid(leftChar))&#123; left++; leftChar = str.charAt(left); if (left &gt;= right) return true; &#125; while (!isValid(rightChar))&#123; right--; rightChar = str.charAt(right); if (right &lt;= left) return true; &#125; if (leftChar != rightChar) return false; left++; right--; &#125; return true; &#125; private Boolean isValid(Character character)&#123; if (character &gt;= 'a' &amp;&amp; character &lt;= 'z') return true; if (character &gt;= 0 &amp;&amp; character &lt;= 9) return true; return false; &#125;&#125; python实现123456789101112131415161718192021222324252627282930313233class Solution: def palindrome(self, str): str = str.lower() left = 0 right = len(str) - 1 while(left &lt; right): leftStr = str[left] rightStr = str[right] while(not self.__isvalid(leftStr)): left += 1 leftStr = str[left] if(left &gt;= right): return True while(not self.__isvalid(rightStr)): right -= 1 rightStr = str[right] if(right &lt;= left): return True if(leftStr != rightStr): return False left += 1 right -= 1 def __isvalid(self, str): if(str.isalnum()): return True return Falseif __name__=="__main__": str = "A man, a plan, a canal: Panama" solution = Solution() print solution.palindrome(str)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2017%2F10%2F08%2FinnerClass%2F</url>
    <content type="text"><![CDATA[内部类可以将一个类的定义放在另一个类的定义内部，这就是内部类。内部类是一种非常有用的特性，因为它允许把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。然而，内部类和组合式完全不同的概念。 创建内部类1234567891011121314151617public class Outer &#123; class Inner &#123; private String str; Inner(String str) &#123; this.str = str; &#125; &#125; public Inner to(String str)&#123; return new Inner(str); &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Inner inner = outer.to("hello"); &#125;&#125; 编译后的class文件如下：123456789101112131415161718192021public class Outer &#123; public Outer() &#123; &#125; public Outer.Inner to(String str) &#123; return new Outer.Inner(str); &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Outer.Inner inner = outer.to("hello"); &#125; class Inner &#123; private String str; Inner(String str) &#123; this.str = str; &#125; &#125;&#125; 如果想从外部类的非静态方法之外的的任意位置创建某个内部类的对象，那么必须具体的指明这个对象的类型：OuterClassName.InnerClassName。（由虚拟机完成） 使用.this和.new如果需要生成对外部类对象的引用可以使用.this。这样产生的引用自动的具有正确的类型，这一点在编译期就被检查并完成，因此在运行期时并没有任何开销。1234567891011121314151617181920public class DotThis &#123; void f()&#123; System.out.println("f()"); &#125; public class Inner&#123; public DotThis outer()&#123; return DotThis.this; &#125; &#125; public Inner inner()&#123; return new Inner(); &#125; public static void main(String[] args) &#123; DotThis dotThis = new DotThis(); Inner inner = dotThis.inner(); inner.outer().f(); &#125;&#125; 如果要告知某些其他对象，去创建某个内部类对象。需要使用.new关键字。12345678public class DotNew &#123; public class Inner&#123; &#125; public static void main(String[] args) &#123; DotNew dotNew = new DotNew(); Inner inner = dotNew.new Inner(); &#125;&#125; 再拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会连接到创建它的外部类对象上。但是如果创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。 匿名内部类12345678910111213public class Parcel &#123; public interface Contents&#123; int value(); &#125; public Contents contents()&#123; return new Contents()&#123; private int i = 11; public int value()&#123; return i; &#125; &#125;; &#125;&#125; 简化形式：123456789101112131415public class Parcelb &#123; public interface Contents&#123; int value(); &#125; class MyContents implements Contents&#123; @Override public int value() &#123; return 0; &#125; &#125; public Contents contents()&#123; return new MyContents(); &#125;&#125; 注意：在jdk1.7及以前，如果一个匿名内部类使用其外部定义的对象，该对象需要使用final修饰，不然会得到一个编译期错误，但是jdk1.8这个final关键字由虚拟机默认加上了。 嵌套类如果不需要内部类对象与其外部类对象之间有联系，可以将内部类声明为static，通常称为嵌套类。想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式的保存了一个引用，指向创建它的外部类对象。当内部类是static时：1、创建嵌套类的对象，并不需要其外围类的对象。2、不能从嵌套类的对象中访问非静态的外围类对象。嵌套类和普通内部类还有一个区别。普通内部类不能包含static数据和字段，也不能包含嵌套类。但是嵌套类可以包含所有这些。1234567891011121314public interface ClassInInterface &#123; void h(); class Test implements ClassInInterface&#123; @Override public void h() &#123; System.out.println("h"); &#125; public static void main(String[] args) &#123; new Test().h(); &#125; &#125;&#125; 以上代码虚拟机在编译之后会把类修饰成static。内部类被嵌套多少层都可以访问所有它所嵌入的外部类的所有成员。 为什么使用内部类每个内部类都能独立的继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。这样的话就可以利用内部类实现类似于c++的多重继承。 使用内部类，还可以获得其他的一些特性：1、内部类可以有多个实例，没个实例都有自己的状态信息，并且与外部类的状态信息相互独立。2、在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。3、创建内部类对象的时刻并不依赖于外部类对象的创建。4、内部类就是一个独立的实体。闭包、回调，和控制框架中都有内部类的身影。 内部类的继承因为内部类的构造器必须连接到指向外部类对象的引用，所以在继承内部类的时候，指向外部类对象的引用必须被初始化。1234567891011public class InnerExtends &#123; class WithInnter&#123; class Inner&#123;&#125; &#125; public class InheritInner extends WithInnter.Inner&#123; public InheritInner(WithInnter withInnter) &#123; withInnter.super(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two Sum]]></title>
    <url>%2F2017%2F09%2F30%2FtwoSum%2F</url>
    <content type="text"><![CDATA[算法练习Two Sum原题：Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 翻译：给定一个整数数组，返回两个数字的索引，使它们相加到一个特定的目标。你可以假设每个输入都只有一个解决方案，而你可能不会使用相同的元素两次。 解决思路：第一种可以用两层循环（时间复杂度O(n^2)），实现代码（纯手打）：123456789public int[] twoSum1(int[] tmp, int target) &#123; for (int i = 0; i &lt; tmp.length; i++)&#123; for (int j = i + 1; j &lt; tmp.length; j++)&#123; if (tmp[i] + tmp[j] == target) return new int[]&#123;i, j&#125;; &#125; &#125; throw new IllegalArgumentException("don't have two sum equals target"); &#125; 第二种可以定义一个map然后把数组的值作为key，索引作为value存到map中，循环数组，每次循环用目标值减去该值，用结果作为key去map中查找，找到了返回索引数组，没找到把该次和循环的值和索引作为key和value存入map中，直到找到结果。（时间复杂度O(n)）实现：1234567891011public int[] twoSum(int[] tmp, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i&lt;tmp.length; i++)&#123; int m = target - tmp[i]; if (map.containsKey(m)) &#123; return new int[] &#123; map.get(m), i &#125;; &#125; map.put(tmp[i], i); &#125; throw new IllegalArgumentException("No two sum solution"); &#125; python实现最近也在学习python，附上python的实现（第二种方案）:1234567891011121314151617class Solution: def twoSum(self, nums, target): map = &#123;&#125; i = 0 for x in nums: if target - x in map: return i,map[target - x] print str(x) + " " + str(i) map[x] = i print map i += 1 returnif __name__=="__main__": a = [5, 4, 9, 3, 7] solution = Solution() print solution.twoSum(a, 10)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2017%2F09%2F29%2FarrayList%2F</url>
    <content type="text"><![CDATA[ArrayListList接口的可调整大小的数组实现。实现所有可选列表操作，并允许所有元素，包括null。除了实现List接口之外，该类还提供了一些方法来操作在内部使用来存储列表的数组的大小。 （这个类大致相当于Vector，除了它是不同步的。）size，isEmpty，get，set，iterator和listIterator操作在常量运行。添加操作以摊销的常数运行，即添加n个元素需要O（n）个时间。所有其他操作都以线性时间运行（粗略地说）。与LinkedList实现相比，常数因子较低。每个ArrayList实例都有一个容量。容量是用于存储列表中的元素的数组的大小。它总是至少与列表大小一样大。当元素被添加到ArrayList时，其容量会自动增长。增长政策的细节不包括增加元素具有不变的摊销时间成本的事实。在使用ensureCapacity操作添加大量元素之前，应用程序可以增加ArrayList实例的容量。这可能会减少增量重新分配的数量。arrayList是线程非安全的。如果要实现线程安全，可以： List list = Collections.synchronizedList(new ArrayList(…)); 使用Iterator去遍历arrayList，如果列表在迭代器创建之后的任何时间被结构化地修改，除了通过迭代器自己的remove或add方法之外，都会抛出一个ConcurrentModificationException，下面这段代码中，因为在iterator创建之后调用了ArrayList的remove方法，所以会抛出异常。12345Iterator iterator = list.iterator(); while (iterator.hasNext())&#123; list.remove(0); iterator.remove(); &#125; ArrayList的实现：12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList几个比较重要的常量：1234/** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; 默认初始容量为10。为什么定义为10？官网上没有给出解释，带着这个疑问我Google了一下，这个默认初始容量可以为任意正整数，为1太少，肯定会做一些大小的调整，100会浪费掉空间，前辈们肯定是做了性能分析和空间分析取出了中间值。1234/** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 用于空实例的共享空数组实例。123456/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 一个空数组实例，当用户没有指定 ArrayList 的容量时(即调用无参构造函数)，返回的是该数组==&gt;刚创建一个 ArrayList 时，其内数据量为 0。当用户第一次添加元素时，该数组将会扩容，变成默认容量为10(DEFAULT_CAPACITY)的一个数组===&gt;通过ensureCapacityInternal()实现，它与 EMPTY_ELEMENTDATA 的区别就是：该数组是默认返回的，而后者是在用户指定容量为0时返回。12345678/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. * */transient Object[] elementData; // non-private to simplify nested class access 存储ArrayList元素的数组缓冲区。ArrayList的容量是此数组缓冲区的长度。任何空的ArrayList elementData的值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA（就是一个空数组）当第一个元素被添加的时候，elementData会扩大到DEFAULT_CAPACITY（也就是10）注意：一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。transient关键字用来用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。ArrayList在序列化的时候会调用writeObject，直接将size和element写入ObjectOutputStream；反序列化时调用readObject，从ObjectInputStream获取size和element，再恢复到elementData。为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。12345/** * The size of the ArrayList (the number of elements it contains). * @serial */ private int size; ArrayList的大小（包含的元素数）。12345678910111213141516171819202122232425262728293031323334353637383940private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; 构造方法ArrayList一共有三个构造方法：123456789101112131415161718/** * Constructs an empty list with the specified initial capacity. * 构造一个指定长度的空列表 * @param initialCapacity the initial capacity of the list * 列表的初始容量 * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; 第一个构造方法主要用于构造一个指定长度的空列表，参数为需要构造列表的初始容量，在这里我们看到当initialCapacity == 0 的时候 elementData = EMPTY_ELEMENTDATA 123456/** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 第二个构造方法构造一个初始容量为10的空list。1234567891011121314151617181920/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) //如果返回值不是Object[]转为Object[] elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 第三个构造方法则将传入的集合转成数组赋值给elementData,如果为空则赋值为上面的共享空数组实例（EMPTY_ELEMENTDATA）。 主要方法接下来看一看ArrayList的主要方法（方法太多就不一一介绍了，有兴趣的同学可以自己看看一源码）：123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 返回指定元素在list中第一次出现的位置。需要注意的是当传入的值为null时并不会报错，因为null也可以作为元素插入ArrayList,查询方式为循环依次查找。如果没有匹配到返回-1。123456789101112public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 与indexOf同理，不过lastIndexOf方法的查找方式为从后向前查找。1234567891011public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; 对原有arrayList实例的浅拷贝。123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; 返回一个新的Object数组，对该数组操作不会影响原有list12345678910@SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; 该方法是传入一个泛型数组a,当a.length&lt;size时，按照list的size创建一个新的数组返回，数组中包含所有list的元素。如果a.length&gt;=size时，则将 list 中的元素按顺序存入 a 中，然后a[list.size] = null, a[list.size + 1] 及其后的元素依旧是 a 的元素,附上测试代码：12345678910public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("a"); list.add("b"); list.add("c"); String[] s = new String[5]; s[0] = "0";s[1] = "1";s[2] = "2";s[3] = "3";s[4] = "4"; String[] c = list.toArray(s); System.out.println(c.length +" " + c[0] + " " + c[1] + " " + c[2] + " " + c[3] + " " + c[4]); &#125; 输出：5 a b c null 4请注意这句话 Make a new array of a’s runtime type, but my contents创建一个新的数组的运行时类型，就是说返回的并不一定是Object[],而是运行时的类型，为什么会出现这种情况呢？原因很简单，因为由于继承的原因，我们父类实例的具体类型，实际上是取决于在 new 时，我们所使用的子类类型。12345public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; 返回指定位置的元素。rangeCheck method: 该方法判断了如果index &gt;= size 则throw一个 IndexOutOfBoundsExceptionelementData method：返回在索引为 index 的元素，主要是避免每次取值都需要强转（看到这里不得不佩服前辈们，要是我自己来写目前肯定封装的不会这么好）1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; 该方法是在指定索引处插入指定元素，并把被替换的元素返回。12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code //防止溢出 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //这里的oldCapacity &gt;&gt; 1相当于 oldCapacity/2 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; add方法就是向list末尾添加数据，但是这时候要考虑容量问题。ensureCapacityInternal方法：若 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 即{}，则取 minCapacity 为 默认容量和参数 minCapacity 之间的最大值。 这里需要介绍一下modCount变量，他是父类AbstractList中的变量主要用于记录arrayList结构变化&gt;的次数，每变化一次增加1.拥有这个参数的方法都是线程不安全的，在一个迭代器初始的时候会赋予它调&gt;用这个迭代器的对象的mCount，如何在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存&gt;储的mcount不一样那就抛异常 grow方法:增加容量以确保它至少能够容纳最小容量参数指定的元素数。如果扩容后大于最大存储容量,则调用hugeCapacity方法，MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8（为什么是Integer.MAX_VALUE - 8呢？只是为了避免一些机器内存溢出，最大长度依然是Integer.MAX_VALUE，并不是Integer.MAX_VALUE-8） 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 在该列表中的指定位置插入指定的元素。将当前位于该位置的元素（如果有）和任何后续元素（向其索引添加一个）移动。1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 移除指定索引位置的元素：index 之后的所有元素依次左移一位 12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; 移除指定的一个元素，索引位置最低的。123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 删除此列表的所有元素。 12345678public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; 将一个集合的所有元素顺序添加到list末尾。12345678910111213141516public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 从指定的位置开始将指定集合中的所有元素插入到此列表中。将当前处于该位置的元素（如果有的话）和随后的任何元素移动到右边（增加其索引）。新元素将按照指定集合的迭代器返回的顺序显示在列表中。123456789101112131415161718192021222324252627282930313233public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; 移除list中和c中共有的元素。1234public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; 保留list中和c中共有的元素。 总结1、ArrayList基于数组实现，其内存储元素的数组为elementData2、ArrayList中EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY._ELEMENTDATA虽然都是空数组，但是使用场景不同。前者是通过ArrayList(int initialCapacity)该构造方法直接指定初试容量为0时，后者是用户直接使用无参构造创建ArrayList时。3、ArrayList的扩容计算为newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 且扩容并非是无限制的，有内存限制、虚拟机限制。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO + github 创建自己的个人博客]]></title>
    <url>%2F2017%2F09%2F24%2FhexoBlog%2F</url>
    <content type="text"><![CDATA[hexo + github 创建自己的个人博客最近想搞一个自己的博客，写一些自己平时工作中的积累，终于搭好了，写一下搭建博客的过程。hexo是一款基于Node.js的静态博客框架,所以安装node.js是必须的（这个就不写了，node官网下载，安装）。申请GitHub（必须）作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 安装hexonode和git安装好后创建一个文件夹blog，安装hexo： sudo npm install -g hexo 执行init命令初始化hexo: hexo init 生成静态页面: hexo generate（hexo g也可以） 配置github建立Repository 建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联，我的blog在本地/user/local/bin/blog，blog是我之前建的东西也全在这里面，有： _config.yml node_modules public source db.json package.json scaffolds themes 现在我们需要_config.yml文件，来建立关联，命令： vi _config.yml 翻到最下面，改成我这样子的 deploy: type: git repo: https://github.com/yougithub/youname.github.io.git branch: master repo也可以写成yougithubname:youpassword@https://github.com/yougithub/youname.github.io.git注意所有的：后面都有一个空格。 生成添加秘钥在终端（Terminal）输入： ssh-keygen -t rsa -C “Github的注册邮箱地址” 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入https://github.com/settings/ssh： 将复制的内容粘贴到Key的输入框，随便写好Title里面的内容，点击Add SSH key按钮即可。可以本地启动服务进行预览，命令： hexo server (hexo s 也可以) 浏览器输入localhost:4000 每次部署的步骤，可按以下三步来进行。 hexo clean hexo generate(hexo g) hexo deploy(hexo d) 参考：http://www.jianshu.com/p/465830080ea9http://www.jianshu.com/p/e99ed60390a8 标签页／分类页 参考：http://theme-next.iissnan.com/theme-settings.html#syntax-highlight-scheme 头像／logo 参考：http://cherryblog.site/Hexo-high-level-tutorialcloudmusic,bg-customthemes-statistical.html 站内搜索 参考：https://zetaoyang.github.io/post/2016/07/08/hexo-localsearch.html]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
